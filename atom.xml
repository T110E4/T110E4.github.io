<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wang Guitong&#39;s Blog</title>
  
  <subtitle>个性化推荐系统、教育数据挖掘</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-16T07:06:08.433Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>T110E4</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度强化学习在教育数据挖掘领域的应用</title>
    <link href="http://yoursite.com/2019/09/16/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9C%A8%E6%95%99%E8%82%B2%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2019/09/16/深度强化学习在教育数据挖掘领域的应用/</id>
    <published>2019-09-16T06:44:52.000Z</published>
    <updated>2019-09-16T07:06:08.433Z</updated>
    
    <content type="html"><![CDATA[<p>Northcutt（2017）为在线教育中的AI提供教程式幻灯片，重点是个性化。 作者提出了在线教育中的AI框架，包括主动/被动课程，内容和学生，并举例说明如下。 主动人工智能指的是课程或经历的变化; 被动AI指的是看不见的估计或建模。</p><a id="more"></a><ul><li>活跃的学生：认知导师</li><li>被动学生：熟练程度估算（IRT）</li><li>活动内容：内容推荐引擎</li><li>被动内容：估计教学视频中的混淆点</li><li>活动课程：从其他课程中自动生成新课程，学生互动; 衡量结果，并迭代</li><li>被动课程：估算新领域的最佳课程先决条件结构<br>Northcutt（2017）提出18个问题，一些有解决方案，一些有想法</li></ul><ol><li>一个问题是表示，即如何将课程表示为向量，如何测量两个课程，视频和学生的相似性，如何向学生推荐内容，以及如何将学生与其他学生匹配等。</li><li>获得表示的一种方法是在课程，内容或学生上使用嵌入。 高维特征矩阵可用于捕获课程，内容和学生之间的交互。 可以使用PCA，SVD等或神经网络的隐藏层来完成尺寸减小。 通过这种嵌入密集的低维表示，我们可以从现有课程，学生配对，推理和结构内容等生成新课程。</li><li>我们可以使用嵌入式MOOCs推荐引擎，使用Siamese神经网络架构，一个网络代表学生，另一个网络用于内容，并生成表示，以便余弦（学生;内容）衡量学生内容的优点。</li><li>Northcutt（2017）还讨论了以下问题，检测挣扎，猖獗的作弊，统计协作，如何个性化，独立处理效果（ITE）/反事实，轨迹预测，如何订购内容，自适应学习，Google学术搜索，论坛中的多数偏见 ，特征提取，认知状态，内容可爱性，混淆点，认知建模，人类智能与人工智能，以及下一个edX。 有关详细信息，请参阅（Northcutt，2017）。<br>最近有一些使用RL的教育工作。</li><li>曼德尔等人。（2014）提出了一种离线政策评估方法，通过将重要性抽样与交叉验证相结合，来研究表示的概括。作者提出了一种针对高维问题的特征压缩算法，该算法受益于PCA和神经网络。此外，作者将该方法应用于教育游戏，通过学习概念选择来优化参与。</li><li>刘等人。（2014）提出了基于多臂强盗算法UCB1的UCB-Explore，通过明确指定这两个目标之间的权衡，自动分配实验样本，在学习每个实验条件的有效性和用户的测试性能之间取得平衡。 作者将UCB-Explore与其他多臂强盗算法（如UCB1和-greedy）与教育游戏模拟进行了比较。</li><li>Upadhyay等。（2018）将强化学习应用于标记的时间点过程，并应用于个性化教育。另见Li等人。（2018a）用于将RL应用于时间点过程。 Oudeyer等人。 （2016）讨论了教育技术中内在动机，好奇心和学习的理论和应用.</li><li>观看名为“与人们一起加强学习”的视频（Brunskill，2017年）。 参见ACL 2018教育应用自然语言处理技术研讨会（NLPTEA 2018），其中包括中文语法错误诊断（CGED）共享任务，<a href="https://sites.google.com/view/nlptea2018/" target="_blank" rel="noopener">https://sites.google.com/view/nlptea2018/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Northcutt（2017）为在线教育中的AI提供教程式幻灯片，重点是个性化。 作者提出了在线教育中的AI框架，包括主动/被动课程，内容和学生，并举例说明如下。 主动人工智能指的是课程或经历的变化; 被动AI指的是看不见的估计或建模。&lt;/p&gt;
    
    </summary>
    
    
      <category term="教育数据挖掘" scheme="http://yoursite.com/categories/%E6%95%99%E8%82%B2%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="深度强化学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>自适应学习的两种设计方案：知识点间和知识点内</title>
    <link href="http://yoursite.com/2019/09/16/%E8%87%AA%E9%80%82%E5%BA%94%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%EF%BC%9A%E7%9F%A5%E8%AF%86%E7%82%B9%E9%97%B4%E5%92%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%86%85/"/>
    <id>http://yoursite.com/2019/09/16/自适应学习的两种设计方案：知识点间和知识点内/</id>
    <published>2019-09-16T04:58:18.000Z</published>
    <updated>2019-09-16T05:00:46.777Z</updated>
    
    <content type="html"><![CDATA[<p>原创： 冯俊晨  爱行知  2017-02-03<br>今年春节，JC根据自己的研究经历，重新写就了一篇他对自适应学习的两种设计方案的思考和总结。值得这个研究方向的童鞋参考和探讨。<br>作为背景，我把和JC第一稿时讨论的若干问题简要放在这里，可以供大家发散：</p><a id="more"></a><p>（1）目前基于我自己课程设计的进展和要求，许多时候我是把孩子的发现能力和知识建构过程（及伴生要求）当做教育目标的，我不确认知识点和知识图谱是否能够完备描述这种学习过程——或者需要多大程度的重新定义。所以我也不太确认在这种课程和学习架构下，自适应学习应当怎样设计。（当然需要坦承的是，目前这种架构的课程体系和学习本身还非常不成熟，遑论一个可以相互促进的计算机自适应系统。但未来我会集中精力投入到这个方向）<br>（2）和自适应学习系统优化最相关的是优化目标的确定，也就是文中的“掌握程度（Mastery）”的概念。我们都承认这个概念是一个朴素的非严格数学意义上定义的概念，而且我们俩基本一致的是，最本真的掌握程度的确定需要教师和实证实验的紧密结合——而这不像“点击率”那么直观和方便，所以这有两个判断：其一，自适应学习的迭代优化一定是一个缓慢的过程（指的是在效果认定和优化层面，不是指技术系统的细节）；其二，目前大部分国内的系统都没有经历足够的优化过程。</p><h2 id="1-知识点间自适应"><a href="#1-知识点间自适应" class="headerlink" title="1.知识点间自适应"></a>1.知识点间自适应</h2><p>知识点间自适应方案主要对于知识点的学习顺序进行优化。大部分“基于知识图谱”的自适应学习都属于这个大类下。</p><p>这种自适应方案的核心问题是：</p><p>假设有一个知识点集合，是否存在一个学习路径，使得学生在掌握前置知识点的前提下，必然能够沿着这个学习路径掌握所有的知识点？<br>比如说，Khan Academy构建了一张数学知识图谱，为每一个知识点都刻画了一个学习路径。它的暗含假设是，如果一个学生掌握了这个路径上的全部前置知识点，他必然可以通过练习掌握这个知识点。因此，只要按图索骥，就可以避免Khan所担心的知识网络“奶酪式”成长（aka都是洞）的问题。</p><p>因为知识图谱上的学习路径是唯一的，Khan Academy的自适应仅局限于对于学习速度的自适应。如果学生A花了一周还没有学会几何法求解空间二面角，他应该花更长的时间来巩固这个知识点直到掌握。如果学生B花了一天就学会了，他应该继续去学别的内容。这相对于统一步调的课堂教学而言，的确是一个实质性的改进。但是，Khan Academy式的知识图谱不能针对掌握水平分布进行自适应。如果学生A并不擅长几何思考，但是熟练地掌握了空间直角坐标系，为什么他不能通过空间直角坐标系来解决这个问题呢？</p><p>上述例子展示了绘制知识图谱所面临的巨大挑战。知识图谱是否只有一种画法？同一个知识点是否只有一条路径？ALEKS从理论上为这两个问题提供了解答。即使知识图谱不只有一个，通往同一个知识点的路径不只有一条，可以学会全部知识点的可行路径依然存在。但是可行路径的数量级可能在千万级。</p><p>仅仅有知识图谱并不足够，系统还需要对于学生在每个知识点上的掌握程度进行诊断。掌握程度（mastery）之所以困难，是因为它是一个不可见的抽象构架。学界和业界对于该如何定义“掌握”存在比较大的分歧。例如，老版的Khan Academy用了最简单的“连对10个就算掌握”的规则。Duolingo也使用预测正确率作为用户掌握某个词汇或者语法的依据。从智能教学系统科班出身的自适应系统，例如卡耐基学习出品的Cognitive Tutor或者Knewton，都使用结构模型来定义掌握程度和做题结果的关联，从而部分抵消题目特性对于掌握程度推断的影响。例如，75分到底是掌握水平高，还是掌握水平低呢？如果平均分是60分（题目偏难），75分可能说明学生的水平相当不错；如果平均分是90分（题目偏易），75分可能说明学生的水平相当糟糕。</p><p>传统的知识点间自适应系统只对于学生做过题的知识点进行掌握程度推断。更复杂的一点自适应系统，（例如Knewton），会使用知识点间的关联关系来推断学生未做过题的知识点的掌握程度。这种关联推断只能算是锦上添花。尽管它降低了学生学习整个图谱所需要完成的最低做题量，但是它并没有提供探索可行学习路径的更好办法。</p><p>“知识点间自适应”是一个在直觉上合理并且在技术上成熟的设计方案。今天我们在中国看到的自适应学习系统，大部分属于这个类别。然而，“知识点间自适应”系统在美国的实际使用中效果差强人意。Eric Taylor 对智能学习系统的实证效果进行了综述，发现大部分混合教学并没有取得比课堂教学更好的教学效果。笔者认为原因有三：</p><ul><li><p>第一，教材本身内含了一个设计良好的知识图谱和学习路径；由第三方教学专家构建的图谱和路径，未必有久经考验的教材版本效果更好。</p></li><li><p>第二，“知识点间自适应”要求老师允许学生以不同的速度学习，从而出现自然的教学分层现象。不论从政治环境上，还是从老师的教学负担上，教学分层都只能是一个“看上去很美”的教学设想。由于大部分知识点间自适应系统并没有ALEKS那样的基于掌握水平的自适应，而只有基于速度的自适应，不允许学习速度分化，事实上扼杀了自适应系统的优势。</p></li><li><p>第三，知识点间自适应和老师的替代性超过互补性，因此老师使用自适应系统后偷懒也可能是效果不章的原因之一。</p></li></ul><h2 id="2-知识点内自适应"><a href="#2-知识点内自适应" class="headerlink" title="2.知识点内自适应"></a>2.知识点内自适应</h2><p>知识点内自适应方案在给定知识点内的不同题目之间进行筛选和排序。笔者认为这与国内大部分题库产品比较类似。笔者不能确定它们是否采用了这种自适应设计方案，因为它们对于自己的方法论讳莫如深。</p><p>“知识点内自适应”是一种颇具中国特色的产品形态。在美国，由于可公开获得的题库不论在数量上和质量上都难以尽如人意，因此大部分自适应学习系统在知识点内都采用计算机出题的模式，包括Khan Academy，Duolingo，Cognitive Tutor和ALEKS。这些题目本身高度雷同，因此并不存在太多的自适应空间。但是这种可控程度较高的练习题生成方式基本没有被中国的教育互联网公司采用。笔者认为一方面是成本的考量，另一方面也是用户体验的考量。从成本上说，在国内获取一个数目客观、质量尚可的题库较挨个知识点写生成器要便宜的多，也要快得多。从用户体验上说，家长和老师可能更希望练习题目应该类似于考试题目（特别是初高中学段）。此外，国内教学环境对于“超纲”比较敏感，知识点间自适应在不能自由选择教学进度的前提下并没有太大用武之地。因此，利用一个数量庞大且品质参差不齐的题库进行知识点内练习（和教学）推荐，是一个非常具有中国特色的技术问题。</p><p>这类推荐系统需要回答的核心问题是：</p><p>假设有一个题库，是否存在一个练习路径，使得学生以最少的做题量达到某个预先指定的熟练程度？<br>这里有两点值得强调：</p><p>第一，这个问题与传统上的计算机辅助测试（Computerized Adaptive Testing），比如ETS的TOEFL和GRE，具有本质的区别。CAT的问题是，假设被试者能力不变，给定一个题库，是否存在一个测试路径，使得系统以最少的题量将学生能力估计到某个预先指定的熟练程度。因为CAT从根本假设上否定了通过练习进行学习（learning through practice）的可能性，因此使用IRT/CAT做推荐引擎的知识点内自适应学习产品都有一点“挂羊头卖狗肉”的嫌疑（但是知识点间自适应系统并不存在这个问题）。</p><p>第二，这个问题与传统上的协同推荐算法，比如淘宝，具有本质区别。协同推荐的问题是，假设每一个用户的偏好不变但是用户之间的偏好不同，是否存在一个办法可以通过用户的行为对于用户进行分类，从而为每一个类别的用户提供更适合其偏好的产品或服务。与CAT系统一样，协同推荐算法从根本上否定了学习的可能性，因此其推荐逻辑不具有教学逻辑。因为有和你类似做题记录的学生做错了这道题，所以你也应该试试这道题。这是一个非常糟糕的教学逻辑（如果有任何教学逻辑的话）。</p><p>知识点内自适应可以说是一个还有待进一步研究的领域。笔者在此仅阐述一个理论框架。</p><p>一个描述动态学习的系统首先要定义什么叫“学习”（learning）。一个直观的办法是把学习和掌握程度（mastery）联系起来，将其定义为低掌握程度到高掌握程度的转换概率。每一个掌握程度由一套可观察的表现来定义。比如，给定一道题，90分以上是精通，60-90是掌握，60以下是未掌握。学习可以定义为从“未掌握”到“掌握”的概率（渐悟），也可以定义为从“未掌握”到“精通”的概率（顿悟）。这并不是唯一的定义方法，但可能是最简单但是不失普遍性的定义方法。</p><p>定义了学习，就可以定义“学习差异性”（learning heterogeneity）。差异性是构造自适应系统的根本原因，否则最优的教学方案会是千人一面而不是千人千面。学习差异性可以抽象成：<br>（1）水平差异性：目标是“精通”，题目对于“未掌握”和“掌握”的学习者的效果应该不同。<br>（2）速度差异性：目标是精通，起点是“掌握”，题目对于一个快速学习者和慢速学习者的效果应该不同。<br>如果接受这套定义，接下来有两个重要的实际问题需要回答：<br>（1）上述定义系统中的参数是否可以被数据估计？<br>（2）如果估计了这些参数，如何构建一个推荐逻辑？<br>遗憾的是，笔者自己的研究表明，问题（1）的答案可能是否定的。只有在特定的题目顺序结构下，题目的参数和用户的类型才能被估计。但是如果我们忽视速度差异性，问题（1）的答案可能是肯定的。<br>问题（2）与其说是一个技术问题，不如说是一个教学问题。笔者认为，推荐逻辑应该由“测评-教学”的两步循环来构成。在测评环节，练习推荐侧重于题目的区分度和测量精度，从而区分用户的不同类型；在教学环节，根据学生类型，练习推荐侧重于题目的教学效果。在下一个测评环境，练习推荐再测试学生的水平和类型，如此循环往复，直到学生达到指定的熟练程度为止。<br>此外，练习推荐也应该注意对于用户留存的影响，如果学生不持续地投入地练习，不论推荐逻辑再优秀，也无法展现其应有的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原创： 冯俊晨  爱行知  2017-02-03&lt;br&gt;今年春节，JC根据自己的研究经历，重新写就了一篇他对自适应学习的两种设计方案的思考和总结。值得这个研究方向的童鞋参考和探讨。&lt;br&gt;作为背景，我把和JC第一稿时讨论的若干问题简要放在这里，可以供大家发散：&lt;/p&gt;
    
    </summary>
    
    
      <category term="教育数据挖掘" scheme="http://yoursite.com/categories/%E6%95%99%E8%82%B2%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="自适应学习" scheme="http://yoursite.com/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>一套自适应学习系统应该包括哪些环节？</title>
    <link href="http://yoursite.com/2019/09/16/%E4%B8%80%E5%A5%97%E8%87%AA%E9%80%82%E5%BA%94%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E5%BA%94%E8%AF%A5%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E7%8E%AF%E8%8A%82%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/09/16/一套自适应学习系统应该包括哪些环节？/</id>
    <published>2019-09-16T00:51:31.000Z</published>
    <updated>2019-09-16T04:56:46.994Z</updated>
    
    <content type="html"><![CDATA[<p>去年年初美国著名的自适应学习平台Knewton完成了一笔5200万美元F轮的融资，国内研发自适应学习产品的乂学教育更是在天使轮融资就达到了1.2亿元人民币，一瞬间国内涌现出越来越多的自适应学习应用，甚至全球范围内宣布做自适应学习机构中有 70% 来自中国。</p><p>热闹的背后我们不禁反思为什么要做自适应教学？一套自适应学习系统又包括了哪些环节？对于创业者而言又该如何用自适应教学提高自己的产品差异化？</p><a id="more"></a><h2 id="为什么要做自适应学习？"><a href="#为什么要做自适应学习？" class="headerlink" title="为什么要做自适应学习？"></a>为什么要做自适应学习？</h2><p>任何教育科技都不是万能药，我们首先应该带着怀疑的眼光去问，为什么要做自适应学习？常见的理由有这么几个。</p><h3 id="A-自适应作为一个营销的噱头"><a href="#A-自适应作为一个营销的噱头" class="headerlink" title="A. 自适应作为一个营销的噱头"></a>A. 自适应作为一个营销的噱头</h3><p>这个看起来是一个不错的理由，用这个噱头与自己的竞品打差异化。但从我过去的经验来看，自适应是一个不太好的宣传方式。考虑到自适应的概念并不普及，这相当于你在面向最终用户之前首先要教育用户。虽然自适应非常好，可是假如用户不买账，这就会很尴尬。</p><p>如果直接宣传产品的效果，弱化自适应，我倒觉得是一个比较明智的方法——比如可以这样宣传：“我们这个产品在试点的时候可以提XX分”，如果用户问起为什么能提分，可以回答：“因为我们有一个自适应的学习引擎”。</p><p>打一个比方：小米手机，如果它整天都是在宣传自己的手机是什么参数的CPU、GPU，用户会产生很大的困惑。因此在实际宣传中，他会说小米是跑分最快的，为什么呢？因为用了XXX、XXX等芯片和技术。同理，Tesla也不会整天宣传他们用的s是什么发动机，而直接会说，特斯拉百公里加速度3.9秒，拥有超过布加迪的推背感。</p><h3 id="B-自适应可以诊断出学生更详细的学习问题"><a href="#B-自适应可以诊断出学生更详细的学习问题" class="headerlink" title="B. 自适应可以诊断出学生更详细的学习问题"></a>B. 自适应可以诊断出学生更详细的学习问题</h3><p>有一些厂商只是对题库打了标签，然后就号称自己做了一套自适应的学习系统；有的还会打印出几页纸的详细报告让家长掏钱。实际上用户得知自己上千个标签的学习情况这件事本身的价值就如同患者去医院抽血后，医生给你一张密密麻麻的检验报告单，不给任何意见就直接让你自己去药店拿药一样。</p><p>很显然，使用电脑的用户要的不是查毒软件，而是要杀毒软件，对于学生来讲，诊断不过是自适应学习的一个初期环节，如果只有诊断，却没有治疗，自适应学习的学、练、测评闭环是不完整的，只能说是一个高级一点的评测项目。</p><h3 id="C-自适应学习系统可以让每一个人有与众不同的学习路径"><a href="#C-自适应学习系统可以让每一个人有与众不同的学习路径" class="headerlink" title="C. 自适应学习系统可以让每一个人有与众不同的学习路径"></a>C. 自适应学习系统可以让每一个人有与众不同的学习路径</h3><p>过去，在没有自适应学习、又不是一对一的情况下，只能做分层、分班教学。有了自适应，似乎就可以让每一个学生拥有专门属于自己的一条路径。可是一人一个路径这个说法是有缺陷的，是完全忽略了同学们之间需要社交、老师需要统一管理学生的现实需求，更何况学生需要知道他自己在整个知识体系里所处的位置。</p><p>可汗学院经常会提到Mastery Learning（掌握学习）这个概念。过去的课堂里，为了统一教学进度，不管学生学得是否扎实，都会讲下一个章节。而Mastery Learning认为只要每一个学生在不同的环节花充分的精力，都可以打好扎实的基础。</p><p>一个自适应的学习系统，应该符合Mastery Learning的教学法则。什么意思呢？学生刚开始使用系统的时候，他的知识网络可能跟奶酪一样里面全都是洞，可是随着时间的推进，之前的知识漏洞应该被补上了，新暴露的问题也是可以归类的。</p><p>虽然每一个人的路径看起来不同，但是针对某一个知识点总能找到具有相同问题的同学。所以自适应学习完全是可以做在线大班课的。比如某一个同学对不懂的知识点进行了反馈，平台通过算法找到该学生，然后把相同问题的学生聚在一个虚拟的教室进行教学，既实现了自适应教学，又不会有一个人在网上学习的孤独感。其实这非常像王者荣耀，通过天梯的机制，让能力相近的人匹配在一起。</p><p>传统的知识结构，不应该是加上自适应学习后就全盘推倒的。几年前曾经有过一款智能音乐推荐引擎叫做Jing.fm，技术很先进，也对各种歌曲打了标签，但是只有推荐和搜索两种方式，没有专辑、作曲家，或者是汇总专辑的分类方法。纯靠推荐是Jing.fm的项目失败的一个原因之一。用户还是会有自己的自主性，自适应不应该是强制规定的路径，而更应该是在自由的情况下给用户一定的引导。</p><h3 id="D-自适应可以让学生哪里不会补哪里"><a href="#D-自适应可以让学生哪里不会补哪里" class="headerlink" title="D. 自适应可以让学生哪里不会补哪里"></a>D. 自适应可以让学生哪里不会补哪里</h3><p>基本上这个思路是对的。问题是该怎么补？学生在反比例函数的定义域上有了问题，就推送20道相关题直到用户彻底掌握为止，显然是一种反人性的教学法。为每一个细节知识点都配上8分钟的精彩微课，又工作量太大。</p><p>做过自适应学习系统的朋友都应该知道，最难的环节不是技术开发，而是通过教学和教研，发现了学生的问题，而怎么让学生从学不明白到学明白，这才是自适应学习最大的价值。</p><p>甚至，就算没有上线自适应学习，如果真的研发出来的内容已经能够做到学生学习之后，一定会从“不会”转变为“会”，那么完全可以设计一种课程结构，由主线课程和支线课程构成，主线是必学的，支线是学生自己发现自己有问题选学的，这种课程结构也完全可以解决大量学生哪里不会补哪里的问题。</p><p>所以当很多人关注点还在如何找到学生的问题时，其实真正关键点还是，找到了问题之后，如何解决这个问题，所谓自适应学习的核心，依然是做好教学。</p><p>好的教学，没有自适应，依然是一个好产品。</p><p>好的自适应，没有好的教学，依然是一个不好的产品。</p><h3 id="E-自适应学习，就是要去适应人脑的学习方法"><a href="#E-自适应学习，就是要去适应人脑的学习方法" class="headerlink" title="E. 自适应学习，就是要去适应人脑的学习方法"></a>E. 自适应学习，就是要去适应人脑的学习方法</h3><p>这是我认为自适应学习最合适的定义。</p><p>大脑的学习方法与电脑拷贝文件的方法差别太大了。电脑可以几秒钟拷完一本辞海，而人脑学习这么多词汇，可能终其一生都学不完。</p><p>我在和一些创业团队聊的时候反复强调，自适应首先不应该是知识的自适应，而应该是engagement（投入度/情绪）的自适应。一个学生，你为他设计了上千种不同的路径，可是他还没有到第一个岔路口就觉得没意思离开了，你的路径就属于白设计。</p><p>举一个我自己生活中的例子，为了锻炼我孩子的跳跃能力，我几个月前在走廊的天花板上用一根绳子栓了一个气球，正好把高度设计成他跳五次，大概有两三次能摸到。在那几天里，他对什么高级的故事机、乐高都失去了兴趣，就喜欢路过那个走廊去够那个气球，可以玩个不停。等我回家时发现他明显跳得更协调，也更容易够到了，于是再把绳子缩短一节，构成新的挑战。</p><p>一个自适应的产品，不应该是设计成用户哪里不会就做哪里，一直受挫，最简单的设计其实就是不断让用户一会儿有一些成就感，过一段时间又有一点挑战，让学习成为一个上瘾的过程。ZPD理论强调，最佳的学习内容，应该是用户够着脚尖就将将能够到的。</p><p>大脑是喜欢新鲜感的，一定要把东西混在一起来，自适应从来也没有规定说必须有了错误就马上解决，很大程度上，遇到了问题，这周内能解决就足够了。举一个直接例子，用户hit和height说不清楚，那也不应该是马上给他出kit和kite、bit和bite、spit和spite等一大堆训练，而是应该在后续的练习里更加注意穿插一些短音长音的练习即可。</p><p>很多背单词软件，或者类似anki、memrise这类记忆软件，都强调自己采取了符合大脑遗忘曲线的方法（所谓用spaced repetition去使用艾宾浩斯遗忘曲线），然而却认为“简单重复”的记忆编码方式是一个好的方式。实际上同一个词汇，或者知识点，应该是在不同的场景下出现才有价值。就像错题本一样，如果每次都是出同样的题目，学生都已经记住了答案，对于其复习巩固毫无意义。一定是要出近似，而不完全一样的题目。</p><p>当然判断近似习题不应该只看题面，而更应该关注解题方法和技巧。下面这两道求阴影面积题看起来是同类习题，但实际上，做起来思路和难度完全不一样（大家不妨试试看）。</p><h2 id="一套自适应学习系统应该包括哪些环节？"><a href="#一套自适应学习系统应该包括哪些环节？" class="headerlink" title="一套自适应学习系统应该包括哪些环节？"></a>一套自适应学习系统应该包括哪些环节？</h2><h3 id="A-收集学习行为数据"><a href="#A-收集学习行为数据" class="headerlink" title="A.收集学习行为数据"></a>A.收集学习行为数据</h3><p>需要一套学习行为统计框架，以日志形式结构化地记录学生的详细学习行为。通常来讲，一个日志条目以json格式呈现，包括用户id、题目/视频/学习行为id、触发时间、有效的学习时间、停留时长和与这个行为相关的个别属性。</p><p>例如视频可能会包括播放时长、拖动时间轴的次数、中途是否暂停离开、视频交互的答案、是第一个观看还是复习巩固等等。而题目要包括学生的选项是否正确、是否使用提示、是否查看解析、是否收藏题目等等。国际上的行为数据标准是xAPI（原名tincanapi）但是过于复杂的标准让其无法普及开来，只能借鉴学习。</p><h3 id="B-存储、初加工学习行为数据"><a href="#B-存储、初加工学习行为数据" class="headerlink" title="B. 存储、初加工学习行为数据"></a>B. 存储、初加工学习行为数据</h3><p>数据统计后，自然要存放一份儿到一个原始的数据中心，但是光存放是不够的，还要对数据进行初加工。初加工的过程可以判断出来，学生快速做题后，根据答题的正确率，可以判断出学生是作弊了还是没有认真答题。如果学生反复做同样一套题，可能会涉及刷分。只有过滤掉脏数据后，才能把干净的数据作为训练样本进行学习。</p><p>正常来讲IRT模型对于每一道题目要求至少有1000个不同的、干净的做题数据才能初步收敛。这个初加工的过程中就可以对一些“大块的”事件进行标注，例如，学生下午3点打开《极限的定义》这节课是属于认真学习，还是属于敷衍了事，还是复习巩固？当学生、家长和老师去查看学习轨迹的时候，他们并不想知道每一个细粒度的行为，而更想要知道粗粒度的概况。</p><h3 id="C-用学习行为更新学生的知识点网络"><a href="#C-用学习行为更新学生的知识点网络" class="headerlink" title="C. 用学习行为更新学生的知识点网络"></a>C. 用学习行为更新学生的知识点网络</h3><p>学生的知识点网络模型的每一个节点都会有两个值，一个是掌握度，一个是置信因子（confidence level）。当学生刚进入自适应学习系统的时候，系统是不清楚学生每一个节点的学习情况的，所以置信因子是最低的；当学生做得题越多时，置信因子会不断变高，掌握度也会更加准确。举一个直接的例子，张三两道题做对两道，和李四100道题目做对98道，如果题目难度和知识点完全一样，实际上李四有更大概率比张三学习更好，但是从分数来讲，张三的分数是100分，李四却是98分。置信因子正是解决这个矛盾的关键点。</p><p>初始化的时候可以认为学生什么都不会，如果是高三总复习阶段，也可以按照系统平均水平去初始化（所谓有易错、较难知识点）。</p><p>真实的题库里，一定有不同难度、考察多个知识点、涉及不同技巧和方法，所以标注好的题库是自适应学习的前提，这背后的教研工作量浩大，远比开发系统所需要的技术困难。知识点与知识点之间也会形成依赖、组合、干扰等各种关系，所以搭建一个细粒度的知识图谱也是有一定难度的。这里我们不会展开，下一讲我会专门针对知识图谱、题库和算法进行深入讲解。</p><h3 id="D-学习结果可视化-改变路径，形成完整闭环"><a href="#D-学习结果可视化-改变路径，形成完整闭环" class="headerlink" title="D. 学习结果可视化+改变路径，形成完整闭环"></a>D. 学习结果可视化+改变路径，形成完整闭环</h3><p>自适应学习系统的可视化应该直观，应该多做减法，多把详情隐藏起来，而让用户看到最关键的信息。</p><p>学生既然遇到了问题，或者有了进步，一定要让学生、老师、家长能够一目了然地看到。详细知识点列表和雷达图似乎是自适应系统的标配，但是真正更有价值的是学生接下来关注什么，对于老师最大价值也不应该是全班的知识图谱列表，而是应该关注哪些易错题，关注哪些普遍的知识点缺陷，并且找到那些需要重点关注的学生。</p><p>路径的改变一般有多种方式，一个是改变用户的学习流，原来是abc，现在改为abdc——这种方式偏向强制性，要求学生必须完成规定动作。另外一种是解锁型，原来你不用去学这个课，现在出现了一些新的题目和课程可以去学习——这种方式的自由度更大，但学生完全可以选择不去学习。</p><p>我个人推荐的是通过游戏化的任务系统去完成自适应的推荐，学生一方面可以按照课程顺序或者自己想学的顺序去学习，同时会有一个任务系统引导他去完成主线、支线的任务。学生如果按照我行我素的方式学习得到的“虚拟奖励”积分少，如果是按照系统的引导去完成，得到的“虚拟奖励”积分多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年年初美国著名的自适应学习平台Knewton完成了一笔5200万美元F轮的融资，国内研发自适应学习产品的乂学教育更是在天使轮融资就达到了1.2亿元人民币，一瞬间国内涌现出越来越多的自适应学习应用，甚至全球范围内宣布做自适应学习机构中有 70% 来自中国。&lt;/p&gt;
&lt;p&gt;热闹的背后我们不禁反思为什么要做自适应教学？一套自适应学习系统又包括了哪些环节？对于创业者而言又该如何用自适应教学提高自己的产品差异化？&lt;/p&gt;
    
    </summary>
    
    
      <category term="教育数据挖掘" scheme="http://yoursite.com/categories/%E6%95%99%E8%82%B2%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="自适应学习" scheme="http://yoursite.com/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>自适应学习-技术篇</title>
    <link href="http://yoursite.com/2019/09/15/%E8%87%AA%E9%80%82%E5%BA%94%E5%AD%A6%E4%B9%A0-%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    <id>http://yoursite.com/2019/09/15/自适应学习-技术篇/</id>
    <published>2019-09-15T13:26:34.000Z</published>
    <updated>2019-09-16T04:56:48.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自适应学习技术"><a href="#自适应学习技术" class="headerlink" title="自适应学习技术"></a>自适应学习技术</h2><p>前面我曾提到，“我认为，自适应学习是在学习研究的范式下，一种以计算机技术为主导的学习环境和系统的横向探索，而且是一种意义重大的探索”。这种意义我这里不再讨论，之前站正面立场时也曾讨论过。我们这里，是通过跳出现有产品经验的方式下，来探讨自适应学习和自适应技术。更多的是来自学术界已经做过的探索。<br>但作为与学习研究范式的连接，我们有必要简单提及一个问题，后面我不再详细讨论这个问题。那就是，持有研究范式的不同，会怎样影响研究者研发自适应学习系统？这涉及到研究范式到教学设计，由教学设计到学习环境和系统搭建的翻译和影响。我觉得这是一个有意思的问题；前面很多自适应技术的文章，都会谈及知识图谱，但不会谈及人的情感变量和社会协作中的问题，我觉得一方面是为其产品背景和阶段所限定，另一方面也和研发团队一开始的范式切入口有关。</p><a id="more"></a><p>既然把自适应学习篇放到学习的研究范式之后，我期望所讨论的自适应技术思路，尽量不为某一种范式所限制。如我一开始所说，通过计算机技术来使得教和学具备自适应特点，这本身应该是一个横向研究领域，相对不同的学习研究范式而言。<br>从应用角度看自适应<br>自适应学习的四维图<br>自适应学习是一种基于计算机技术的系统研究，很自然它有一系列非常直观而且朴素的问题需要回答，根据Mieke Vandewaetere, Geraldine Clarebout对四维视图的界定，那就是：</p><ul><li><p>它在学习中改变的是什么？</p></li><li><p>在学习中因何而改变？</p></li><li><p>在何时发生这种改变？</p></li><li><p>怎样才能使得学习发生这种改变？</p></li></ul><p>这四个问题，分别是自适应学习的四个维度，也是适应的——对象，来源，时间或情境，及方法。这是一种系统研究方法，很显然和学习研究范式中对于学习关键要素的回答是不同的。<br>具体而言，自适应学习的四维视图如下：<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70ivu0xdij30hs0g8aah.jpg" alt="undefined"><br>所以，在教和学的体系中，自适应学习的应用涉及如下四个方面：</p><ul><li><p>1.适应的对象（改变什么）：适应性教学可以调整的对象包括三个方面，关注点是系统中哪些内容可以调整。首先是改变内容或者题目，如可以通过区分任务或项目的难度水平改变内容。其次是改变学习内容的表征形式和路径选择，如隐藏或突出显示链接。再次是通过间接指导调整教学水平和可用的支持。</p></li><li><p>2.适应的来源（因何改变）：这个层面也可以关注三个方面，首先是学习参数，如学习者特征和学习结果，其次是学习者和系统的交互，如学习者对于模型可视化的反馈和调整交互，或者与系统的博弈行为，再次是教学的变量，如教学目标、反馈类型、脚手架等。</p></li><li><p>3.适应的时间（何时改变）：第三个维度就是适应性学习的时间或情境，适应性在什么时间或情境发生。这个包括静态的用户建模和动态的用户建模，双路径方法也是可以实现的，一般是一次测量学习者特征之后进行首次调整，随后基于学习者交互参数持续进行建模和调整。</p></li><li><p>4.适应的方法（如何改变）：最后一个维度区分了学习者控制的适应，以及系统控制的适应，或者两者组合的适应。系统控制的适应大家见到的比较多，而学习者控制的适应，强调学习者可以完全控制学习环境和内容。两种适应方法各有优劣，有人就提出共享控制适应，它首先选择一组合适的学习材料或任务，然后考虑学习者的特征以便适应，随后，学习者可以自由的选择材料或任务，两者兼之。</p></li></ul><p>自适应学习的四维视图，非常直观、朴素但又非常准确的描述了自适应学习应用中涉及的核心问题，以及背后的复杂系统。一个教和学的过程的适应性，需要解决这些核心问题。</p><p>但再进一步，主要是面向学习者的自适应，和主要是面向教育者的自适应，也是不同的，我们随后分别展开。</p><h2 id="面向学习者的自适应学习系统"><a href="#面向学习者的自适应学习系统" class="headerlink" title="面向学习者的自适应学习系统"></a>面向学习者的自适应学习系统</h2><p>我们之前的系列文章——也就是我们市场上常见的自适应学习系统，都是主要面向学习者的。所以面向学习者的自适应学习系统我们更加熟悉。</p><p>一个面向学习者的自适应学习系统，有四个基本的循环阶段，分别是获取（当学习者与环境交互时收集学习者数据）、分析（创建和维护一个与领域相关的学习者模型）、选择（根据学习者模型和系统目标来选择信息）和展示（根据选择过程的结果向学习者展示信息内容）。</p><p>这四个方面又可以有很多路径的变种，代表了不同系统和自适应学习的能力，对用户的体验有非常大的不同。比如基本完整的系统是学习者获取、分析、选择、展示所有步骤走完，而一个修正的系统是增加一个核心环节，四个循环步骤中增加用户对于学习者模型的交互，因为增加了对学习者模型的交互，所以系统是更加多样化的，且有助于学习者的元认知的培养。另外一种修正方式是，略去选择环节，这就是学习者获取、分析和展示一个小循环，这是一个检测路径的系统。这是两种例子。</p><h2 id="面向教育者的自适应教学系统"><a href="#面向教育者的自适应教学系统" class="headerlink" title="面向教育者的自适应教学系统"></a>面向教育者的自适应教学系统</h2><p>我之前系列文章中曾经提到过，但没有针对性讨论的是面向教育者的自适应教学系统。这样的系统在我所见的行业内状况来看是不多的（只有一个朋友他们曾经自我定位是做智能教师系统，是类似这个层面的事情），但学术界对适应性教学系统还是有研究的。</p><p>我们先岔开一下，对于教育者而言，使用自适应教学系统可能会存在一些障碍，尤其是国内环境。自适应的教学系统对于每一个学生而言，必然是个性化的教学。但个性化教学对教学进度的控制、对课程管理等等，都是和现有教学体制冲突非常大的，而且，教师的能力模型也存在一定的问题。所以公立教育系统中，应该很难推广这种教育技术的产品。在培训市场中，我觉得一方面以线下见长的团队，其教育技术研发能力可能受限，另一方面，无论是SPOC还是双师，都是跟着培训市场的投入产出比来走的，而自适应教学系统——可能还很漫长。</p><p>根据Jung Lee和Ok-ChoonPark的整理，开发和实施适应性教学有五种不同的方法。</p><p>第一种方法是在宏观水平上改变教学，允许不同的教学目标、课程内容难度和传递系统等等。为替代学校中传统的固定步调的集体教学而开发的适应性教学大部分采用这种方法。</p><p>第二种方法是根据学生的具体特征调整具体的教学过程和策略。这种方法要求确定与学生最相关的学生特征（或者能力倾向），并为具备此特征的学生选择最能促进其学习过程的教学策略。</p><p>第三种适应方法是在微观水平上改进教学，在教学过程中动态诊断学生特定的学习需要，为不同需要的学生提供不同的教学。例如智能导师系统。</p><p>第四种方法是适应性超媒体和web系统。因为其是基于web系统的，所以其资料库是开放的。</p><p>第五种方法是基于特定教学法开发的可适应系统。应用这些系统中的教学方法包括建构主义、动机理论、社会学习理论和元认知等。 </p><p>虽然有这五种常用方法，一方面可以根据具体场景来选择，另外也常常可以做一混合式系统，以面对现实的复杂性。而且，在具体学习的研究范式中，还有许多深入问题可以探索，如将认知负荷理论应用于自适应教学，就是一个探索方向。</p><h2 id="自适应技术路线"><a href="#自适应技术路线" class="headerlink" title="自适应技术路线"></a>自适应技术路线</h2><p>我们接下来探讨具体的自适应的技术路线。先把之前的内容框架图重新展示一下：<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70ixe896xj30hs0deq3n.jpg" alt="undefined"><br>关于调整教学内容的基本原理</p><p>因为自适应系统的一个关键，就是自动分析并干预（调整教学内容）的能力，所以我们先重点分析一下调整教学内容的基本原理。之前自适应学习的四维视图中曾提到适应的来源，这里大概可以认为，我们重点分析一下学习者和学习的参数。</p><p>第一个重要的依据是学习者的初始知识、能力的差异。这种差异是真实的、常常很大，对后续环节的影响强而有力。但我们系统中的教育方法往往并不能很好的服务于多样化的学生人群。也有很多人认为初始知识是随后学习唯一重要的决定因素（学习的研究范式中曾提到，符号认知理论研究者）。</p><p>第二个重要的依据是学习者的人口学和社会文化变量的差异。这种差异也是客观的，比如语言的丰富度和成熟度，家庭核心成员的社会背景与终身学习习惯，等等，且可能影响学习结果和最终成就。</p><p>第三个重要的依据是学生的情感状态。学生的许多情感状态会深刻影响他的学习，如沮丧、厌倦，或者积极、信心等。有很多种非介入性的措施可以推断学习者的状态来改变教学环境以适应不同需求。 </p><p>这三个重要依据，是我们调整教学内容的基本原理。</p><p>基于知识和学习目标特征的自适应</p><pre><code>早期的自适应技术，将注意力集中在诸如学习者的知识和学习目标特征上。包括国内我们的一些商用自适应学习系统，多数也是如此。我们之前系列文章的大量案例，都在探讨题目的知识点标注，知识图谱的建设，学生对知识点掌握程度的特征，等等，这些都是学术界比较早期的自适应技术研究特征。</code></pre><p>虽然发端比较早，但我觉得不见得就没有继续研究的价值——其实在符号认知理论范式的继续演进下，我觉得这里仍然是大有可为的。只不过我们之前讨论的比较多，我们这里从略。</p><p>基于学习风格的自适应</p><p>所谓学习风格，Honey和Mumford的通用定义是，学习风格是对能确定一个人偏爱的学习方式的那些态度和行为的描述。也就是说，学习风格是对学习者的态度和行为的描述，这些态度和行为可以确定他的偏爱的学习方式。另外一种可以参考的定义是，学习风格是学习者在一定的环境和条件下所表现出来的复杂行为，它们能够支持学习者快速有效的理解、加工、存储、回忆他们的学习内容。</p><p>对学习风格的分类有很多种。包括Myers-Briggs风格量表、Kolb的学习风格模型、Honey-Mumford的学习风格模型和Felder-Silverman的学习风格模型等。我们以Honey-Mumford的学习风格模型为例，他们是在Kolb的基础上进一步发展出来的，学习风格包括行动主义者（热衷于新东西新体验，做中学是他们最好的方式）、理论主义者（擅长将观察结果整合到理论中，学习过程离不开概念、模型和事实的支持）、实用主义者（对学习内容在现实世界的应用感兴趣，会不断尝试各种应用进行观察），以及反思者（喜欢从不同角度观察和反思，并从中得到结论进行学习）。 </p><p>基于学习风格的自适应学习系统，一般会根据几种不同的技术来调整学习内容和过程来适应学生的不同学习风格。最常用的包括：</p><p>在一个课程中改变每一个片段中呈现的学习对象类型的顺序，</p><p>隐藏那些不匹配学生学习风格的学习对象、学习对象的元件和学习对象的链接，</p><p>对学习对象进行注解，以表明它们符合学生的学习风格的程度，进而推荐最合适的学习对象，等等。</p><p>大部分自适应系统使用静态的和协作的学生建模方法，要求学习者填写问卷来确定他们的学习风格。但这些问卷是基于“学习者了解自己如何学习”这一假设的，且因为是基于自我报告的测量而不是能力测试，所以其效度有很大的问题。</p><p>最近的发展，研究已经通过调查和发展自动化的途径来确定学习风格，在线学习平台的大量学习相关的行为数据都被收集和利用。模型是贝叶斯网，或者隐马尔可夫模型，或者其它机器学习分类算法，都是可用的选择。</p><p>基于认知能力的自适应</p><p>认知能力，也就是获取知识的心理过程，包括诸如意识、感知、推理和判断等方面。人类有很多典型的认知能力，对学习是至关重要的，这包括工作记忆能力、推理能力、信息加工速度、链接式学习能力以及元认知等。</p><p>所谓工作记忆，就是允许我们在记忆中短暂的保持有限容量的信息。早些时候，工作记忆也指短时记忆。双重编码假设理论就是基于这样一个假设：工作记忆由两个相互独立的部分组成，一个与言语信息有关，另一个与非言语信息有关。根据这一假设，当两个通道都参与时，可以降低认知负荷，由此，学习者可以更好的学习。但事情的复杂性在于，有研究者发现，双重编码理论对知识表征的解释力是随着学习者的经验的增长而减少的。</p><p>推理能力大家比较熟悉，包括归纳、演绎等。其中归纳推理越来越受重视，研究认为，归纳推理能力和情境中的概念建构有关。归纳能力越强，对学术知识的智力模式建构就越容易。Harverty等曾经说过，归纳推理能力是学业成就的最佳预测器。</p><p>信息加工速度决定了学习者正确的获取信息的速度。自适应学习系统需要考虑学习者的信息加工速度，进而调整各种学习细节，包括细节信息的量，信息的传播途径和相互关联，以及是否提供要点等等。</p><p>链接式学习能力能够将新旧知识联系起来。知识关联过程需要进行模式匹配，它可以发现已有的信息空间，分析新旧知识之间的关系，将新知识存入长时记忆。系统设计需要帮助学习者回忆已有信息，清晰的呈现概念之间的关系，促使学习者创建联想和理解。</p><p>元认知是对于个体自己认知系统和功能的知觉和监控。元认知的重要性越来越凸显，尤其在问题解决任务中，元认知能力尤其重要。 </p><p>基于认知能力的自适应技术涉及确认学习者的认知能力并使用这些信息为具有不同认知能力的学习者提供不同的支持。但目前这个领域的研究还处于比较早期的阶段，研究成果数量也并不多。</p><p>基于情感状态的自适应</p><p>可以影响学习过程的另一方面是一个人的情感状态。在学习过程中，情感状态通常被认为尤其相关，例如厌倦、困惑、沮丧，或信任、满意度和独立等。提供关于情感状态方面的自适应是一个新的研究领域，仅有少数的自适应学习系统开始探索解决这一类问题。</p><p>我在上一家公司工作时，曾代表公司教育技术团队和北师大对接，联合申请了一个教育部的项目，这个项目主要包含两个方向的探索，一个是深化IRT模型做基于内容测评的自适应推荐，另一个是基于学生学习过程视频的情感状态识别，通过情感状态的识别来进行推荐——也是这个方向的一个尝试。随着可穿戴设备的兴起，系统可以采集大量的数据进行情感状态的识别，如体感坐姿数据，处于葛优瘫的学生其情感状态多数往消极的方向走，这也是一种例子。</p><p>基于情境和环境的自适应</p><p>Dey给出了情境的一般性定义，他将其描述为“任何可以用来描述实体情况的信息。实体可以是一个人、地点或被认为与用户和应用程序之间的互动有关的物体，包括用户和应用程序本身”。</p><p>由于移动技术的最新发展，学习可以随时随地的发生。因此，学习者当前所处的情境，以及他的学习的周边环境特点，成为自适应技术考虑的另一个重要方面。通过将学习者的情境和环境信息整合到适应性过程，自适应技术开启了新的可能。</p><p>这样的例子我们不需要多举，这样的情境是丰富的、异质的，环境千差万别，使用手机屏幕的碎片学习，和使用pad屏幕在有辅导下的学习，那是有极大不同的——自适应系统无法忽视这一移动时代的学习特征。 </p><p>基于情境和环境的自适应学习，以及扩展到移动学习，被许多研究者认为是下一个教育技术研究的热点。</p><p>混合式自适应</p><p>上面我们提到了如此多的自适应技术的基本线条，所以学术界和工业界有着大量不同的自适应学习系统。但我们说，因为教育是一个复杂系统，所以，自适应学习技术还有一个线条，那就是混合式的自适应，把以上两种或若干种的自适应技术进行综合使用，设计出符合用户需求的混合式自适应系统。（这里可以对比互联网推荐引擎中的混合式模型。）</p><h2 id="自适应技术的基础模块"><a href="#自适应技术的基础模块" class="headerlink" title="自适应技术的基础模块"></a>自适应技术的基础模块</h2><p>自适应技术，乃至教育技术，我认为有两个基础的技术模块，其一是媒体传播技术，包括传播相关的各种硬件、软件的技术，我们这里不再探讨。而另一个方向，就是以智能技术为代表，包括教育数据挖掘、学习者建模和人工智能等。学习者建模的内容我们上面提到了大量的方向，人工智能相关的知识库和语义网，以及机器学习和深度学习，我们开始就曾说因篇幅关系这次不再介绍。那么还有一个模块就是教育数据挖掘，值得加以讨论。</p><p>教育数据挖掘</p><p>虽然数据挖掘是一个有长期积累的计算机科学的学科，但教育数据挖掘，却是一个比较新的领域。根据Baker的定义，教育数据挖掘是“开发探索来自教育环境的独特数据类型的方法，用这些方法更好的理解学生和学习环境”。虽然早期研究来自数据挖掘和知识发现的传统，但是由于教育数据的具体特征不同，应用的方法也不同，如Baker提到，教育数据经常是嵌套的（学生隶属于班级，班级隶属于学校），即教育数据是多层次结构的一部分；而且我认为，对学习者和学习环境的理解涉及大量心理学、教育学和学习科学的范式与规律，这和传统数据挖掘应用领域是大大不同的。所以教育数据挖掘是一个很有挑战的新领域，也是自适应学习系统的基础模块之一。 </p><p>教育数据挖掘的方法，基本上可以分为四组。</p><p>第一组是预测，目标在于把相对独立的变量（预测变量）组合在一起，推测数据的单一方面（因变量或结果变量）。在解释对结果变量的预测时，预测方法可以关注哪些特点或变量更重要；也可以首先关注预测调节性或中介性的因素。Baker描述了三种预测方法：分类、回归分析和密度估计。</p><p>第二组教育数据挖掘方法包含聚类方法。因此，它的目标是找到可以形成自然分组的数据点（比如，学习者、学习者特征、学校、学生行为等）。</p><p>第三组教育数据挖掘方法包含关系挖掘方法，重点在于大量变量数据组中，发现变量关系及关系程度。这类挖掘的实施，可以通过关联规则挖掘，或者通过相关性挖掘，通过序列模式挖掘，也可以通过因果关系挖掘等不同模型来实现不同目的。</p><p>第四组教育数据挖掘是模型发现法，先开发验证模型，再将其作为另一轮分析的输入，如预测挖掘。在教育数据挖掘中，模型发现法越来越流行。 </p><p>也有人把文本挖掘方法增加为教育数据挖掘的第五组方法。如文档分类、教育内容的知识抽取、分析评估系统内部或开放平台上的讨论与交互文本等。我们商业系统中的题目的知识点抽取或分类，可以算作其中的一种应用。</p><p>综上，这是通观学术界和工业界的进展，对自适应技术的一个总结。很自然的感受是，自适应技术的空间是巨大的，它从另外一个探索维度，打穿了教和学的方方面面，也是教育技术最为深刻的方向之一；虽然，它还处于比较早期的阶段。</p><p>*本文转自微信公众号爱知行，由李子选编，原标题《谈谈学习与自适应学习技术（自适应学习技术</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自适应学习技术&quot;&gt;&lt;a href=&quot;#自适应学习技术&quot; class=&quot;headerlink&quot; title=&quot;自适应学习技术&quot;&gt;&lt;/a&gt;自适应学习技术&lt;/h2&gt;&lt;p&gt;前面我曾提到，“我认为，自适应学习是在学习研究的范式下，一种以计算机技术为主导的学习环境和系统的横向探索，而且是一种意义重大的探索”。这种意义我这里不再讨论，之前站正面立场时也曾讨论过。我们这里，是通过跳出现有产品经验的方式下，来探讨自适应学习和自适应技术。更多的是来自学术界已经做过的探索。&lt;br&gt;但作为与学习研究范式的连接，我们有必要简单提及一个问题，后面我不再详细讨论这个问题。那就是，持有研究范式的不同，会怎样影响研究者研发自适应学习系统？这涉及到研究范式到教学设计，由教学设计到学习环境和系统搭建的翻译和影响。我觉得这是一个有意思的问题；前面很多自适应技术的文章，都会谈及知识图谱，但不会谈及人的情感变量和社会协作中的问题，我觉得一方面是为其产品背景和阶段所限定，另一方面也和研发团队一开始的范式切入口有关。&lt;/p&gt;
    
    </summary>
    
    
      <category term="教育数据挖掘" scheme="http://yoursite.com/categories/%E6%95%99%E8%82%B2%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="自适应学习" scheme="http://yoursite.com/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>国外24个值得关注的自适应学习工具</title>
    <link href="http://yoursite.com/2019/09/15/%E5%9B%BD%E5%A4%9624%E4%B8%AA%E5%80%BC%E5%BE%97%E5%85%B3%E6%B3%A8%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/09/15/国外24个值得关注的自适应学习工具/</id>
    <published>2019-09-15T13:06:55.000Z</published>
    <updated>2019-09-15T13:50:29.858Z</updated>
    
    <content type="html"><![CDATA[<p>在线教育市场上充斥着提供或者声称提供自适应学习的工具。接下来，我们就将列举出24个工具供大家比较。当然，我们的列表并不全面，仅仅列举出了一些比较有名的和新工具的代表。</p><h2 id="1-Ck-12-Platform"><a href="#1-Ck-12-Platform" class="headerlink" title="1 Ck-12 Platform"></a>1 Ck-12 Platform</h2><a id="more"></a><h2 id="2-Aleks-官网：-https-www-aleks-com"><a href="#2-Aleks-官网：-https-www-aleks-com" class="headerlink" title="2 Aleks 官网： https://www.aleks.com/"></a>2 Aleks 官网： <a href="https://www.aleks.com/" target="_blank" rel="noopener">https://www.aleks.com/</a></h2><p>领域：幼教、K-12；数学<br>Aleks是一个评测学生掌握情况的系统，应用于很多科目。这个系统是为了测试入学孩子的数学水平和数学知识掌握情况，主要用于K-12和幼教。<br>Aleks的人工智能引擎使用“知识空间理论”来衡量学生对一个主题的熟练程度，使用少量的问题即能快速确定学生知道什么和可以做什么，而这些选择不依赖多项选择题，而是来自学生自己的开放式问题答案。</p><h2 id="3-Learnsmart-Smartbook"><a href="#3-Learnsmart-Smartbook" class="headerlink" title="3 Learnsmart + Smartbook"></a>3 Learnsmart + Smartbook</h2><p>官网：<a href="http://www.mheducation.com/highered/platforms/learnsmart.html" target="_blank" rel="noopener">http://www.mheducation.com/highered/platforms/learnsmart.html</a><br>领域：K-12，高等教育；全科<br>支持超过1300门McGraw-Hill课程的自适应平台。当学生被要求练习问题时，他们的回答必须包括他们对答案的信心程度。课程还提醒学生何时可能会忘记他们学到的东西。<br>LearnSmart包括SmartBook，自适应电子书，基于学生之前的表现推算出他们应关注的领域。教师可以查看课程进度报告，学生可以查看有关他们自己学习的报告。教师可以在完全在线，混合或面对面的形式的教学时使用课件。</p><h2 id="4-ScootPad"><a href="#4-ScootPad" class="headerlink" title="4 ScootPad"></a>4 ScootPad</h2><p>官网：<a href="https://www.scootpad.com/" target="_blank" rel="noopener">https://www.scootpad.com/</a><br>领域：幼教，K-8；数学和阅读<br>给K-8学生提供数学和阅读技巧的自适应训练。每个学生通过诊断练习来确认薄弱环节，确保他们得到个性化学习材料。同时教师可以通过创建有针对性的作业来为特定的学生进行指导。</p><h2 id="5-SuccessMaker"><a href="#5-SuccessMaker" class="headerlink" title="5 SuccessMaker"></a>5 SuccessMaker</h2><h2 id="6-LearnBop"><a href="#6-LearnBop" class="headerlink" title="6 LearnBop"></a>6 LearnBop</h2><p>官网：<a href="https://www.learnbop.com/" target="_blank" rel="noopener">https://www.learnbop.com/</a><br>领域：K-12；数学<br>针对K-12学生的自适应数学教学和测试系统。老师可以给学生出一组多项选择或填空问题。每个学生单独完成一组问题。当学生犯错误时，LearnBop将会对错误答案逐步分析，看看学生在哪个环节出了错误。</p><h2 id="7-Lexia"><a href="#7-Lexia" class="headerlink" title="7 Lexia"></a>7 Lexia</h2><h2 id="8-St-Math"><a href="#8-St-Math" class="headerlink" title="8 St Math"></a>8 St Math</h2><p>官网：<a href="http://www.mindresearch.org/stmath/" target="_blank" rel="noopener">http://www.mindresearch.org/stmath/</a><br>领域：K-12，数学<br>ST依靠脑神经科学、精美的视觉设计和游戏式学习来教K-12学生数学。学生在学习数学的过程中不需要看过任何语言和数字符号。</p><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p>Fulcrum Labs (Formerly Adapt Courseware)<br>官网：<a href="http://www.the-fulcrum.com/" target="_blank" rel="noopener">http://www.the-fulcrum.com/</a><br>领域：高等教育，职业教育；员工培训，考试培训和高等教育<br>学生可以通过三种方式学习：观看3-5分钟的教学，阅读文本和图像，以及做各种试题。学生在学习的时候可以和彼此沟通，也可以联系教师。教师可以访问分析页面看学生做作业的情况。<br>Fulcrum的自适应算法考虑了诸如学习者自我评估，先前学习目标掌握，问题表现和学习风格偏好等因素。教师可以自定义内容和问题，学生还可以跳过其已经掌握的内容。</p><h2 id="10-i-Ready"><a href="#10-i-Ready" class="headerlink" title="10 i-Ready"></a>10 i-Ready</h2><p>官网：<a href="http://www.i-ready.com/" target="_blank" rel="noopener">http://www.i-ready.com/</a><br>领域：K-12；数学、阅读、语言和早教<br>i-Ready软件包提供基于K-12数学和阅读的学生指导，性能诊断和进度报告。学生根据自己的能力接受i-Ready诊断并接受个性化的在线教学，而学校和学区则收到学生全年学习成绩和进步的定制报告。<br>i-Ready包含四套独立工具：<br>i-Ready诊断 - 在K-12数学和阅读中提供自适应诊断<br>i-Ready在线指令 - 基于诊断的在线课程<br>iPad应用程序 - 支持在线教学的游戏<br>i-Ready标准管理 - 基于微观标准的评估</p><h2 id="11-Istation"><a href="#11-Istation" class="headerlink" title="11 Istation"></a>11 Istation</h2><h2 id="12-Mastering"><a href="#12-Mastering" class="headerlink" title="12 Mastering"></a>12 Mastering</h2><p>官网：<a href="http://www.pearsonmylabandmastering.com/northamerica/index.html" target="_blank" rel="noopener">http://www.pearsonmylabandmastering.com/northamerica/index.html</a><br>领域：科学和工程<br>该课程提供一系列的科学和工程类课程。该课程会根据每个学生的答案来选择适合他的课程。</p><h2 id="13-Think-Through-Math"><a href="#13-Think-Through-Math" class="headerlink" title="13 Think Through Math"></a>13 Think Through Math</h2><p>官网：<a href="https://www.thinkthroughmath.com/" target="_blank" rel="noopener">https://www.thinkthroughmath.com/</a><br>领域：高中<br>Think Through Math是一个在线的自适应学习平台，主要教3-8年级的数学，代数和几何。 教师们会利用平台反馈来给学生制定个性化教程。</p><h2 id="14-CogBooks"><a href="#14-CogBooks" class="headerlink" title="14 CogBooks"></a>14 CogBooks</h2><p>官网：<a href="https://www.cogbooks.com/" target="_blank" rel="noopener">https://www.cogbooks.com/</a><br>领域：高中，生物、美国历史<br>CogBooks提供了预先录制的生物和美国历史的课程，并且可以根据用户需求来定制。该软件会从学生回答问题，分析数据的过程中发展出一个18个维度的学习档案。该平台支持纯线上学习和混合式学习。</p><h2 id="15-Dreambox"><a href="#15-Dreambox" class="headerlink" title="15 Dreambox"></a>15 Dreambox</h2><h2 id="16-KnowRe"><a href="#16-KnowRe" class="headerlink" title="16 KnowRe"></a>16 KnowRe</h2><p>官网：<a href="http://knowre.com/product/" target="_blank" rel="noopener">http://knowre.com/product/</a><br>领域：幼教，K-8；代数、几何<br>KnowRe是一个自适应数学平台，能够将交互式游戏和测试以及自适应课程联系起。KnowRe是2008年在韩国首尔发展起来的数学学院。</p><h2 id="17-Mathspace"><a href="#17-Mathspace" class="headerlink" title="17 Mathspace"></a>17 Mathspace</h2><p>官网：<a href="https://mathspace.co/" target="_blank" rel="noopener">https://mathspace.co/</a><br>领域：幼教，K-8；<br>Mathspace的特点在于能够自动识别学生解数学题的步骤是否正确，并且当学生在哪一步写错的时候能够识别并且纠正。</p><h2 id="18-MyLab"><a href="#18-MyLab" class="headerlink" title="18 MyLab"></a>18 MyLab</h2><p>官网：<a href="http://www.pearsonmylabandmastering.com/northamerica/" target="_blank" rel="noopener">http://www.pearsonmylabandmastering.com/northamerica/</a><br>领域：高等教育；全科<br>MyLab是由培生集团出品，主要是给培生集团线下课程的线上补充，包括在线作业，指导课程和测试系统。学生使用MyLab来写作业，而该软件会根据学生的作业情况制定出新的课程表。</p><h2 id="19-Redbird-Advanced-Learning"><a href="#19-Redbird-Advanced-Learning" class="headerlink" title="19 Redbird Advanced Learning"></a>19 Redbird Advanced Learning</h2><p>官网：<a href="http://redbirdlearning.com/" target="_blank" rel="noopener">http://redbirdlearning.com/</a><br>领域：高等教育；数学<br>Redbird是和斯坦福大学合作开发的在线数字课程。课程包括学生和教师的多媒体教学。系统使用自动评分体系来评价学生的学习进步和掌握情况。在线学习工具允许教师区分教学目标和学生的特定学习需求。掌握技能或概念的学生可以快速地进入下一课，而那些没掌握的学生会收到具体的教学支持学习课程。课程还为学生提供解决常见错误的帮助和提示。如果没有彻底学会，学生就无法进入下一堂课。</p><h2 id="20-Smart-Sparrow"><a href="#20-Smart-Sparrow" class="headerlink" title="20 Smart Sparrow"></a>20 Smart Sparrow</h2><p>官网：<a href="https://www.smartsparrow.com/" target="_blank" rel="noopener">https://www.smartsparrow.com/</a><br>领域：科学、医学；高等教育<br>Smart Sparrow是一个适应性课件的课程构建平台。课件包括学生和课程分析，还可以在平台上虚拟实验室。Smart Sparrow的自适应能力并非使用预定义的算法; 相反，教师可以创建自己的自适应规则，这些规则可以基于诸如学生在页面上的停留时间或尝试解决问题的次数这样的变量来制定。此外，Smart Sparrow还提供预科科学课程和课程设计服务。Smart Sparrow的自适应规则基于诸如学习者信心和自我评估，完成学习的时间，表现，学习风格偏好和先前学习目标掌握程度等因素。教师可以从课件外添加内容，了解评分等级并更改驱动自适应性的规则。</p><h2 id="21-Waggle"><a href="#21-Waggle" class="headerlink" title="21 Waggle"></a>21 Waggle</h2><h2 id="22-Brightspace-Leap"><a href="#22-Brightspace-Leap" class="headerlink" title="22 Brightspace Leap"></a>22 Brightspace Leap</h2><p>官网：<a href="https://www.d2l.com/" target="_blank" rel="noopener">https://www.d2l.com/</a><br>领域：K-12，高等教育，职业教育<br>Brightspace旨在帮助学校建立混合或在线课程环境。此环境从Brightspace课程库开始，教师可以从这里访问来自各种来源的内容。该图书馆与OER网站和许多第三方平台合作。通过关键词，主题或日期来给每个“学习对象”（例如教程视频，工作表，评估等）打标签。<br>教育者使用这些材料为每个学生建立不同学习路径。教师可以设置“条件”以控制学生的访问权限。当学生通过Brightspace的工作时，他们可以使用工具的通信功能与其它同学讨论他们的工作。家长也可以通过工具通知作业或其他新闻。<br>一旦学生完成学习，教师可以对他们进行评分，并通过Brightspace的注释工具提供关于作业的反馈。教师通过使用内置的数据仪表板监控学生的进步和成绩。</p><h2 id="23-Fishtree"><a href="#23-Fishtree" class="headerlink" title="23 Fishtree"></a>23 Fishtree</h2><p>官网：<a href="https://www.fishtree.com/" target="_blank" rel="noopener">https://www.fishtree.com/</a><br>领域：平台，全科；K-12，高等教育，职业教育；<br>对于教师来说，Fishtree的核心价值在于搭建课程。教师可以设置课程及其难度系数。基于所选择的难度，Fishtree将生成一个进入课程的内容列表; 内容来源于如CK-12，可汗学院和YouTube的开放平台，以及来自教师自己的课程和其他第三方内容。教师选择他们要分配的内容，构建或选择评估以结束课程，然后选择将接收作业的学生（或学生组）。<br>Fishtree集成了许多现有的SIS，LMS和成绩数据，以便来自Fishtree的内容可以纳入学校现有的基础设施内。教师还可以覆盖Fishtree的自适应系统，并直接管理学生观看的视频和课程。</p><h2 id="24-Knewton"><a href="#24-Knewton" class="headerlink" title="24 Knewton"></a>24 Knewton</h2><p>注：以上工具名来自于Edsurge的自适应学习研究报告。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在线教育市场上充斥着提供或者声称提供自适应学习的工具。接下来，我们就将列举出24个工具供大家比较。当然，我们的列表并不全面，仅仅列举出了一些比较有名的和新工具的代表。&lt;/p&gt;
&lt;h2 id=&quot;1-Ck-12-Platform&quot;&gt;&lt;a href=&quot;#1-Ck-12-Platform&quot; class=&quot;headerlink&quot; title=&quot;1 Ck-12 Platform&quot;&gt;&lt;/a&gt;1 Ck-12 Platform&lt;/h2&gt;
    
    </summary>
    
    
      <category term="教育数据挖掘" scheme="http://yoursite.com/categories/%E6%95%99%E8%82%B2%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="自适应学习" scheme="http://yoursite.com/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Knewton适应性学习白皮书</title>
    <link href="http://yoursite.com/2019/09/15/Knewton%E9%80%82%E5%BA%94%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%99%BD%E7%9A%AE%E4%B9%A6/"/>
    <id>http://yoursite.com/2019/09/15/Knewton适应性学习白皮书/</id>
    <published>2019-09-15T12:04:09.000Z</published>
    <updated>2019-09-15T13:50:31.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Knewton适应性学习-构造全球最强大的教育推荐引擎"><a href="#Knewton适应性学习-构造全球最强大的教育推荐引擎" class="headerlink" title="Knewton适应性学习-构造全球最强大的教育推荐引擎"></a>Knewton适应性学习-构造全球最强大的教育推荐引擎</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.  介绍"></a>1.  介绍</h3><p>适应性学习：一个以课程应该适应每一个用户的思想为前提的教学方法。<br>（原文：Ateaching method premised on the idea that the curriculum should adapt to eachuser.）<br>在基础层次上，适应性学习的定义看起来很简单。但是更深入的探讨一下，这个概念的细微差别开始更深入的揭示它自身的本质。</p><a id="more"></a><p>适应性学习有多个不同的等级和种类（单点模式VS连续模式，适应性测试VS适应性学习，原文：singlepoint vs. continuous, adaptive testing vs. adaptive learning），但是不同类别的区别并不是很清楚。因为个性化学习的需求对于教育者有很大的吸引力，越来越多的产品声称他们有“适应性学习”的功能，关于这个概念已经让人迷惑。<br>我们一直在思考适应性的概念，我们也一直在改善我们的适应性平台。本白皮书的目的是阐释我们对适应性学习的认知，提供我们的推荐引擎的相关理论的概览，以及Knewton适应性学习在教室环境中能够产生的效果。我们希望本白皮书对您有所帮助。</p><h3 id="2-适应性学习的含义"><a href="#2-适应性学习的含义" class="headerlink" title="2.  适应性学习的含义"></a>2.  适应性学习的含义</h3><p>适应性学习是最近在教育领域朝着一个好的目标被不断的研究的一个概念。<br>原文：Adaptivelearning is a term that has been tossed around a good deal recently in edtechcircles.<br>大部分人在涉及这个令人迷惑的词的时候，他们真正在讨论的有以下几种情况：</p><ul><li>a) 单点适应性，在一个时间点上评估一个学生的表现，用来决定教导层次或者他从那个时间点开始使用的材料。</li><li>b) 适应性测试，通过固定数量的试题决定一个学生的准确的精通程度层次。<br>我们这里提到的适应性学习，指的是一个连续的适应性的系统，对于每个用户在本系统上的表现和活动都进行实时的响应；通过提供正确的指导，在正确的时间，最大化一个学生将要获得的学习目标的可能性（原文：maximizes the likelihood a student will obtain her learning objectivesby providing the right instruction, at the right time, about the right thing.）。换句话说，适应性测试回答了这个问题：如何通过指定数量的试题精确的掌握学生对于知识的掌握程度，适应性学习回答了这个问题：计入我们已经知道一个学生的当前的知识水平、状态，这个学生从现在开始应该学习哪些新的知识。<br>为了提供连续适应性学习，我们分析了基于成千上万的数据点的资料，包括概念，结构，不同的层次，以及媒体格式数据，并采用复杂的算法不断的把每个学生的最好的数据内容拼接起来（原文：and uses sophisticated algorithms to piece together the perfectbundle of content for each student, constantly），系统通过分析收集的所有学生的数据的网络效果提炼出推荐结果，用来给每个学生优化学习方法(原文：The system refines recommendations through network effects thatharness the power of all the data collected for all students to optimize learningfor each individual student.)。<h3 id="3-Knewton推荐的理论和方法"><a href="#3-Knewton推荐的理论和方法" class="headerlink" title="3.  Knewton推荐的理论和方法"></a>3.  Knewton推荐的理论和方法</h3>没有两个学生是一样的——他们以不同的速率学习和忘记，来自不同的教育背景，有着不同的智力程度，注意力范围和学习方式。所以，设计一个对于每一个学生的特点都敏感的实时推荐引擎是一个非常巨大的工程。<br>在Knewton，我们勇往直前的面对这个挑战，通过采用教育路径规划技术和学生能力高级模型。这些技术和模型可以保证每个学生都通过课程材料以最大化的学习方式来实现不断的进步。<br>以下是Knewton推荐引擎一些理论和方法的速揽。<h4 id="项目反应理论（ItemResponse-Theory-IRT-）（试题反馈理论）"><a href="#项目反应理论（ItemResponse-Theory-IRT-）（试题反馈理论）" class="headerlink" title="项目反应理论（ItemResponse Theory (IRT)）（试题反馈理论）"></a>项目反应理论（ItemResponse Theory (IRT)）（试题反馈理论）</h4></li></ul><p>假设你教四个年级的数学补习课，你刚刚安排了一个包含10个测试题的测试。这10道测试题里，两道题非常简单，两道题非常的困难，其他的题是中等难度。现在假设两个你的学生参加了这个测试。两个人都回答对了10道题中的9道题，第一个学生回答错了一个非常简单的问题，另外一个学生回答错了一个非常困难的问题。那么哪一个学生对于课程材料的知识掌握的更好呢？<br>在传统评分方法中，你会给两个学生都打90分，满分是100分的话，两个人都会获得成绩A，然后进入到下一个测试。但是这个方法通过测试来评价学生的能力有一个关键问题：测试试题没有统一的特征。那么我们怎么样能过通过试题的差别来评价学生的能力呢？<br>IRT通过试题级别表现对学生的能力进行建模，而不是聚集的测试级别表现。不是假设每个试题都有相同的贡献度来实现我们对学生能力的掌握，取而代之的是，IRT对于每一个学生的每一个试题都提供信息的细微差别的观察。它是在一个试题被正确性回答的可能性是一个多参数的数学公式的前期下建立起来的，这些数学公式的参数包括一个人的潜在特性，能力和试题特征。<br>图Ｂ是由IRT模型生成的二项反馈函数。这些曲线表现了IRT模型如何将学生能力与正确回答一个试题的可能性联系起来，在给定试题难度，区分级别和“猜测性”。因为IRT模型在能力的单独评价上是永久的和可靠的（只反映了Knewton推荐的一个方面），它帮助我们更好的理解一个学生在测试中的表现与他的能力的联系。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70gl9gfjsj30cx0dit9e.jpg" alt="undefined"></p><h4 id="概率图形模型（ProbabilisticGraphical-Models）"><a href="#概率图形模型（ProbabilisticGraphical-Models）" class="headerlink" title="概率图形模型（ProbabilisticGraphical Models）"></a>概率图形模型（ProbabilisticGraphical Models）</h4><p>在本框架中，包含了贝叶斯神经网络和马尔科夫随机场等统计方法，使得数据学家能够在多维空间中通过成百上千的参数分析和操作概率分布。换句话说，PGMs允许使得Knewton分析师对一个效果建立复杂的模型，将众多的观测到的学习活动与对系统推荐有用的评估联系起来。<br>Knewton应用PGMs的一种方法是通过使用学生已知的掌握程度来决定他可能已经有能力学习的知识。例如，这样的模型能够帮助平台发现一个学生对于分数的什么样的掌握程度能够帮助学生掌握小数，以及对小数的什么样的掌握程度能够帮助学生掌握指数。Knewton的数据学家因此能够决定对于分数的掌握和对于指数的掌握之间的联系。最终，这些类型的联系的发现使得Knewton适应性学习平台能够持续的提炼推荐结果。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70glndmt2j30d40bnmxp.jpg" alt="undefined"></p><h4 id="凝聚层次聚类（HierarchicalAgglomerative-Clustering）"><a href="#凝聚层次聚类（HierarchicalAgglomerative-Clustering）" class="headerlink" title="凝聚层次聚类（HierarchicalAgglomerative Clustering）"></a>凝聚层次聚类（HierarchicalAgglomerative Clustering）</h4><p>在数据挖掘中，层次聚类是一种分析方法，被用来构建类的层次或者结构。在Knewton系统中，这个技术被用来检测大的分组内的潜在结构和建立如何决定学生应该怎样分组以及根据哪些特征将学生分组的算法。Knewton数学准备（Knewton Math Readiness）包含一个这种技术的实现，它提供了一个分组面板，使得老师可以对使用相同教材的学生根据学生对概念理解的级别进行分组。</p><p><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70gmzlz7cj30cw07l0t2.jpg" alt="undefined"></p><h3 id="4-为什么Knewton适应性学习平台如此高效"><a href="#4-为什么Knewton适应性学习平台如此高效" class="headerlink" title="4.  为什么Knewton适应性学习平台如此高效"></a>4.  为什么Knewton适应性学习平台如此高效</h3><p>推荐理论的科学通过Knewton适应性能力的规律性范围和极大的实用性被增强。对于每一个参加Knewton课程的学生，一个跨学科的知识图谱，连续的适应性的，终身的学生学习层面和巨大的网络效果结合起来产生了强大的个性化学习方案。</p><h4 id="知识图谱（Knowledge-GraphTM）"><a href="#知识图谱（Knowledge-GraphTM）" class="headerlink" title="知识图谱（Knowledge GraphTM）"></a>知识图谱（Knowledge GraphTM）</h4><p>Knewton课程通过Knewton知识图谱连接起来，一个“权威的”学术概念交叉学科图。这些知识图谱考虑进了内容设置定义的概念以及这些概念之间的联系。Knewton推荐个性化的引导学生，即使是在知识图谱上朝着最终学习目标的交叉学科路径也是基于学生知道什么和学生如何学习的。教授的内容越多，或者被加入到系统的每个概念的评价越多，适应性学习体验就变得更加准确（The more content that teaches or assesses each concept that is addedto the system, the more precise the adaptive course experience becomes.）。<br>当可视化以后，知识图谱通过课程材料可以提供对于学生潜在发展路径的认知。<br>在知识图谱内，因为通过课程定义了一个学生的学习路径，概念之间有先决条件的关系。将内容定义为“执导的”或者“评估”的特殊关系，决定了在任何给定的时间点应该给学生传送什么样的学习内容。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70gnsae7qj30cy0cpgmc.jpg" alt="undefined"></p><h4 id="连续性学习，与单点适应性相反的。（Continuous-as-opposed-to-single-point-adaptivity）"><a href="#连续性学习，与单点适应性相反的。（Continuous-as-opposed-to-single-point-adaptivity）" class="headerlink" title="连续性学习，与单点适应性相反的。（Continuous, as opposed to single-point adaptivity）"></a>连续性学习，与单点适应性相反的。（Continuous, as opposed to single-point adaptivity）</h4><p>单点适应性学习系统在一个单独的时间点评估学生的表现，然后从这个时间点决定他将要收到的指导的类型。一个单点适应性学习的例子如，包含测试考试的课程，考试的测试结果将会决定接下来的课程内容，只包括很少的或者没有更进一步的数据挖掘和个性化。<br>Knewton连续适应学习系统，在另一方面，不断的挖掘学生表现数据，对于学生在系统中的活动进行实时的响应。根据一个给定的活动的完成情况，系统指引学生进入下一个活动。例如，当一个学生对于一个特殊的试题组受到困扰的时候，Knewton系统就会知道这个学生的特殊的不足和哪些这些试题考核的概念相关联，然后可以给学生传送这些概念内容让学生增强对于这些概念的掌握（Knewton will know where that particular student’s weaknesseslie in relation to the concepts assessed by those questions and can delivercontent to increase thestudent’s proficiency on those concepts.）。通过这种方法，连续适应性系统给每个学生在任何时刻都提供一个个性化的学习大纲。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70gohv0y3j30cy0cgt9h.jpg" alt="undefined"><br>下面内容是能够使Knewton系统提供真正的连续性学习的方法的一些具体的例子。</p><h3 id="空间强化（Spaced-reinforcement）"><a href="#空间强化（Spaced-reinforcement）" class="headerlink" title="空间强化（Spaced reinforcement）"></a>空间强化（Spaced reinforcement）</h3><p>和大量的强化相比，标准的训练方法要求学生在较短的时期内应用新的概念或技巧直到他们精通为止，空间强化（也可以理解为分布式强化）是这样的一种学习方法，在教学的过程中新的概念或技巧被吸收，同时学过的概念和技巧被强化。<br>因为新的材料被不断的增加进来并编织成用户熟悉的材料，空间强化经常发生在一个时间延长期内（Because new material is introduced incrementally and woven intofamiliar material, spaced reinforcement typically occurs over an extendedperiod of time.）。空间强化使得Knewton推荐系统能够帮助学生通过不断累积的方式培养学生的能力，并且一旦学习过就能长久记住。</p><h4 id="记忆力和学习曲线（Retention-amp-learning-curves）"><a href="#记忆力和学习曲线（Retention-amp-learning-curves）" class="headerlink" title="记忆力和学习曲线（Retention &amp; learning curves）"></a>记忆力和学习曲线（Retention &amp; learning curves）</h4><p>Knewton推荐引擎需要将衰退或者衰退技巧加入到系统中来。它要能够检测这些事件并提供可控告的推荐最为结果。<br>受到艾宾浩斯在记忆保持力和学习曲线方面的工作的启发，Knewton数据学家使用了指数增长和衰退曲线学生学习和忘记的能力曲线，这些曲线建立在如下的前提下：每次学生接触的是一个给定主题的内容，他们收到关于这个主题的真实能力的一个“突然测试”；同样的，如果他们没有接触其他的主题，他们很有可能会在一段时间后忘记这个主题的内容（These curves are governed by the following premise: each timestudents are exposed to content associated with a given topic, they receive a “bump” in theirvirtual ability level for a topic; likewise, if they are not exposed to someother topic, they likely “forget” that topic over time.）。控制记忆力比率的遗忘曲线可以大致粗糙的由下面的公式表示：<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70gpe5bejj305n02ogll.jpg" alt="undefined"><br>R表示的是记忆保留值，S是记忆力相对强度，t表示的是时间。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70gpnyvv3j30cz0d43z3.jpg" alt="undefined"><br>通过把这个曲线整合到引擎验证努力中，Knewton数据学家可以根据学生在何时以及如何接触内容等资料捕获学生知识增长和减少的方式。最终，这个过程使得Knewton数据学家能够测试控制学生在课程中的发展流程的算法。</p><h4 id="学生学习概览（Student-learning-profile）"><a href="#学生学习概览（Student-learning-profile）" class="headerlink" title="学生学习概览（Student learning profile）"></a>学生学习概览（Student learning profile）</h4><p>在Knewton系统中，学生能够获得持续更新的学习概览，包括这个学生学习到的知识以及他如何学习效率最高的信息。这个概览是不断发展的，随着学生在本平台上学习的时间越长，这个概览变得更加的智能。<br>例如，如果一个已经参加过Knewton课程的学生加入了另外的一个课程，这个课程会利用学生的数据进行“暖”开始（没有任何数据的可以看做“冷”开始）。这个课程将该学生最近学习的概念与技巧，以及在教材中的独一无二的学习轨迹纳入考虑范围，利用这些信息使学生从那个时间点开始能够达到最大化的学习程度。一旦有了足够的数据，本平台会揭示学生的学习模式，可能存在的学习盲点；形态与媒介喜好；粒度强度和缺点。一个学生使用Knewton课程的时间越多，本平台对于服务目标学习材料的效率就越高（The more often a student uses Knewton-powered courses, the moreeffective the platform becomes at serving up targeted learning material.）。<br>在这种方式下，Knewton适应性学习平台致力于最小化沮丧、迷惑等不利于学习的感觉，以一种自然的方式培养学生的能力。这样做的好处很明显，如果学术知识能够以一种连续的方式被灌输那么学生的参与就会被强化。对于学生没有什么会比让学生感觉他们面临的挑战是武断的和特别困难的更加令人不满。Knewton学习概览通过提供学生在学习过程中一个长期实践回答了学生对于连续性和意图的需求（The Knewton learning profile answers the student need for continuityand meaning by affording students a sense of long-term investment in thelearning process.）。</p><h3 id="5-大数据和适应性结构"><a href="#5-大数据和适应性结构" class="headerlink" title="5.  大数据和适应性结构"></a>5.  大数据和适应性结构</h3><p>大数据的概念被用来描述数量巨大的卷，速度，和通过各种各样的技术平台产生的各种各样的数据，其中很多包含连续的或者普遍存在的数据集。大数据特别指那些特别大的，复杂的，难以用传统的数据库管理工具处理的数据集；这些挑战包括数据存储，搜索，分析和数据可视化。</p><h4 id="大数据与教育（BigData-amp-Education）"><a href="#大数据与教育（BigData-amp-Education）" class="headerlink" title="大数据与教育（BigData &amp; Education）"></a>大数据与教育（BigData &amp; Education）</h4><p>在互联网搜索和社会媒体领域，大数据的出现打乱了现存的工业格局，创造出了新的产业，并导致了非凡的企业成功，例如Google,Facebook。特别在教育领域，大数据展示了强大的创造性，因为教育领域的大数据反映了认知，这一点从结构上与用户在网站上的活动，社交网络以及在线购物习惯等产生的数据完全不同。因为教育数据有高度相关性（例如对于分数的掌握和对于指数的掌握），这样就存在非常大的可能性来给学生提供最大优化用户体验和提供切实的价值。</p><p>一个区分由学生产生的数据（例如和在线购物产生的数据）的特征是，学术学习要求一个延长的参与时间；因此学生会在平台上保持一个比较长的时间。更进一步，学生活动会增加注意力，关注度，强度：他们的参与程度比较高，他们为了分数学习一门课程，努力改变未来，扩展他们的技能的范围。这些高强度的努力产生了巨大数据量的有意义的数据，这些有价值的数据又可以被连续的操作处理，实现每个学生的个性化学习。</p><h4 id="适应性基础设施（AdaptiveInfrastructure）"><a href="#适应性基础设施（AdaptiveInfrastructure）" class="headerlink" title="适应性基础设施（AdaptiveInfrastructure）"></a>适应性基础设施（AdaptiveInfrastructure）</h4><p>Knewton已经建立了一个基础结构，允许平台能够处理大量的学生数据。例如，在概率图形模型上的推断就是一类称为“图算法”的一个例子。这些算法非常的特别，他们能够被分解成一些计算单元，这些计算单元仅依赖于其他的一些具体的单元，并且如果工作量被分配到多台电脑上能够实现高效的并行计算，所以只需要很少的协调工作。</p><p>用于实现这些大规模计算的框架缺少鲁棒性，Knewton已经设计了一个自己的称为“AltNode”的框架，这个框架通过在计算机之间分割工作量来实现，并在一个最小需求数量的计算机之间发送连续更新。所有重大的更新都被存储在分布式的Cassandra数据库中。如果一台机器失效，另外一台附近的机器会取代他的位置，从数据库中回复最近的数据然后继续工作。AltNode的一个独一无二的特征是，它允许模型从任何状态进行恢复并且对新到来的数据立即作出响应。</p><h3 id="6-在课堂中的Knewton适应性学习"><a href="#6-在课堂中的Knewton适应性学习" class="headerlink" title="6.  在课堂中的Knewton适应性学习"></a>6.  在课堂中的Knewton适应性学习</h3><p>适应性学习支持基于精通的学习，并且认为通过学习课程获得进步应该建立在对于课程内容的掌握程度上，而不是花费在课程上时间的多少。可能虽然并不经常提起这个概念，基于精通掌握的学习描述了学生的进步是通过成功的完成一系列的给定的试题，实验或者活动，而不是他们花费的时间的多少。</p><p>在线适应性学习让视线基于掌握精通的学习变得非常灵活。例如，Knewton Math Readiness，创造了一个指导的，自我学习步调的学习环境，在这个学习环境中围绕着分组话题给学生实时的优化的指导。根据每个学生的个人学习路径，课程被提供给每个学生，并且持续的评估学生的掌握程度并且作出调整。课程包括视频，在线教材，以及课程问题，学生通过获得课程奖励实现进步，进入到下面的学些。早期的功效报告反映出这个程序的成功之处：在ASU大学通过2000个补习数学的学生使用一个学期以后，不及格率(withdrawal)下降了50%，及格率从66%上升到75%，并且有50%的同学提前4周完成所有任务。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70gthxgcjj30d2066t93.jpg" alt="undefined"><br>这个实现模型经常被看做弯曲的学习，表示一个学生学习什么的任何安排，部分在一个实体的设备同时部分在在线传送给学生内容的部分，这样可以控制学生的时间，地点，路径，以及步调。</p><p>Arizona州立大学的高级讲师Irene bloom,曾经是在线学习的怀疑者。但是她说他的数学补习班自从引入Knewton系统后正在动态的朝着好的方向改变，“我喜欢看到教室里的他们分组学习，相互讨论，并且互相解释问题。通常，不同的分组讨论着不同的话题，根据他们所学课程内容的不同。这个系统对我来说是全新的。在这之前，我总是以假设所有的学生的学习进度都是一致的来进行教学。现在，因为他们以不同的速率在课程中前进，我会在他们每个人的学习程度上进行辅导。”</p><h3 id="7-Knewton适应性学习是如何吸引学生的"><a href="#7-Knewton适应性学习是如何吸引学生的" class="headerlink" title="7.  Knewton适应性学习是如何吸引学生的"></a>7.  Knewton适应性学习是如何吸引学生的</h3><p>Knewton适应性学习通过增加自信，减少不适合沮丧，能够改善学生的参与效果，并且鼓励学生培养高效的学习习惯。Knewton adaptive learning can improve student engagement byincreasing self-confidence, decreasing discomfort and frustration, andencouraging productive learning habit</p><h4 id="实时反馈（Instant-Feedback）"><a href="#实时反馈（Instant-Feedback）" class="headerlink" title="实时反馈（Instant Feedback）"></a>实时反馈（Instant Feedback）</h4><p>如何反馈是及时的那么学生将不会失去注意力，并且他们能够快速的自我修正。一个连续的适应性学习挺能够以多选择模式和自由试题反馈(multiple choice and free response questions)两种方式及时给学生发送个性化的反馈，实时的或者接近实时的给学生进行反馈。结果是学生学习的步调能够指导承担风险，实现，迭代发展和快速学习。</p><h4 id="社区与合作（Community-amp-Collaboration）"><a href="#社区与合作（Community-amp-Collaboration）" class="headerlink" title="社区与合作（Community &amp; Collaboration）"></a>社区与合作（Community &amp; Collaboration）</h4><p>孤立学习使学生的面临的挑战更加的恶化。适应性学习系统能够通过编制一个社会组件到课程中来改善学生的参与。例如，Knewton Math Readiness，提供了一个可以让老师根据学生使用的教材的不同进行将学生分组的控制面板。利用报告中的特点，老师可以给学生安排作业互查机会并且根据学生的能力进行分组，使得每组的组员的能力可以互补。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70guef0tpj30d4069aad.jpg" alt="undefined"></p><h4 id="游戏化（Gamification）"><a href="#游戏化（Gamification）" class="headerlink" title="游戏化（Gamification）"></a>游戏化（Gamification）</h4><p>有无数的学生可以展示技巧并且反馈的机会，适应性课程与游戏有着很多的共同点。还有，适应性课程有一种游戏的方式逐步的增加作业的难度，揭露下一个要学习的层次，增加悬疑性。这些还有其他的游戏元素可以被强化（在Knewton Math Readiness课程中，宝库了进步奖励，勋章以及成就），将适应性课程真正的转换为游戏性的学习体验。<br>对于学习的“解锁”过程能够帮助增强学生在进步中的满足感。</p><h3 id="8-Knewton适应性学习如何帮助老师"><a href="#8-Knewton适应性学习如何帮助老师" class="headerlink" title="8.  Knewton适应性学习如何帮助老师"></a>8.  Knewton适应性学习如何帮助老师</h3><p>Knewton适应性学习让老师能够对学习过程，特别是学习效率，参与程度以及知识的记忆力有较好的洞察力。平台也史无前例的提供了范围的灵活性；老师可以掌握学生在整个课程中活动和表现的模式，也可以深入研究一个学生的学习概览来决定是什么让这个学生的学习变得痛苦。（Knewton adaptive learning gives teachers insight into the learningprocess, specifically in terms of efficacy, engagement, and knowledgeretention. The platform also provides an unprecedented flexibility of scope; teacherscan grasp patterns in student activity and performance across the whole classor drill down into individual student profiles to determine exactly why astudent is struggling.）</p><h4 id="强调学生不同的需求（Addressing-the-Diverse-Needs-of-Students）"><a href="#强调学生不同的需求（Addressing-the-Diverse-Needs-of-Students）" class="headerlink" title="强调学生不同的需求（Addressing the Diverse Needs of Students）"></a>强调学生不同的需求（Addressing the Diverse Needs of Students）</h4><p>目前老师和学校管理者面临的最大的一个挑战就是不断增加的学生的多样性。越大的学生多样性则表示需要考虑更多的多样性需要。有些人因为英语不是第一语言而挣扎，有些很难集中注意力或者不融入组织，有些可能在某方面有缺陷而其他的方面却很优秀。</p><p>Knewton适应性学习让老师可以强调学生的多样性需求，同时观察学习进程。例如，系统能够发现一个学生在数学单词方面有问题是因为它在阅读理解方面有缺陷；系统就会指导老师进行教授特定的关于语法和词汇的材料，并建议老师应该对于这个学生在这些方面进行单独辅导的方式。然后，如果系统发现有个学生在理解数学概念上没有问题但是却在处理数学计算上很粗心，老师就会被通知这个学生应该受到关于如何增加估算能力和答题后检查的建议。老师然后可以指导学生精确的明白他自己存在弱点。</p><p>例如，Knewton Math Readiness课程控制面板中包括一个”开启追踪/关闭追踪”的概念，来衡量学生在课程中的进步。这个概念功能最为一个二值指示帮助老师高效的从整体了解一个班级的信息（This concept functions as a binary indicator that helps teachers efficientlygrasp information about the class as a whole.）。使用这些工具，老师可以从两个视角看到报告数据：</p><h4 id="1）-整个班级（The-Whole-Class）"><a href="#1）-整个班级（The-Whole-Class）" class="headerlink" title="1）  整个班级（The Whole Class）"></a>1）  整个班级（The Whole Class）</h4><p>Knewton Math Readiness指示面板包含一个提供了整个班级追踪状态的评估的直方图。</p><p>利用这个控制面板，老师也可以看到学生在每个独立的主题中如何表现：材料中的哪一部分对于学生来说最容易以及最困难；在班级的表现和活动中出现了什么样的模式。经过多年教授同一门课程，老师可以比较每一年的数据；Knewton分析功能可以帮助他们分析有用的信息，让他们不用自己去解释分析的结构。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70gxjjae7j30d908qt97.jpg" alt="undefined"></p><h4 id="2）-单独学生（Individual-Students）"><a href="#2）-单独学生（Individual-Students）" class="headerlink" title="2）  单独学生（Individual Students）"></a>2）  单独学生（Individual Students）</h4><p>在Knewton Math Readiness中的报告控制面板是流线型的，于是老师可以将注意力放在大的数据分析图像上，老师也可以在控制面板点击每个学生的信息查看每个系统中每个学生具体信息。老师可以查看学生在指定的试题和考试中学生的表现。如果一个学生没有掌握材料，老师可以决定（使用分析指导他们到具体的数据点）发生了哪些具体的误解。</p><p>这个功能使得老师即可以强调学生的多样性需求，也可以更好的理解他们的内容，于是他们可以从每年的数据中不断的提炼更加精准有效的数据。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g70gy0ovz5j30cz09wmxt.jpg" alt="undefined"></p><h4 id="改进与理解长期课程学习的内容（Improving-amp-Understanding-Content-forLong-Term-Curriculum-Development）"><a href="#改进与理解长期课程学习的内容（Improving-amp-Understanding-Content-forLong-Term-Curriculum-Development）" class="headerlink" title="改进与理解长期课程学习的内容（Improving &amp; Understanding Content forLong-Term Curriculum Development）"></a>改进与理解长期课程学习的内容（Improving &amp; Understanding Content forLong-Term Curriculum Development）</h4><p>一个能够度量内容学习效率的指导面板能够帮助老师挖掘他们教学材料的最好的以及最差的方面。就像以前描述的一样（在单项反应理论和网络效果中），Knewton适应性学习能够帮助老师精准的掌握他们正在教授的以及评估的是什么样的内容。这样能够保证这些内容能够被分析，并且实现调整改善，学生不会因为过时的或者低效率的材料而在学习方面受阻。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Knewton适应性学习-构造全球最强大的教育推荐引擎&quot;&gt;&lt;a href=&quot;#Knewton适应性学习-构造全球最强大的教育推荐引擎&quot; class=&quot;headerlink&quot; title=&quot;Knewton适应性学习-构造全球最强大的教育推荐引擎&quot;&gt;&lt;/a&gt;Knewton适应性学习-构造全球最强大的教育推荐引擎&lt;/h2&gt;&lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.  介绍&quot;&gt;&lt;/a&gt;1.  介绍&lt;/h3&gt;&lt;p&gt;适应性学习：一个以课程应该适应每一个用户的思想为前提的教学方法。&lt;br&gt;（原文：Ateaching method premised on the idea that the curriculum should adapt to eachuser.）&lt;br&gt;在基础层次上，适应性学习的定义看起来很简单。但是更深入的探讨一下，这个概念的细微差别开始更深入的揭示它自身的本质。&lt;/p&gt;
    
    </summary>
    
    
      <category term="教育数据挖掘" scheme="http://yoursite.com/categories/%E6%95%99%E8%82%B2%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="Knewton" scheme="http://yoursite.com/tags/Knewton/"/>
    
  </entry>
  
  <entry>
    <title>知识空间理论-R</title>
    <link href="http://yoursite.com/2019/09/14/%E7%9F%A5%E8%AF%86%E7%A9%BA%E9%97%B4%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/09/14/知识空间理论/</id>
    <published>2019-09-14T06:56:23.000Z</published>
    <updated>2019-09-15T13:47:36.575Z</updated>
    
    <content type="html"><![CDATA[<p>在R语言中有一些关于教育诊断的一些包,我试着进入R包的CRAN,进行关键词检索,找到我想要试玩的那些教育数据挖掘(或许叫教育诊断更为恰当),我搜索的关键词有Item Response Theory(项目反应理论), Knowledge Space(知识空间), education.<br>首先,我要试玩的是kst(Knowledge Space Theory),kst的基本思想是一个学生对某领域知识的掌握程度可以通过该学生对问题的应答情况来体现，问题可以被学生答对打错。知识空间通俗意义上讲为构成某一领域知识的所有可能的知识状态的集合。<br>用途：自适应构造每个学生的学习路径，针对不同学生所缺乏的知识点来推荐相应的高速有效的学习路径。</p><a id="more"></a><p>要想了解学生的知识状态，首先我们要精心设计一系列能够具体测试相应知识点的问题，然后让学生参加测试，这样能够正确回答的问题就可以表征学生的知识状态。</p><p>知识空间现已应用在数学、物理学、化学、医学等学科领域。如果想应用于计算机领域也未尝不可。</p><p>但知识空间的构建，往往需要领域专家进行构建，但这往往太过费时，且精度不一。这也是知识空间不能广泛应用于实际的关键问题，如何摆脱专家进行构建知识点及其相互关联这是才要点。</p><p>杨文正等人提出了让学生在学习的过程中自己构建知识点及其相互关联，相应的让专家也构建该领域的知识点及其关联，然后进行对比分析，但文章提到使用知识空间技术进行分析，却没有提供更多的使用知识空间进行分析的研究细节，只是简单的使用了知识空间的概念。</p><p>对于知识空间理论来说，测试学生对某一领域知识的掌握程度可以转换为学生解答相应知识点构成问题的对与错的个数，而按章节组织的知识可以更加容易的构成知识空间领域的知识点，且知识间相互关系也更加容易被算法所获得。<br>首先，引入关键词：<br>知识结构：Knowledge structure<br>知识空间：Knowledge space<br>猜测关系：Surmise relation<br>蕴含关系：Entail relation</p><h2 id="kst简介"><a href="#kst简介" class="headerlink" title="kst简介:"></a>kst简介:</h2><p>知识空间理论基于集合理论框架,提供了在特定知识领域里使用数学的形式来操作知识结构.kst包提供了基础的函数来产生/处理/操作知识结构和知识空间。知识空间了理论中最基础的假设是每个知识域（domain）可以由问题(problems)集合或者项目(items)集合进行表示.知识空间理论中假设给定的项目之间相互关系，即一个项目是另一个项目的前提条件。这种前提关系被定义为猜测关系（surmise relations），它在不同项目间建立了拟序关系（quasi-order）。这种猜测关系的优势在于减少了知识状态的数量，提供了更加可靠的知识状态。</p><p>首先，打开终端，输入：R,<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g6z22dldzbj30gf0at0tl.jpg" alt="undefined"><br>输入：install.packages(“kst”),进行安装R包。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g6z22mqqx7j30ja00w746.jpg" alt="undefined"><br>加载kst包：library(kst)<br>1.知识结构（knowledge structure）<br>定义：知识结构被表示为（Q，K），其中Q是一个非空集合，K是Q形成的子集，它至少包含了Q和空集∅. 集合Q成为知识结构（Q，K）的域（domain），且∪K=Q.<br>通俗意义上讲，Q是由一系列的问题构成，称为知识结构的域（domain），K是由Q的子集组成的集合，其中的集合元素称为知识状态，且K至少包含了Q以及空集∅∅.<br>对于给定的知识结构( Q, K) , ≤是定义在Q上的关系: r≤q⟺Kr⊇Kqr≤q⟺Kr⊇Kq, 其中r,q∈Q,Kr,Kqr,q∈Q,Kr,Kq∈K表示包含问题r,q的知<br>识状态的集合。 当r,q之间满足上述关系时, 称r可以从q猜测出来。 在应用上可以理解为: 从问题r的解决猜测出学生也可以解决问题q, 或者说解决问题q是解决问题r的前提, 对应的关系≤称为猜测关系, 猜测关系的存在可以大大方便知识结构的建立过程, 我们也可以从猜测关系的存在可知并不是所有子集都能成为知识状态。<br>kstructure()函数是包kst中构建知识结构的函数。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;kst &lt;- kstructure(set(set(<span class="string">"d"</span>),set(<span class="string">"a"</span>,<span class="string">"c"</span>),set(<span class="string">"e"</span>,<span class="string">"f"</span>)</span><br><span class="line">                  ,set(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>),set(<span class="string">"a"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>),set(<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>),set(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>)</span><br><span class="line">                      ,set(<span class="string">"a"</span>,<span class="string">"c"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>),set(<span class="string">"a"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>)))</span><br><span class="line"> &gt; kst</span><br><span class="line">&#123;&#123;<span class="string">"d"</span>&#125;, &#123;<span class="string">"a"</span>, <span class="string">"c"</span>&#125;, &#123;<span class="string">"e"</span>, <span class="string">"f"</span>&#125;, &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;, &#123;<span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>&#125;, &#123;<span class="string">"a"</span>, <span class="string">"b"</span>,</span><br><span class="line"> <span class="string">"c"</span>, <span class="string">"d"</span>&#125;, &#123;<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>&#125;, &#123;<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>,</span><br><span class="line"> <span class="string">"e"</span>, <span class="string">"f"</span>&#125;&#125;  </span><br><span class="line">&gt; sets_options(<span class="string">"quote"</span>,<span class="literal">FALSE</span>)  <span class="comment">#去掉引号</span></span><br><span class="line">&gt; kst</span><br><span class="line">&#123;&#123;d&#125;, &#123;a, c&#125;, &#123;e, f&#125;, &#123;a, b, c&#125;, &#123;a, c, d&#125;, &#123;d,</span><br><span class="line"> e, f&#125;, &#123;a, b, c, d&#125;, &#123;a, c, e, f&#125;, &#123;a, c, d, e,</span><br><span class="line"> f&#125;&#125;                   </span><br><span class="line"><span class="comment">#输入在cmd框上输入kstructure，即可看其源码：</span></span><br><span class="line">&gt; kstructure</span><br><span class="line">dependencies：<span class="keyword">library</span>（sets），<span class="keyword">library</span>（relations）</span><br><span class="line"><span class="keyword">function</span> (x) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">#检查x</span></span><br><span class="line">    <span class="keyword">if</span> (!inherits(x, <span class="string">"relation"</span>) &amp; !inherits(x, <span class="string">"set"</span>)) &#123;</span><br><span class="line">        <span class="keyword">stop</span>(sprintf(<span class="string">"%s must be a relation or a set of subsets."</span>, </span><br><span class="line">            dQuote(<span class="string">"x"</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#将关系转换成集合</span></span><br><span class="line">    <span class="keyword">if</span> (inherits(x, <span class="string">"relation"</span>)) &#123;</span><br><span class="line">        relmat &lt;- relation_incidence(x)</span><br><span class="line">        mode(relmat) &lt;- <span class="string">"logical"</span></span><br><span class="line">        x &lt;- as.set(apply(relmat, <span class="number">2</span>, <span class="keyword">function</span>(z) as.set(names(which(z)))))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        x &lt;- as.set(lapply(lapply(x, as.character), as.set))</span><br><span class="line">    &#125;</span><br><span class="line">    names(x) &lt;- <span class="literal">NULL</span></span><br><span class="line">    class(x) &lt;- unique(c(<span class="string">"kstructure"</span>, class(x)))</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装R包Rgraphviz：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span>(<span class="string">"http://bioconductor.org/biocLite.R"</span>)</span><br><span class="line">    biocLite(<span class="string">"Rgraphviz"</span>)</span><br></pre></td></tr></table></figure><h2 id="ALEKS-知识空间理论的应用"><a href="#ALEKS-知识空间理论的应用" class="headerlink" title="ALEKS-知识空间理论的应用"></a>ALEKS-知识空间理论的应用</h2><p>ALEKS是一个互联网上的指导和评估程序，现在包括了数学、化学等课程。<br>它和传统的数值计分不同的是， ALEKS使用知识空间的原理来制定了一个主题集合，这个集合的某些元素是学生回答对这道题目的关键因素。通过评估诊断，推荐哪些主题需要学生学习，并且允许学生选择可交互的学习模块来学习这些主题。<br>LEKS最大的特色在于使用人工智能（AI）来映射每个学生的知识状态细节。在每一刻，ALEKS都知道你是否掌握了相关主题，如果没有掌握，ALEKS会知道你在这时刻里准备学习这个主题。ALEKS使用这种方式来让学生更加有效的学习，它会连续为学生提供在当时时间点想学习的主题，这样做的目的是可以给学生带来更多学习上的自信和快乐。<br>ALEKS是基于网页在线学习和评估的系统，它使得美国数百万的学生受益。它来源于知识空间理论(“KST”),所有的内容都是聘请的专家设计的，他们都是在这个领域里有着多年的教育教学经验和研究经验。<br>ALEKS的主旨就是希望学生们主动学习、自主学习。<br>在ALEKS中的多数问题就是没有固定的答案的，学生们解决这种没有固定答案的问题避免了阅读或者观看其他人怎么解决这个问题，这样就可以使用不同的方法、技术手段来回答这种开放式的问题。<br>ALEKS有着复杂精密的答案处理系统，使得可以实时评估分析学生们的答案，以便可以快速的给学生们作出反馈<br>ALEKS在每次新的主题被学习后都会全面的更新学生们的知识状态，它会持续的收集和分析从学生测试和学习过程中得来大量的统计数据。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul><li>1.<a href="https://www.aleks.com/about_aleks/knowledge_space_theory" target="_blank" rel="noopener">knowledge space</a></li><li><ol start="2"><li><a href="https://github.com/cran/kst" target="_blank" rel="noopener">kst源码</a></li></ol></li><li>3.<a href="https://www.aleks.com/about_aleks/overview" target="_blank" rel="noopener">OVERVIEW OF ALEKS</a></li><li>4.<a href="https://www.aleks.com/about_aleks/publications_kst" target="_blank" rel="noopener">Aleks相关出版物</a></li><li><ol start="5"><li>杨文正, 邹霞. 运用知识空间理论分析概念图[J]. 中国电化教育, 2011(3):83-87. </li></ol></li><li><ol start="6"><li>傅骞, 孙波. 知识空间理论与项目反应理论对比研究[J]. 中国电化教育, 2004(5):75-76. </li></ol></li><li><ol start="7"><li>傅骞, 刘志波, 陈良柱. 基于扩展知识空间理论的新一代教育资源平台研究[J]. 电化教育研究, 2006(4):39<br>1Cosyn, E., &amp; Thiéry, N. (2000). A Practical Procedure to Build a Knowledge Structure. Journal of Mathematical Psychology, 44, 383-407.<br>Degreef, E., Doignon J.-P., Ducamp A., &amp; Falmagne J.-C. (1986). Languages for the assessment of knowledge. Journal of Mathematical Psychology, 30, 243-256.<br>Doignon, J.-P. &amp; Falmagne, J.-C. (1985). Spaces for the assessment of knowledge. International Journal of Man-Machine Studies, 23, 175-196.<br>Doignon, J.-P. &amp; Falmagne, J.-C. (1999). Knowledge Spaces. Springer-Verlag.<br>Dowling, C.E. (1993). Applying the basis of knowledge space for controlling the questioning of an expert. Journal of Mathematical Psychology, 37, 21-48.<br>Dowling, C.E. (1993). On the irredundant construction of knowledge spaces. Journal of Mathematical Psychology, 37, 49-62.<br>Falmagne, J.-C. (1989). A latent trait theory via stochastic learning theory for a knowledge space. Psychometrika, 54, 283-303.<br>Falmagne, J.-C. &amp; Doignon, J.-P. (1988). A class of stochastic procedures for the assessment of knowledge. British Journal of Mathematical and Statistical Psychology, 41, 1-23.<br>Falmagne, J.-C. &amp; Doignon, J.-P. (1988). A markovian procedure for assessing the state of a system. Journal of Mathematical Psychology, 32, 232-258.<br>Falmagne, J.-C. &amp; Doignon, J.-P. (2011). Learning Spaces. Springer-Verlag.<br>Falmagne, J.-C., Koppen, M., Villano, M., Doignon, J.-P. &amp; Johannesen, L. (1990). Introduction to knowledge spaces: How to build test and search them. Psychological Review, 97, 201-224.<br>Kambouri, M., Koppen, M., Villano, M. &amp; Falmagne, J.-C. (1991). Knowledge assessment: Tapping human expertise. Irvine Research Unit in Mathematical Behavioral Sciences. University of California.<br>Koppen, M. (1993). Extracting human expertise for constructing knowledge spaces: An algorithm. Journal of Mathematical Psychology, 37, 1-20.<br>Koppen, M. &amp; Doignon, J.-P. (1990). How to build a knowledge space by querying an expert. Journal of Mathematical Psychology, 34, 311-331.<br>Villano, M., Falmagne, J.-C., Johannesen, L. &amp; Doignon, J.-P. Stochastic procedures for assessing an individual’s state of knowledge. In: Proceedings of the int. conf. on computer assisted learning in post-secondary educ.</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在R语言中有一些关于教育诊断的一些包,我试着进入R包的CRAN,进行关键词检索,找到我想要试玩的那些教育数据挖掘(或许叫教育诊断更为恰当),我搜索的关键词有Item Response Theory(项目反应理论), Knowledge Space(知识空间), education.&lt;br&gt;首先,我要试玩的是kst(Knowledge Space Theory),kst的基本思想是一个学生对某领域知识的掌握程度可以通过该学生对问题的应答情况来体现，问题可以被学生答对打错。知识空间通俗意义上讲为构成某一领域知识的所有可能的知识状态的集合。&lt;br&gt;用途：自适应构造每个学生的学习路径，针对不同学生所缺乏的知识点来推荐相应的高速有效的学习路径。&lt;/p&gt;
    
    </summary>
    
    
      <category term="教育数据挖掘" scheme="http://yoursite.com/categories/%E6%95%99%E8%82%B2%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="知识空间理论" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%A9%BA%E9%97%B4%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>使用ANki 5年后，为什么我切换到SuperMemo</title>
    <link href="http://yoursite.com/2019/09/13/%E4%BD%BF%E7%94%A8ANki-5%E5%B9%B4%E5%90%8E%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%88%87%E6%8D%A2%E5%88%B0SuperMemo/"/>
    <id>http://yoursite.com/2019/09/13/使用ANki-5年后，为什么我切换到SuperMemo/</id>
    <published>2019-09-13T07:01:40.000Z</published>
    <updated>2019-09-16T05:11:52.053Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://masterhowtolearn.wordpress.com/2018/10/28/why-i-switched-to-supermemo-after-using-anki-for-5-years-with-over-50000-cards-and-420000-total-reviews/#more-9" target="_blank" rel="noopener">原文链接</a><br>目录</p><ul><li><a href="#1、Anki的故事">1、Anki的故事</a></li><li><a href="#2、我在尝试切换到SuperMemo时失败了">2、我在尝试切换到SuperMemo时失败了</a></li><li><a href="#3、为什么我切换到SuperMemo">3、为什么我切换到SuperMemo</a><a id="more"></a></li><li><a href="#4、来自重复的职业倦怠">4、来自重复的职业倦怠</a></li><li><a href="#5、对最佳安吉设置感到沮丧">5、对最佳安吉设置感到沮丧</a></li><li><a href="#6、SuperMemo的优秀算法">6、SuperMemo的优秀算法</a></li><li><a href="#7、知识转移的介绍">7、知识转移的介绍</a></li><li><a href="#8、我使用Anki进行知识转移的令人沮丧的任务">8、我使用Anki进行知识转移的令人沮丧的任务</a></li><li><a href="#9、实现增量阅读的好处">9、实现增量阅读的好处</a></li><li><a href="#10、闭幕致辞">10、闭幕致辞</a><h2 id="快速术语回顾"><a href="#快速术语回顾" class="headerlink" title="快速术语回顾"></a>快速术语回顾</h2>SRS = Spaced Repetition软件</li></ul><p>SM =来自super-memo.com的 SuperMemo ; 不是来自supermemo.com的课程，移动应用程序，应用程序。它们是不同的。</p><p>SuperMemo中的项目= Anki中的卡片; IR = 增量读数</p><p>Woz = Piotr Wozniak博士，Spaced Repetition算法和SuperMemo的创建者</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我的故事可能值得一读，因为我：</p><ul><li><p>自2013年9月以来一直使用Anki（超过5年）</p></li><li><p>2018年3月（7个月前）尝试过SuperMemo</p></li><li><p>放弃Anki并完全切换到SuperMemo<br>Anki的故事<br>我记得读过“ Make It Stick ” 一书，而Anki是我遇到的第一个SRS，它具有书中描述的学习原则：间隔重复和检索实践。我在2013年9月5日创建了我的Anki帐户，所以超过5年前。自从我成为Anki的忠实粉丝之后：</p><h2 id="我的Anki统计"><a href="#我的Anki统计" class="headerlink" title="我的Anki统计"></a>我的Anki统计</h2><p>对同一个人资料进行重大更改的三个期间：</p></li><li><p>高中时期</p></li><li><p>高考期间</p></li><li><p>语言学习的最新时期和当前的兴趣知识</p></li></ul><p>总评价：<br>420,003</p><p>总审核时间：<br>1,538小时</p><p>总卡数：<br>21695 + 18582 + 10052 = 50329，超过50,000张卡（三个时段之间没有重叠卡）<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g6xwpek885j30gm0kedig.jpg" alt="undefined"><br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g6xwqgp7dkj30g80wn0u3.jpg" alt="undefined"><br>PS：我刚刚意识到我甚至从2013年9月14日开始收集了collection.apkg。请记住备份人员！</p><p>编辑这篇文章的统计数据让我意识到我为Anki投入了多少时间和精力。我把我的灵魂和心灵倾注到安基。当我盯着屏幕，制作新卡并做我的代表时，有无数个小时。<br>我对安基的爱</p><ul><li><p>我买了25美元的iOS Anki只是为了表示支持（我甚至不拥有iPhone）</p></li><li><p>作为一名贫穷的大学生，我在达米恩停止接受捐款之前捐赠了两次。我刚刚查看了我的电子邮件记录：一个是2013年9月19日，另一个是2014年5月16日。我现在甚至感到惊讶，在我第一次遇到SRS后的两周内，我可以看到SRS的潜力和好处。</p></li><li><p>我开始学习Python只是因为Anki是用Python编写的，我想制作以下附加组件：</p></li></ul><p>附加想法：在显示正确答案之前再次尝试的机会</p><ul><li>我在2017年给Damien写了一封私人感谢信。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g6xwquwssqj30sg0opte4.jpg" alt="undefined"><br>我认为我的Anki统计数据和这些证据足以说我爱Anki而且我永远不会因为我的转换而讨厌它。安基挽救了我的学术生活。</li></ul><p>我在尝试切换到SuperMemo时失败了<br>我在2016年尝试过SuperMemo。当我搜索它时，我在网上搜索的所有内容都是关于从SuperMemo切换到Anki，而不是相反。我不断质疑自己为什么要放弃Anki，更好的SRS。<br>无论如何，我尝试过SuperMemo 15.由于我还是非常亲Anki，我正在尝试一种对SuperMemo非常不利的心态。当我第一次打开SuperMemo时<br><strong>该死，界面看起来很糟糕。</strong><br>有太多的按钮，选项和符号非常令人困惑。我浏览了SuperMemo的ABC，这是一个关于SuperMemo基础知识的5分钟教程。然后沮丧的周期开始了：<br>1、我想做点什么，比如改变字体，模板，插入图片/ mp3<br>2、想不通<br>3、在线搜索<br>4、只有来自SuperMemo官方网站的超长篇文章。我永远无法找到问题的确切解决方案，只能找到相关信息，并希望得到一个解决方案。互联网上似乎没有人使用SuperMemo。与此同时，我一直在想：“Anki在这方面更好，Anki可以做得更好，Anki有Ankidroid”<br>经过几轮这样的比赛后，我退出了。我不认为我在删除SuperMemo之前已经持续了几天。回想起来，我没有长时间使用它来看到IR的要点。我对用户界面和复杂性的抱怨只是缓解我认知失调的手段，也是让自己不太可能转换的借口。试图切换并不容易。毕竟，我已经使用Anki已经3年了。在尝试时，我对SuperMemo有一种评判和亲Anki的态度。<br>试图切换时的认知不协调和确认偏差<br>1.认知不协调<br>转换意味着承认我一直都错了，3年来，SRS比Anki好，我没有使用它。认知失调很强烈。</p><p>感觉就像是你一生的左翼，然后突然想要成为一个右翼。我正在抵制，拼命地坚持我认为是真实和正确的（Anki是最好的）。</p><p><a href="https://apps.ankiweb.net/docs/manual.html#what-algorithm" target="_blank" rel="noopener">https://apps.ankiweb.net/docs/manual.html#what-algorithm</a></p><p><a href="http://supermemopedia.com/wiki/Algorithm_SM-17_vs._older_SuperMemos" target="_blank" rel="noopener">http://supermemopedia.com/wiki/Algorithm_SM-17_vs._older_SuperMemos</a></p><p>当我阅读这些页面时，我完全同意Damien所说的内容并迅速驳回了supermemopedia页面：</p><p>“是。Damien的评论是完全合法的。“所有这些详细的考虑都不应该掩盖算法SM-2在实践中运行良好的事实，而算法微调对理论而言比实际原因更重要。” 所以Anki就是这样！“</p><p>从本质上讲，SuperMemo和Anki是相互排斥的：同意一方意味着不同意另一方。由于我是亲安基，我很快就克服了对更好的选择的怀疑。<br>2.确认偏差<br>每当我在Reddit上搜索时，每个人都是如此的Pro-Anki（当然，我在r / Anki里面搜索）。每个人都在说Anki如何比SuperMemo更好，并询问如何从SuperMemo切换到Anki。</p><p>谷歌搜索Anki与SuperMemo，你会看到我的感觉是双方：</p><p>Anki世界用户与Woz本人</p><p>Anki的受欢迎程度超越了SuperMemo：</p><ul><li><p>有一个完整的学习日语论坛致力于使用Anki学习日语</p></li><li><p>医学生共享Anki甲板</p></li><li><p>我最喜欢的r / Anki。这个subreddit非常有帮助和热情。</p></li></ul><p>另一方面，有Woz和唯一的Woz。他一直在更新他的维基和帮助网站</p><p>100％毫无疑问，他关于SRS和SuperMemo的言论是有偏见的。他是间隔重复算法和SuperMemo的创建者。读他的话时，我多吃了一些盐。鉴于他的立场，我不认为他的话是值得信赖的，无论多么真实。</p><p>在网上有一些关于Anki vs. SuperMemo的博客文章，但是它们非常肤浅，只是不是很有帮助而且深入; 有一个谷歌论坛，但它几乎死了：没有积极的讨论，没有活跃的成员，没有任何东西。</p><p>我的观点是，在我看来：</p><ul><li><p>世界正在使用Anki。SRS = Anki</p></li><li><p>每个人都反对SuperMemo，SuperMemo用户正在转向Anki</p></li><li><p>只有创作者在为他的软件辩护</p></li></ul><p>就是这样：我删除了SuperMemo并继续使用Anki。直到2年后我才尝试再给它一次。<br>为什么我切换到SuperMemo<br>有两个原因让我转过身来：</p><p>1.在安基烧毁</p><p>2.相信SM-17算法的优越性</p><p>但是，我的经验和算法不足以让我切换。这两个原因是我需要切换的最后一步：</p><ol><li>Anki中的知识转移令人沮丧</li></ol><p>2.实现增量阅读的好处</p><p>我在Anki的职业倦怠是由于：</p><p>1.高评价</p><p>2.对Anki的设定感到沮丧</p><p>高评价计数使我调整了Anki设置。是的，调整它降低了审查次数，但它也使我对于弄乱算法并降低效率和效率感到偏执。为了证明我的新设置，我一直在研究，这只会导致更多的挫败感。</p><p>1.在Anki中燃烧<br>1.高评价<br>当我开始学习外语时，高度复习的积累特别明显。如果那天我没有完成我的销售代表，那么审核计数会不断积累，在我知道之前，100张卡片会变成800张卡片。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g6xwuqnp12j30ai0370ss.jpg" alt="undefined"><br>图片来自2016年11月22日：我在255分钟（超过4小时）内研究了1163张卡片。如果记忆有效，我应该花费超过4个小时做我的代表。在Anki，学习时间并不总是反映真实的学习时间。</p><p>有很多天我不得不审查超过500张卡片，我有多个这样的套牌。我记得每天，每天都要忠实地练习词汇，经历所有的评论。几天之后，我会看到评论从500到300减少到200 ……</p><p>然后，如果我几天没有做我的代表，审查将拍摄超过1000张卡。这要么是因为懒惰（“看？评论计数已经平息。让我休息一下。”）或生活中发生的事情。然后我不得不再次通过评论。每天，我都会点击桌面安基，翻阅词汇; 每当我在这里和那里有时间，我都会在Ankidroid做我的代表。通常，审核次数太高，我无法添加更多新卡。</p><p>这样做了一个月之后，我被烧了。我想停止学习，与其他感兴趣的科目一起学习。但我也不想放弃学习。这总是在我的头脑中：</p><p>“应该继续做我的代表？但是还有很多卡片可供选择！但如果我不审查并让审查建立……第二天我将遭受更多的痛苦…“</p><p>是的，你可能会说这不是学习外语的正确方法。无论如何，这种经历使我开始研究Anki设置和算法。<br>2.最佳Anki设置令人沮丧<br>由于钻井词汇的高评价，我开始阅读有关记忆的文献，并研究Anki设置和算法。</p><p>从理想的难度Vs. 词汇习得的Anki设置：</p><p>“因此，应该避免过于简单的检索。[…]或者，如果我失败了，我怎么知道这是为了更好的后续学习，或者我的设置过于苛刻，以至于我实际上完全忘记了这些材料？“</p><p>“如何平衡理想难度和Anki设置之间的细微差别？如何判断它是否太多，对我来说太难了？“</p><p>“我担心的是，更多的评论实际上会影响我的保留率。”</p><p>从  与Anki设置弄乱我的后5个月的调查结果：</p><p>“看起来反直觉，如此大的间隔，如何有效地记忆？”</p><p>“我无法相信我一直在使用默认设置，当我再次按下时，它会将卡片重新调整为1天。”</p><p>正如您所看到的，我非常认真地调整设置。我主要跟随一位日本学习“大师”的背景，他会引用研究并用研究来支持他的主张。他比其他用户的个人喜好更值得信赖。</p><p>我的5个月的调查结果很明显，都是垃圾和噪音。我无法得出任何有意义的结论或应用。变量太多了。哎呀，我甚至不知道如何正确设计我的“实验”。在我开始之前，实验失败了。</p><p>但我的实验强调：</p><p>1.没有人关心算法优化。我无法在网上找到（好）答案所以我不得不尝试自己做实验。似乎大多数人都不了解改变算法对长期保留和重复工作量的影响的重要性和程度。</p><p>2.大多数情况下，人们会以这种方式或那种方式改变设置只是因为“感觉正确”或“这就是我这样做”而没有给出正确的理由或解释。</p><p>我对更改设置和算法优化的调查只会导致更多的挫折和疑问。Anki中有很多参数和设置：</p><p>步骤，渐变间隔，轻松间隔，开始轻松，轻松奖励，间隔修改器，步骤和新的时间间隔。</p><p>理解每个参数的含义并不难。真正的问题是每个参数如何相互影响。不同的参数是如此相互关联的，改变一个参数会对评论和算法的行为产生巨大的影响。</p><p>另一个类似于Is Red Meat Killing Us的类比？：</p><p>[治疗组接受治疗]用14种不同的化疗药物，加上放射治疗，加上手术，加上催眠治疗，加上每日按摩，加上每日冰淇淋三明治，以及小猫的每日访问。</p><p>一年后，治疗组已经过了对照组，因此治疗效果很好。但是，我们如何确切地知道是什么导致了生存的好处呢？它是14种药物中的3种吗？手术？小猫？我们无法从这个实验中得知。</p><p>在Anki中，可能会减少起始缓和和轻松奖励的组合，而增加步数和新时间间隔的效果会更好。或者，起动舒适度每增加10％就必须与Easy Bonus减少30％相匹配。</p><p>我根本不知道如何改变它们。我还是没有。</p><p>由于我不知道我的变化如何影响我的长期保留，因此我对于破坏算法的效率并浪费我的时间感到妄想。</p><p>你可能会争辩说，“嘿，你可以查看统计数据并找出答案！”</p><p>统计数据并不能全面了解情况。您没有任何标准可以使用“修改后的算法”确定后续学习的有效性。审查时间，审查计数和答案按钮都受以前的Anki设置。</p><p>是的，您可以根据此公式调整间隔修改器，</p><p>log（90％）/ log（85％）<br>但是，预期结果仅在您遵循默认设置并且仅更改间隔修改器的条件下才有效。如果您还更改了其他参数，则该公式不会考虑其他参数的更改如何影响算法。算法中的所有参数协同工作。1 + 1≠2。更多不是更好，更少不一定更糟。</p><p>例如，你已经发现Anki的新时间间隔的残酷性（稍后将详细介绍）。你是如何建议解决的？</p><p>您是否将新的间隔时间更改为30％，50％或70％？根据什么标准，原因，证据？你只是觉得调整它吗？</p><p>例如，“我是否过多地增加了间隔修改器，以至于太多的重复会损害我的保留？”</p><p>1.更多≠更好和更高的保留<br>我查看同一张卡的次数越多，我实际上可能会伤害我的长期保留：</p><p>从“ 关于记忆，忘记和学习的共生 ”：</p><p>“如果一个项目尚未转变为学习状态，但可用于短期记忆（由于新生），研究该项目对其学习没有影响。”</p><p>“重要的是要认识到，不仅努力检索可以增强学习，而且反过来也是如此：简单易用的检索似乎导致基本上没有学习。”</p><p>从“空间检索的复杂性：决议 ”：</p><p>“在太容易的条件下进行多次测试会破坏测试的积极效果。在0-0-0的条件下，受试者被要求在他们基本上总是正确的条件下三次召回物品。然而，这三个（简单）检索导致后来的保留，甚至比在更困难的条件下给出的单个测试更糟糕（两个延迟的5个条件）。<br><img src="http://ww1.sinaimg.cn/large/006MwQ98ly1g6xwvqptkvj30ga0cjwf4.jpg" alt="undefined"><br>“诸如保持条件不变和可预测以及在特定任务中集中试验的操作通常似乎可以提高教学或培训期间的学习速度，但通常无法支持长期保留和转移。”</p><p>“如果文献在任何一点都很明确，那就是在容易检索的条件下重复测试会导致长期保留不良。”</p><p>并非所有检索都是相同的。如果我增加了区间修饰符，我会更频繁地查看。更多的评论会带来更好的表现（更成功的回忆），但这并不意味着更好的长期保留。</p><p>换句话说，如果我增加了间隔修改器，不仅可能会浪费我的时间，还会伤害我的长期保留。那么更多的工作和更糟糕的长期保留？有什么可能比那更糟？！</p><p>2.检索强度和存储强度之间的关系是违反直觉的<br>从“ 关于记忆，忘记和学习的共生 ”：</p><p>“[理解这样的想法]’回答问题的时间越长，答案越可能在以后重新调整’需要理解检索是一个学习事件，更难以（成功）检索，学习越有效。</p><p>“在新的废弃理论中，当待学习（或重新学习）的信息具有低检索强度和高存储强度时，存储和检索强度的最大增量就会出现。”</p><p>这是理想困难的概念：你越是难以回想起答案，只要你成功，你的长期保留就越好。因此，增加Interval Modifier会影响我的长期保留，因为它们使审查更容易，从而破坏了理想难度的影响。</p><p>从“ 让自己的事情变得艰难，但是以一种好的方式：创造理想的困难来提高学习 ”：</p><p>“在没有重大学习的情况下，可以在整个实践中实现性能的显着提升。”</p><p>迷你结论<br>我的观点是，我认为任何用户（包括我自己）都没有足够的知识或数据来确定如何更改任何参数，更不用说确定最佳间隔了。你“感觉”无效。感性流畅，误导学习表现的熟悉感，错误的学习判断都是认知偏见和反对学习的元记忆幻觉。</p><p>然而，默认设置效率非常低（稍后会更多），并且与我从文献中学到的内容不一致。所以我陷入了两难的境地，因为我知道如果不知道如何更改默认设置。</p><p>通过调整Anki设置我发现了什么<br> 有关默认Anki算法行为的更多详细信息，请参阅我的帖子  我从调整Anki设置中发现的内容。</p><p>另一方面，在SuperMemo中，算法主要是在幕后。您只能更改遗忘曲线索引。哎呀，Woz甚至限制你只有10％-20％的范围。而已。我完全无法控制算法的行为方式。对我来说，这是一个很大的安慰。我不必考虑是否应该更改一些参数。我甚至不会考虑因为我不能。没有更多的猜测，然后担心弄乱它。我只需要相信（而且我确实）该算法将为我处理所有事情。缺乏选择和选择是自由的。</p><p>SuperMemo的优秀算法<br>请参阅我的帖子  在SuperMemo中的算法比Anki中的算法更好吗？ 有关不同算法之间比较的更多详细信息。</p><p>知识转移的介绍<br>请参阅我的文章  “知识转移简介”，  简要介绍知识转移。</p><p>实现知识转移需求：<br>增加你对长期记忆的了解<br>练习检索它们<br>以某种方式将“相关”信息“加载”到工作记忆中<br>以某种方式将它们串在一起<br>丁！在那里你拥有它：刚出现或成功应用先验知识的新见解。<br>对于第1步和第2步，SRS可以提供​​极大的帮助。</p><p>您如何使用SRS以及其他学习技巧为您提供更好的实现学习转移的可能性？</p><p>摘要比绘制思维导图更好吗？</p><p>对于学习转移，自我测试比自我解释更好吗？</p><p>因此，这开始了我使用Anki转移知识的追求。</p><p>我使用Anki进行知识转移的令人沮丧的任务<br>我在r / Anki中问了类似的问题：</p><p>使用Anki时如何保持知识的“全局”？</p><p>提出的解决方案：如何通过Anki学习概念和知识的大局</p><p>例如，我学习了Halo效果的概念，从“思考，快速和慢速”中读取了一些例子。然后在Anki中，我会记住一些关于Halo效果的关键词，总结一些例子并尝试提出一些例子。通过这样做，我希望能够在现实生活中识别出Halo效应的新事件和情况，因此，重新校准我的判断以获得更好的批判性思维。</p><p>我理解我希望实现的目标是没有客观衡量，因为“全局思考”，知识转移，创造性见解都是模糊的术语，没有明确的标准。尽管如此，我很快意识到这只是因为我能够回想起那些被隐藏的关键词= /我可以在需要时回想起那个概念或想法。</p><p>Derek Sivers在接受“成为超人”的采访中提到了类似的担忧：</p><p>[… ..]所以我对这220本书的第一个想法，你看到的每一本都是那本书上的页面和页面。我的第一个想法就是如何将其置于间隔重复中。就像我怎么能记住我从这些书中学到的东西间隔重复？老实说，我还没有想出答案。我实际上玩过一些东西。我做了 - 我认为你称之为封闭技术，你省略了某些单词。但即便如此，我还是说，“好吧，这不是我要记住的句子。我不是在背诵诗歌。我想要记住这个概念，这个想法让它变得像我之前所说的那样内化，“不管你害怕什么，去做吧”或者你的10条原则清单。</p><p>我认为他也是，寻求实现知识转移。如果我没有弄错的话，“内化”与知识转移高度相似。</p><p>我越来越长时间地记住一个概念的关键词，我感觉越多，嗯……我只是记住一个概念的关键词。这些概念似乎在我的脑海中孤立存在，就像单独监禁囚犯一样。知道“外部视图”或“可用性启发式”的存在当然是有帮助的，但我希望获得的不仅仅是了解名称。</p><p>从问答的可能答案：为什么Anki非常适合记忆而不是学习？：</p><p>一位成员提到，</p><p>“但是我转而使用SuperMemo，过了一段时间我注意到了大量的连接。”</p><p>通常，我不相信轶事证据，因为你肯定能找到与此类陈述完全相反的证据。尽管如此，他理解我的关注，他所描述的内容对我很有吸引力：</p><p>“我在获取大图片连接方面有类似的经验，SM帮助解决了这个问题。”</p><p>此外，在那一点上，我对Anki的设置感到非常沮丧，我愿意尝试新的东西。这个reddit帖子是棺材里的钉子，让我再次尝试SuperMemo。</p><p>我很清楚我正在寻找可能超出Anki范围的东西。没人能保证更好的算法或增量阅读可以帮助我转移知识。但至少我相信它会有很大的帮助。知识转移依赖于更多的背景知识。由于SRS在长期记忆中起着重要作用，因此更好的长期保留算法也应有助于知识的转移。</p><p>实现增量阅读的好处<br>更新：有关IR的更深入的文章，请参阅此处和此处<br>我有记录我的SuperMemo使用记录：</p><p>log 1（2018年3月22日）：</p><p>我不必立刻处理整篇文章。我真的很喜欢在一段时间内多次处理它的想法。它是分布式实践，是学习原则之一。当我回到文章时，由于时间的推移，我会更好地理解。所以更多的理解=&gt;更好的理解。</p><p>Log 2（2018年3月29日）：</p><p>没有更多的压力来阅读和完成一篇文章。我可以将文章导入SM，并让它决定何时向我展示。我也可以停止阅读，按下一步并稍后重新访问同一篇文章。由于完成的压力消失了，我可以阅读更多的文章。<br>我可以逐步处理文章。为胜利增加阅读！</p><p>当我写日志的时候，我还在研究增量阅读的早期，但我能以某种方式看到它的潜力; 不知何故IR点击的好处和光彩。如果你曾经问我那时红外有什么特别之处，我可能无法告诉你。更有意义的是IR有一些非常特殊的东西。</p><p>简而言之，增量阅读是阅读和阅读之间的交错，这极大地有助于理解，从而提供更好的知识转移机会。增量阅读的壮大之处在于它有助于避免快速达到工作记忆的瓶颈。</p><p>为什么？</p><p>工作记忆的空间非常有限。尝试在5条新信息之间慢跑，你很可能会在中间失去思路。神奇的数字7 +/- 2。</p><p>摘自“为什么学生不喜欢学校？”：</p><p>“如果你试图处理太多事实或者以太多方式比较它们，你就会忘记你正在做的事情。假设我说，’蝴蝶，蜻蜓，筷子，碉堡和稻草人有什么共同之处？’ 这些只是太多项目无法同时比较。当你在考虑如何将药盒与筷子联系起来时，你已经忘记了其他物品是什么。“</p><p>另一方面，增量阅读可帮助您在进一步处理之前将一些信息分块，这样您就有更多的思考空间。</p><p>例如，当我第一次阅读以下论文的前几段时：</p><p>脂肪氧化产物在油炸食品中呈现的慢性非传染性疾病风险</p><p>鉴于我们的观察，这些LOP可能在广泛的人类非传染性疾病（NCDs）的发展，进展和发病率方面发挥关键作用，这无疑将促进全球医疗成本上升。实际上，30-35％的由环境来源引起的人类癌症可归因于单独的饮食，因此高度可想象的是，饮食LOP可能对该发病水平有显着影响。因此，需要严格努力限制在具有高LOP含量的CFO中油炸食品的消费。由于富含过氧化物抗性的MUFA，特别是SFA的CFO分别在油炸过程中产生更低和更低水平的此类LOP毒素，因此它们为那些含有PUFA的人提供更安全，更健康的替代品。</p><p>据说，你对营养和食物都是全新的：你不知道PUFA，MUFA，LOPs，CFO是什么。继续阅读可能非常具有挑战性和令人沮丧，因为随着时间的推移，您经常会遇到这些缩写并忘记PUFA，MUFA，LOP，CFO是什么。你会经常问自己，“LOP又是什么？他们在做什么？”</p><p>但是，在增量阅读期间，我会停止阅读并做出以下项目，</p><p>问：PUFA的全名？</p><p>答：多不饱和脂肪酸</p><p>问：MUFA的全名？</p><p>答：单不饱和脂肪酸</p><p>问：哪种脂肪酸更容易受到热诱导氧化？</p><p>答：PUFA</p><p>问：哪种脂肪酸对过氧化有抵抗力？</p><p>答：SFA</p><p>也许我甚至会谷歌和一些关于多不饱和脂肪酸和单不饱和脂肪酸的基本知识的项目。我没有，因为我已经基本了解它们是什么。我只是不知道PUFA =多不饱和脂肪酸和MUFA =单不饱和脂肪酸。</p><p>在SuperMemo再次向我展示文章之前，可能需要几天甚至几周。在此期间，我将回答我在该段落中提出的问答和完整性（如上所述）。值得一提的是，以这种方式间隔你的阅读和学习可以让睡眠发挥其魔力：巩固记忆。</p><p>当我终于再次遇到这篇文章的时候，我会理解基本的事实并记住术语。通过这种方式，当我继续阅读时，我将不会在基础知识上挣扎。不再“什么是PUFA了？他们有什么问题？“</p><p>制作和回忆这些问题有助于您熟悉基本知识：论文的术语，基本思想和整个论点。我增加了我的先前知识，减少了工作记忆的工作量，因此可以分配更多的东西以便更深入地理解。</p><p>这与20条知识制定规则的基础知识相符。</p><p>这就是Michael Nielsen在Anki所做的事情。他正在进行增量阅读，但可能没有意识到。然而，关于Anki中物品与其相关物品（卡片）之间的间距和交错存在一个关键缺点。请参阅SuperMemo中增量阅读的意义：第二部分</p><p>闭幕致辞<br>本文总结了我的期刊与SRS。写这篇文章很好地回顾了我如何从Anki的回顾到现在用SuperMemo学习。</p><p>我从来没有后悔从第1天开始切换到SuperMemo的决定。我全心全意地相信SuperMemo比Anki更能为我服务。我非常感谢我与Anki的五年精彩以及两者之间的每一次经历。</p><p>无论你是否考虑改变，我希望你从阅读中获得一些东西。</p><p>如果我已经说服你试试SuperMemo，你可能会对我如何将超过50,000张卡片的我的Anki系列移动到SuperMemo感兴趣</p><p>如果您还没有，请务必在Twitter上关注我和/或关注此博客，这样每当我发布博客文章时您都会收到通知。</p><p>如果您发现我的内容有所帮助，请考虑访问此支持页面或通过Patreon（订阅）或Ko-fi（一次性）支持此博客。谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://masterhowtolearn.wordpress.com/2018/10/28/why-i-switched-to-supermemo-after-using-anki-for-5-years-with-over-50000-cards-and-420000-total-reviews/#more-9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1、Anki的故事&quot;&gt;1、Anki的故事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2、我在尝试切换到SuperMemo时失败了&quot;&gt;2、我在尝试切换到SuperMemo时失败了&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3、为什么我切换到SuperMemo&quot;&gt;3、为什么我切换到SuperMemo&lt;/a&gt;
    
    </summary>
    
    
      <category term="学习方法" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="SuperMemo" scheme="http://yoursite.com/tags/SuperMemo/"/>
    
  </entry>
  
  <entry>
    <title>面向对象思想</title>
    <link href="http://yoursite.com/2019/09/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2019/09/11/面向对象思想/</id>
    <published>2019-09-11T02:08:07.000Z</published>
    <updated>2019-09-11T02:12:25.446Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#一三大特性">一、三大特性</a><ul><li><a href="#封装">封装</a></li><li><a href="#继承">继承</a></li><li><a href="#多态">多态</a><a id="more"></a></li></ul></li><li><a href="#二类图">二、类图</a><ul><li><a href="#泛化关系-generalization">泛化关系 (Generalization)</a></li><li><a href="#实现关系-realization">实现关系 (Realization)</a></li><li><a href="#聚合关系-aggregation">聚合关系 (Aggregation)</a></li><li><a href="#组合关系-composition">组合关系 (Composition)</a></li><li><a href="#关联关系-association">关联关系 (Association)</a></li><li><a href="#依赖关系-dependency">依赖关系 (Dependency)</a></li></ul></li><li><a href="#三设计原则">三、设计原则</a><ul><li><a href="#solid">S.O.L.I.D</a></li><li><a href="#其他常见原则">其他常见原则</a></li></ul></li><li><a href="#参考资料">参考资料</a><h1 id="一、三大特性"><a href="#一、三大特性" class="headerlink" title="一、三大特性"></a>一、三大特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</li></ul><p>优点：</p><ul><li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p><p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender == <span class="number">0</span> ? <span class="string">"man"</span> : <span class="string">"woman"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" is working very hard!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" can't work any more!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承实现了  <strong>IS-A</strong>  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为  <strong>向上转型</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态分为编译时多态和运行时多态。编译时多态主要指方法的重载，运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定。</p><p>运行时多态有三个条件：</p><ul><li>继承</li><li>覆盖（重写）</li><li>向上转型</li></ul><p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Instument is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Percussion is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Instrument&gt; instruments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        instruments.add(<span class="keyword">new</span> Wind());</span><br><span class="line">        instruments.add(<span class="keyword">new</span> Percussion());</span><br><span class="line">        <span class="keyword">for</span>(Instrument instrument : instruments) &#123;</span><br><span class="line">            instrument.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、类图"><a href="#二、类图" class="headerlink" title="二、类图"></a>二、类图</h1><p>以下类图使用 <a href="https://www.planttext.com/" target="_blank" rel="noopener">PlantUML</a> 绘制，更多语法及使用请参考：<a href="http://plantuml.com/" target="_blank" rel="noopener">http://plantuml.com/</a></p><h2 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 (Generalization)"></a>泛化关系 (Generalization)</h2><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p><div align="center"> <img src="../pics//SoWkIImgAStDuU8goIp9ILLmJyrBBKh.png"> </div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Generalization</span><br><span class="line"></span><br><span class="line">class Vihical</span><br><span class="line">class Car</span><br><span class="line">class Trunck</span><br><span class="line"></span><br><span class="line">Vihical &lt;|-- Car</span><br><span class="line">Vihical &lt;|-- Trunck</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h2 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h2><p>用来实现一个接口，在 Java 中使用 implement 关键字。</p><div align="center"> <img src="../pics//SoWkIImgAStDuU8goIp9ILK8IatCoQn.png"> </div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Realization</span><br><span class="line"></span><br><span class="line">interface MoveBehavior</span><br><span class="line">class Fly</span><br><span class="line">class Run</span><br><span class="line"></span><br><span class="line">MoveBehavior &lt;|.. Fly</span><br><span class="line">MoveBehavior &lt;|.. Run</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h2 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h2><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p><div align="center"> <img src="../pics//SoWkIImgAStDuU8goIp9ILLmJ4ylIar.png"> </div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Aggregation</span><br><span class="line"></span><br><span class="line">class Computer</span><br><span class="line">class Keyboard</span><br><span class="line">class Mouse</span><br><span class="line">class Screen</span><br><span class="line"></span><br><span class="line">Computer o-- Keyboard</span><br><span class="line">Computer o-- Mouse</span><br><span class="line">Computer o-- Screen</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h2 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h2><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p><div align="center"> <img src="../pics//SoWkIImgAStDuU8goIp9ILLmpiyjo2_.png"> </div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Composition</span><br><span class="line"></span><br><span class="line">class Company</span><br><span class="line">class DepartmentA</span><br><span class="line">class DepartmentB</span><br><span class="line"></span><br><span class="line">Company *-- DepartmentA</span><br><span class="line">Company *-- DepartmentB</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h2 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 (Association)"></a>关联关系 (Association)</h2><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><div align="center"> <img src="../pics//SoWkIImgAStDuU8goIp9ILLmB2xEJyv.png"> </div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Association</span><br><span class="line"></span><br><span class="line">class School</span><br><span class="line">class Student</span><br><span class="line"></span><br><span class="line">School &quot;1&quot; - &quot;n&quot; Student</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h2 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 (Dependency)"></a>依赖关系 (Dependency)</h2><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p><ul><li>A 类是 B 类中的（某中方法的）局部变量；</li><li>A 类是 B 类方法当中的一个参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li></ul><div align="center"> <img src="../pics//LOun2W9134NxVugmbJPp15d4LalxC4O.png"> </div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Dependency</span><br><span class="line"></span><br><span class="line">class Vihicle &#123;</span><br><span class="line">    move(MoveBehavior)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MoveBehavior &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">note &quot;MoveBehavior.move()&quot; as N</span><br><span class="line"></span><br><span class="line">Vihicle ..&gt; MoveBehavior</span><br><span class="line"></span><br><span class="line">Vihicle .. N</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h1 id="三、设计原则"><a href="#三、设计原则" class="headerlink" title="三、设计原则"></a>三、设计原则</h1><h2 id="S-O-L-I-D"><a href="#S-O-L-I-D" class="headerlink" title="S.O.L.I.D"></a>S.O.L.I.D</h2><table><thead><tr><th align="center">简写</th><th align="center">全拼</th><th align="center">中文翻译</th></tr></thead><tbody><tr><td align="center">SRP</td><td align="center">The Single Responsibility Principle</td><td align="center">单一责任原则</td></tr><tr><td align="center">OCP</td><td align="center">The Open Closed Principle</td><td align="center">开放封闭原则</td></tr><tr><td align="center">LSP</td><td align="center">The Liskov Substitution Principle</td><td align="center">里氏替换原则</td></tr><tr><td align="center">ISP</td><td align="center">The Interface Segregation Principle</td><td align="center">接口分离原则</td></tr><tr><td align="center">DIP</td><td align="center">The Dependency Inversion Principle</td><td align="center">依赖倒置原则</td></tr></tbody></table><h3 id="1-单一责任原则"><a href="#1-单一责任原则" class="headerlink" title="1. 单一责任原则"></a>1. 单一责任原则</h3><blockquote><p>修改一个类的原因应该只有一个。</p></blockquote><p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p><h3 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="2. 开放封闭原则"></a>2. 开放封闭原则</h3><blockquote><p>类应该对扩展开放，对修改关闭。</p></blockquote><p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p><p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p><h3 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h3><blockquote><p>子类对象必须能够替换掉所有父类对象。</p></blockquote><p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p><p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p><h3 id="4-接口分离原则"><a href="#4-接口分离原则" class="headerlink" title="4. 接口分离原则"></a>4. 接口分离原则</h3><blockquote><p>不应该强迫客户依赖于它们不用的方法。</p></blockquote><p>因此使用多个专门的接口比使用单一的总接口要好。</p><h3 id="5-依赖倒置原则"><a href="#5-依赖倒置原则" class="headerlink" title="5. 依赖倒置原则"></a>5. 依赖倒置原则</h3><blockquote><p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br>抽象不应该依赖于细节，细节应该依赖于抽象。</p></blockquote><p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p><p>依赖于抽象意味着：</p><ul><li>任何变量都不应该持有一个指向具体类的指针或者引用；</li><li>任何类都不应该从具体类派生；</li><li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li></ul><h2 id="其他常见原则"><a href="#其他常见原则" class="headerlink" title="其他常见原则"></a>其他常见原则</h2><p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p><table><thead><tr><th align="center">简写</th><th align="center">全拼</th><th align="center">中文翻译</th></tr></thead><tbody><tr><td align="center">LOD</td><td align="center">The Law of Demeter</td><td align="center">迪米特法则</td></tr><tr><td align="center">CRP</td><td align="center">The Composite Reuse Principle</td><td align="center">合成复用原则</td></tr><tr><td align="center">CCP</td><td align="center">The Common Closure Principle</td><td align="center">共同封闭原则</td></tr><tr><td align="center">SAP</td><td align="center">The Stable Abstractions Principle</td><td align="center">稳定抽象原则</td></tr><tr><td align="center">SDP</td><td align="center">The Stable Dependencies Principle</td><td align="center">稳定依赖原则</td></tr></tbody></table><h3 id="1-迪米特法则"><a href="#1-迪米特法则" class="headerlink" title="1. 迪米特法则"></a>1. 迪米特法则</h3><p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p><h3 id="2-合成复用原则"><a href="#2-合成复用原则" class="headerlink" title="2. 合成复用原则"></a>2. 合成复用原则</h3><p>尽量使用对象组合，而不是继承来达到复用的目的。</p><h3 id="3-共同封闭原则"><a href="#3-共同封闭原则" class="headerlink" title="3. 共同封闭原则"></a>3. 共同封闭原则</h3><p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p><h3 id="4-稳定抽象原则"><a href="#4-稳定抽象原则" class="headerlink" title="4. 稳定抽象原则"></a>4. 稳定抽象原则</h3><p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p><h3 id="5-稳定依赖原则"><a href="#5-稳定依赖原则" class="headerlink" title="5. 稳定依赖原则"></a>5. 稳定依赖原则</h3><p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Java 编程思想</li><li>敏捷软件开发：原则、模式与实践</li><li><a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html" target="_blank" rel="noopener">面向对象设计的 SOLID 原则</a></li><li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization" target="_blank" rel="noopener">看懂 UML 类图和时序图</a></li><li><a href="http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html" target="_blank" rel="noopener">UML 系列——时序图（顺序图）sequence diagram</a></li><li><a href="http://blog.csdn.net/jianyuerensheng/article/details/51602015" target="_blank" rel="noopener">面向对象编程三大特性 —— 封装、继承、多态</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一三大特性&quot;&gt;一、三大特性&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#封装&quot;&gt;封装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#继承&quot;&gt;继承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#多态&quot;&gt;多态&lt;/a&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统</title>
    <link href="http://yoursite.com/2019/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/09/11/计算机操作系统/</id>
    <published>2019-09-11T02:05:40.000Z</published>
    <updated>2019-09-11T02:07:06.936Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#一概述">一、概述</a><ul><li><a href="#操作系统基本特征">操作系统基本特征</a></li><li><a href="#操作系统基本功能">操作系统基本功能</a></li><li><a href="#系统调用">系统调用</a></li><li><a href="#大内核和微内核">大内核和微内核</a></li><li><a href="#中断分类">中断分类</a><a id="more"></a></li></ul></li><li><a href="#二进程管理">二、进程管理</a><ul><li><a href="#进程与线程">进程与线程</a></li><li><a href="#进程状态的切换">进程状态的切换</a></li><li><a href="#进程调度算法">进程调度算法</a></li><li><a href="#进程同步">进程同步</a></li><li><a href="#经典同步问题">经典同步问题</a></li><li><a href="#进程通信">进程通信</a></li></ul></li><li><a href="#三死锁">三、死锁</a><ul><li><a href="#死锁的必要条件">死锁的必要条件</a></li><li><a href="#死锁的处理方法">死锁的处理方法</a></li></ul></li><li><a href="#四内存管理">四、内存管理</a><ul><li><a href="#虚拟内存">虚拟内存</a></li><li><a href="#分页系统地址映射">分页系统地址映射</a></li><li><a href="#页面置换算法">页面置换算法</a></li><li><a href="#分段">分段</a></li><li><a href="#段页式">段页式</a></li><li><a href="#分页与分段的比较">分页与分段的比较</a></li></ul></li><li><a href="#五设备管理">五、设备管理</a><ul><li><a href="#磁盘调度算法">磁盘调度算法</a></li></ul></li><li><a href="#六链接">六、链接</a><ul><li><a href="#编译系统">编译系统</a></li><li><a href="#静态链接">静态链接</a></li><li><a href="#目标文件">目标文件</a></li><li><a href="#动态链接">动态链接</a></li></ul></li><li><a href="#参考资料">参考资料</a></li></ul><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h3><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线或者多处理器。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h3><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。</p><h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h3><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时分复用技术和空分复用技术。例如多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。</p><h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h2 id="操作系统基本功能"><a href="#操作系统基本功能" class="headerlink" title="操作系统基本功能"></a>操作系统基本功能</h2><h3 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h3><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p><h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p><h3 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h3><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><div align="center"> <img src="../pics//tGPV0.png" width="600"> </div><br><p>Linux 的系统调用主要有以下这些：</p><table><thead><tr><th align="center">Task</th><th>Commands</th></tr></thead><tbody><tr><td align="center">进程控制</td><td>fork(); exit(); wait();</td></tr><tr><td align="center">进程通信</td><td>pipe(); shmget(); mmap();</td></tr><tr><td align="center">文件操作</td><td>open(); read(); write();</td></tr><tr><td align="center">设备操作</td><td>ioctl(); read(); write();</td></tr><tr><td align="center">信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr><td align="center">安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h2 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h2><h3 id="1-大内核"><a href="#1-大内核" class="headerlink" title="1. 大内核"></a>1. 大内核</h3><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p><p>由于各模块共享信息，因此有很高的性能。</p><h3 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h3><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p><div align="center"> <img src="../pics//2_14_microkernelArchitecture.jpg"> </div><br><h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h3><p>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p><h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p><h3 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h3><p>在用户程序中使用系统调用。</p><h1 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h3><p>进程是资源分配的基本单位。</p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><div align="center"> <img src="../pics//a6ac2b08-3861-4e85-baa8-382287bfee9f.png"> </div><br><h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>线程是独立调度的基本单位。</p><p>一个进程中可以有多个线程，它们共享进程资源。</p><div align="center"> <img src="../pics//3cd630ea-017c-488d-ad1d-732b4efeddf5.png"> </div><br><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h3><ul><li><p>拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p></li><li><p>调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p></li><li><p>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p></li><li><p>通信方面：进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。</p></li></ul><p>举例：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p><h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><div align="center"> <img src="../pics//ProcessState.png" width="500"> </div><br><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h3 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong> </p><p>按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p><strong>1.2 短作业优先 shortest job first（SJF）</strong> </p><p>按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong> </p><p>按估计剩余时间最短的顺序进行调度。</p><h3 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><p><strong>2.1 时间片轮转</strong> </p><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系。因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</p><div align="center"> <img src="../pics//8c662999-c16c-481c-9f40-1fdba5bc9167.png"> </div><br><p><strong>2.2 优先级调度</strong> </p><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p><strong>2.3 多级反馈队列</strong> </p><p>如果一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><div align="center"> <img src="../pics//042cf928-3c8e-4815-ae9c-f2780202c68f.png"> </div><br><h3 id="3-实时系统"><a href="#3-实时系统" class="headerlink" title="3. 实时系统"></a>3. 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p><p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure><h3 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h3><ul><li>同步：多个进程按一定顺序执行；</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li><strong>down</strong>  : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了  <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="3">  <strong>使用信号量实现生产者-消费者问题</strong>  </font> <br></p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，也就无法执行 up(empty) 操作，empty 永远都为 0，那么生产者和消费者就会一直等待下去，造成死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。</p><p>管程引入了  <strong>条件变量</strong>  以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><p><font size="3"> <strong>使用管程实现生产者-消费者问题</strong> </font><br></p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><p>生产者和消费者问题前面已经讨论过了。</p><h3 id="1-读者-写者问题"><a href="#1-读者-写者问题" class="headerlink" title="1. 读者-写者问题"></a>1. 读者-写者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-哲学家进餐问题"><a href="#2-哲学家进餐问题" class="headerlink" title="2. 哲学家进餐问题"></a>2. 哲学家进餐问题</h3><div align="center"> <img src="../pics//a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"> </div><br><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        put(i);</span><br><span class="line">        put((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat();</span><br><span class="line">        put_tow(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    test(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_tow</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    test(LEFT);</span><br><span class="line">    test(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(i)</span> </span>&#123;         <span class="comment">// 尝试拿起两把筷子</span></span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h3><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>它具有以下限制：</p><ul><li>只支持半双工通信（单向传输）；</li><li>只能在父子进程中使用。</li></ul><div align="center"> <img src="../pics//53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"> </div><br><h3 id="2-FIFO"><a href="#2-FIFO" class="headerlink" title="2. FIFO"></a>2. FIFO</h3><p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p><div align="center"> <img src="../pics//2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"> </div><br><h3 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h3><p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul><h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h3><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h3 id="5-共享存储"><a href="#5-共享存储" class="headerlink" title="5. 共享存储"></a>5. 共享存储</h3><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段。</p><h3 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6. 套接字"></a>6. 套接字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><h1 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h1><h2 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h2><div align="center"> <img src="../pics//c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"> </div><br><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><h2 id="死锁的处理方法"><a href="#死锁的处理方法" class="headerlink" title="死锁的处理方法"></a>死锁的处理方法</h2><h3 id="1-鸵鸟策略"><a href="#1-鸵鸟策略" class="headerlink" title="1. 鸵鸟策略"></a>1. 鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h3 id="2-死锁检测与死锁恢复"><a href="#2-死锁检测与死锁恢复" class="headerlink" title="2. 死锁检测与死锁恢复"></a>2. 死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><p>（一）每种类型一个资源的死锁检测</p><div align="center"> <img src="../pics//b1fa0453-a4b0-4eae-a352-48acca8fff74.png"> </div><br><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p>（二）每种类型多个资源的死锁检测</p><div align="center"> <img src="../pics//e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"> </div><br><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol><p>（三）死锁恢复</p><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h3 id="3-死锁预防"><a href="#3-死锁预防" class="headerlink" title="3. 死锁预防"></a>3. 死锁预防</h3><p>在程序运行之前预防发生死锁。</p><p>（一）破坏互斥条件</p><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p><p>（二）破坏占有和等待条件</p><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><p>（三）破坏不可抢占条件</p><p>（四）破坏环路等待</p><p>给资源统一编号，进程只能按编号顺序来请求资源。</p><h3 id="4-死锁避免"><a href="#4-死锁避免" class="headerlink" title="4. 死锁避免"></a>4. 死锁避免</h3><p>在程序运行时避免发生死锁。</p><p>（一）安全状态</p><div align="center"> <img src="../pics//ed523051-608f-4c3f-b343-383e2d194470.png"> </div><br><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><p>（二）单个资源的银行家算法</p><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><div align="center"> <img src="../pics//d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"> </div><br><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><p>（三）多个资源的银行家算法</p><div align="center"> <img src="../pics//62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"> </div><br><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p><h1 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到一部分不在物理内存中的地址空间时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序称为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><div align="center"> <img src="../pics//7b281b1e-0595-402b-ae35-8c91084c33c1.png"> </div><br><h2 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h2><ul><li>内存管理单元（MMU）：管理着地址空间和物理内存的转换。</li><li>页表（Page table）：页（地址空间）和页框（物理内存空间）的映射表。例如下图中，页表的第 0 个表项为 010，表示第 0 个页映射到第 2 个页框。页表项的最后一位用来标记页是否在内存中。</li></ul><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。因此对于虚拟地址（0010 000000000100），前 4 位是用来存储页面号，而后 12 位存储在页中的偏移量。</p><p>（0010 000000000100）根据前 4 位得到页号为 2，读取表项内容为（110 1），它的前 3 为为页框号，最后 1 位表示该页在内存中。最后映射得到物理内存地址为（110 000000000100）。</p><div align="center"> <img src="../pics//cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"> </div><br><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h3 id="1-最佳"><a href="#1-最佳" class="headerlink" title="1. 最佳"></a>1. 最佳</h3><blockquote><p>Optimal</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><div align="center"><img src="https://latex.codecogs.com/gif.latex?7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1"></div> <br><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p><h3 id="2-最近最久未使用"><a href="#2-最近最久未使用" class="headerlink" title="2. 最近最久未使用"></a>2. 最近最久未使用</h3><blockquote><p>LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面时最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><div align="center"><img src="https://latex.codecogs.com/gif.latex?4，7，0，7，1，0，1，2，1，2，6"></div> <br><div align="center"> <img src="../pics//eb859228-c0f2-4bce-910d-d9f76929352b.png"> </div><br><h3 id="3-最近未使用"><a href="#3-最近未使用" class="headerlink" title="3. 最近未使用"></a>3. 最近未使用</h3><blockquote><p>NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h3 id="4-先进先出"><a href="#4-先进先出" class="headerlink" title="4. 先进先出"></a>4. 先进先出</h3><blockquote><p>FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p><h3 id="5-第二次机会算法"><a href="#5-第二次机会算法" class="headerlink" title="5. 第二次机会算法"></a>5. 第二次机会算法</h3><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><div align="center"> <img src="../pics//ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"> </div><br><h3 id="6-时钟"><a href="#6-时钟" class="headerlink" title="6. 时钟"></a>6. 时钟</h3><blockquote><p>Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面链接起来，再使用一个指针指向最老的页面。</p><div align="center"> <img src="../pics//5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"> </div><br><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><div align="center"> <img src="../pics//22de0538-7c6e-4365-bd3b-8ce3c5900216.png"> </div><br><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><div align="center"> <img src="../pics//e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"> </div><br><h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h2 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h2><ul><li><p>对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。</p></li><li><p>地址空间的维度：分页是一维地址空间，分段是二维的。</p></li><li><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p></li><li><p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p></li></ul><h1 id="五、设备管理"><a href="#五、设备管理" class="headerlink" title="五、设备管理"></a>五、设备管理</h1><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴旋转磁盘，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h3 id="1-先来先服务"><a href="#1-先来先服务" class="headerlink" title="1. 先来先服务"></a>1. 先来先服务</h3><blockquote><p>FCFS, First Come First Served</p></blockquote><p>按照磁盘请求的顺序进行调度。</p><p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h3 id="2-最短寻道时间优先"><a href="#2-最短寻道时间优先" class="headerlink" title="2. 最短寻道时间优先"></a>2. 最短寻道时间优先</h3><blockquote><p>SSTF, Shortest Seek Time First</p></blockquote><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两边的磁道请求更容易出现饥饿现象。</p><div align="center"> <img src="../pics//4e2485e4-34bd-4967-9f02-0c093b797aaa.png"> </div><br><h3 id="3-电梯算法"><a href="#3-电梯算法" class="headerlink" title="3. 电梯算法"></a>3. 电梯算法</h3><blockquote><p>SCAN</p></blockquote><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p><div align="center"> <img src="../pics//271ce08f-c124-475f-b490-be44fedc6d2e.png"> </div><br><h1 id="六、链接"><a href="#六、链接" class="headerlink" title="六、链接"></a>六、链接</h1><h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><p>以下是一个 hello.c 程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure><p>这个过程大致如下：</p><div align="center"> <img src="../pics//b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"> </div><br><ul><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编文件；</li><li>汇编阶段：将汇编文件翻译成可重定向目标文件；</li><li>链接阶段：将可重定向目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li></ul><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态连接器以一组可重定向目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ul><div align="center"> <img src="../pics//47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"> </div><br><h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><ul><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定向目标文件：可与其它可重定向目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：这是一种特殊的可重定向目标文件，可以在运行时被动态加载进内存并链接；</li></ul><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul><div align="center"> <img src="../pics//76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"> </div><br><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014.</li><li>汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001.</li><li>Bryant, R. E., &amp; O’Hallaron, D. R. (2004). 深入理解计算机系统.</li><li><a href="https://applied-programming.github.io/Operating-Systems-Notes/" target="_blank" rel="noopener">Operating System Notes</a></li><li><a href="http://blog.csdn.net/yufaw/article/details/7409596" target="_blank" rel="noopener">进程间的几种通信方式</a></li><li><a href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/2_Structures.html" target="_blank" rel="noopener">Operating-System Structures</a></li><li><a href="http://cse.csusb.edu/tongyu/courses/cs460/notes/process.php" target="_blank" rel="noopener">Processes</a></li><li><a href="https://www.slideshare.net/rkolahalam/inter-process-communication-presentation1" target="_blank" rel="noopener">Inter Process Communication Presentation[1]</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一概述&quot;&gt;一、概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#操作系统基本特征&quot;&gt;操作系统基本特征&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#操作系统基本功能&quot;&gt;操作系统基本功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#系统调用&quot;&gt;系统调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#大内核和微内核&quot;&gt;大内核和微内核&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#中断分类&quot;&gt;中断分类&lt;/a&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统原理</title>
    <link href="http://yoursite.com/2019/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/11/数据库系统原理/</id>
    <published>2019-09-11T02:03:12.000Z</published>
    <updated>2019-09-11T02:04:56.063Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#一事务">一、事务</a><ul><li><a href="#概念">概念</a></li><li><a href="#acid">ACID</a></li><li><a href="#autocommit">AUTOCOMMIT</a></li></ul></li><li><a href="#二并发一致性问题">二、并发一致性问题</a><ul><li><a href="#丢失修改">丢失修改</a></li><li><a href="#读脏数据">读脏数据</a></li><li><a href="#不可重复读">不可重复读</a></li><li><a href="#幻影读">幻影读</a><a id="more"></a></li></ul></li><li><a href="#三封锁">三、封锁</a><ul><li><a href="#封锁粒度">封锁粒度</a></li><li><a href="#封锁类型">封锁类型</a></li><li><a href="#封锁协议">封锁协议</a></li><li><a href="#mysql-隐式与显示锁定">MySQL 隐式与显示锁定</a></li></ul></li><li><a href="#四隔离级别">四、隔离级别</a><ul><li><a href="#未提交读read-uncommitted">未提交读（READ UNCOMMITTED）</a></li><li><a href="#提交读read-committed">提交读（READ COMMITTED）</a></li><li><a href="#可重复读repeatable-read">可重复读（REPEATABLE READ）</a></li><li><a href="#可串行化serializable">可串行化（SERIALIZABLE）</a></li></ul></li><li><a href="#五多版本并发控制">五、多版本并发控制</a><ul><li><a href="#版本号">版本号</a></li><li><a href="#undo-日志">Undo 日志</a></li><li><a href="#实现过程">实现过程</a></li><li><a href="#快照读与当前读">快照读与当前读</a></li></ul></li><li><a href="#六next-key-locks">六、Next-Key Locks</a><ul><li><a href="#record-locks">Record Locks</a></li><li><a href="#gap-locks">Gap Locks</a></li><li><a href="#next-key-locks">Next-Key Locks</a></li></ul></li><li><a href="#七关系数据库设计理论">七、关系数据库设计理论</a><ul><li><a href="#函数依赖">函数依赖</a></li><li><a href="#异常">异常</a></li><li><a href="#范式">范式</a></li></ul></li><li><a href="#八er-图">八、ER 图</a><ul><li><a href="#实体的三种联系">实体的三种联系</a></li><li><a href="#表示出现多次的关系">表示出现多次的关系</a></li><li><a href="#联系的多向性">联系的多向性</a></li><li><a href="#表示子类">表示子类</a></li></ul></li><li><a href="#参考资料">参考资料</a><h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1></li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><div align="center"> <img src="../pics//185b9c49-4c13-4241-a848-fbff85c03a64.png" width="400"> </div><br><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。</p><p>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</p><hr><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时要只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库崩溃的情况。</li></ul><div align="center"> <img src="../pics//a58e294a-615d-4ea0-9fbf-064a6daec4b2.png" width="400"> </div><br><h2 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><p>T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p><div align="center"> <img src="../pics//88ff46b3-028a-4dbb-a572-1f062b8b96d3.png" width="300"> </div><br><h2 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h2><p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p><div align="center"> <img src="../pics//dd782132-d830-4c55-9884-cfac0a541b8e.png" width="300"> </div><br><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><div align="center"> <img src="../pics//c8d18ca9-0b09-441a-9a0c-fb063630d708.png" width="300"> </div><br><h2 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h2><p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><div align="center"> <img src="../pics//72fe492e-f1cb-4cfc-92f8-412fb3ae6fec.png" width="300"> </div><br><hr><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><div align="center"> <img src="../pics//1a851e90-0d5c-4d4f-ac54-34c20ecfb903.jpg" width="300"> </div><br><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><h3 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1. 读写锁"></a>1. 读写锁</h3><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定：</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ul><p>锁的兼容关系如下：</p><table><thead><tr><th align="center">-</th><th align="center">X</th><th align="center">S</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">NO</td><td align="center">NO</td></tr><tr><td align="center">S</td><td align="center">NO</td><td align="center">YES</td></tr></tbody></table><h3 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2. 意向锁"></a>2. 意向锁</h3><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>各种锁的兼容关系如下：</p><table><thead><tr><th align="center">-</th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">NO</td><td align="center">NO</td><td align="center">NO</td><td align="center">NO</td></tr><tr><td align="center">IX</td><td align="center">NO</td><td align="center">YES</td><td align="center">NO</td><td align="center">YES</td></tr><tr><td align="center">S</td><td align="center">NO</td><td align="center">NO</td><td align="center">YES</td><td align="center">YES</td></tr><tr><td align="center">IS</td><td align="center">NO</td><td align="center">YES</td><td align="center">YES</td><td align="center">YES</td></tr></tbody></table><p>解释如下：</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li><li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li></ul><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1. 三级封锁协议"></a>1. 三级封锁协议</h3><p><strong>一级封锁协议</strong> </p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><table><thead><tr><th align="center">T<sub>1</sub></th><th align="center">T<sub>2</sub></th></tr></thead><tbody><tr><td align="center">lock-x(A)</td><td align="center"></td></tr><tr><td align="center">read A=20</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">lock-x(A)</td></tr><tr><td align="center"></td><td align="center">wait</td></tr><tr><td align="center">write A=19</td><td align="center">.</td></tr><tr><td align="center">commit</td><td align="center">.</td></tr><tr><td align="center">unlock-x(A)</td><td align="center">.</td></tr><tr><td align="center"></td><td align="center">obtain</td></tr><tr><td align="center"></td><td align="center">read A=19</td></tr><tr><td align="center"></td><td align="center">write A=21</td></tr><tr><td align="center"></td><td align="center">commit</td></tr><tr><td align="center"></td><td align="center">unlock-x(A)</td></tr></tbody></table><p><strong>二级封锁协议</strong> </p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><table><thead><tr><th align="center">T<sub>1</sub></th><th align="center">T<sub>2</sub></th></tr></thead><tbody><tr><td align="center">lock-x(A)</td><td align="center"></td></tr><tr><td align="center">read A=20</td><td align="center"></td></tr><tr><td align="center">write A=19</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">lock-s(A)</td></tr><tr><td align="center"></td><td align="center">wait</td></tr><tr><td align="center">rollback</td><td align="center">.</td></tr><tr><td align="center">A=20</td><td align="center">.</td></tr><tr><td align="center">unlock-x(A)</td><td align="center">.</td></tr><tr><td align="center"></td><td align="center">obtain</td></tr><tr><td align="center"></td><td align="center">read A=20</td></tr><tr><td align="center"></td><td align="center">commit</td></tr><tr><td align="center"></td><td align="center">unlock-s(A)</td></tr></tbody></table><p><strong>三级封锁协议</strong> </p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><table><thead><tr><th align="center">T<sub>1</sub></th><th align="center">T<sub>2</sub></th></tr></thead><tbody><tr><td align="center">lock-s(A)</td><td align="center"></td></tr><tr><td align="center">read A=20</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">lock-x(A)</td></tr><tr><td align="center"></td><td align="center">wait</td></tr><tr><td align="center">read A=20</td><td align="center">.</td></tr><tr><td align="center">commit</td><td align="center">.</td></tr><tr><td align="center">unlock-s(A)</td><td align="center">.</td></tr><tr><td align="center"></td><td align="center">obtain</td></tr><tr><td align="center"></td><td align="center">read A=20</td></tr><tr><td align="center"></td><td align="center">write A=19</td></tr><tr><td align="center"></td><td align="center">commit</td></tr><tr><td align="center"></td><td align="center">unlock-X(A)</td></tr></tbody></table><h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure><h2 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><h2 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h2><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h2 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h2><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h2 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h2><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><h2 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h2><p>强制事务串行执行。</p><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">未提交读</td><td align="center">YES</td><td align="center">YES</td><td align="center">YES</td></tr><tr><td align="center">提交读</td><td align="center">NO</td><td align="center">YES</td><td align="center">YES</td></tr><tr><td align="center">可重复读</td><td align="center">NO</td><td align="center">NO</td><td align="center">YES</td></tr><tr><td align="center">可串行化</td><td align="center">NO</td><td align="center">NO</td><td align="center">NO</td></tr></tbody></table><h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC；可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ul><li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号：事务开始时的系统版本号。</li></ul><p>InooDB 的 MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p><ul><li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul><h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>InnoDB 的 MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p><div align="center"> <img src="../pics//e41405a8-7c05-4f70-8092-e961e28d3112.jpg" width> </div><br><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>以下实现过程针对可重复读隔离级别。</p><h3 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1. SELECT"></a>1. SELECT</h3><p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p><p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。</p><p>除了上面的要求，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><h3 id="2-INSERT"><a href="#2-INSERT" class="headerlink" title="2. INSERT"></a>2. INSERT</h3><p>将当前系统版本号作为数据行快照的创建版本号。</p><h3 id="3-DELETE"><a href="#3-DELETE" class="headerlink" title="3. DELETE"></a>3. DELETE</h3><p>将当前系统版本号作为数据行快照的删除版本号。</p><h3 id="4-UPDATE"><a href="#4-UPDATE" class="headerlink" title="4. UPDATE"></a>4. UPDATE</h3><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><h3 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h3><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure><h3 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h3><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line"><span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks 也是 MySQL 的 InnoDB 存储引擎的一种锁实现。MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><h2 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h2><p>锁定整个记录（行）。锁定的对象是记录的索引，而不是记录本身。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚集索引，因此 Record Locks 依然可以使用。</p><h2 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h2><p>锁定一个范围内的索引，例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录，也锁定范围内的索引。在 user 中有以下记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|   id | last_name   | first_name   |   age |</span><br><span class="line">|<span class="comment">------|-------------|--------------|-------|</span></span><br><span class="line">|    4 | stark       | tony         |    21 |</span><br><span class="line">|    1 | tom         | hiddleston   |    30 |</span><br><span class="line">|    3 | morgan      | freeman      |    40 |</span><br><span class="line">|    5 | jeff        | dean         |    50 |</span><br><span class="line">|    2 | donald      | trump        |    80 |</span><br><span class="line">+<span class="comment">------|-------------|--------------|-------+</span></span><br></pre></td></tr></table></figure><p>那么就需要锁定以下范围：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 21]</span><br><span class="line">(21, 30]</span><br><span class="line">(30, 40]</span><br><span class="line">(40, 50]</span><br><span class="line">(50, 80]</span><br><span class="line">(80, ∞)</span><br></pre></td></tr></table></figure><h1 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖；</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th><th align="center">Mname</th><th align="center">Cname</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生-1</td><td align="center">学院-1</td><td align="center">院长-1</td><td align="center">课程-1</td><td align="center">90</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-2</td><td align="center">80</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-1</td><td align="center">100</td></tr><tr><td align="center">3</td><td align="center">学生-3</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-2</td><td align="center">95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 学生-2 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如如果删除了 课程-1，需要删除第一行和第三行，那么 学生-1 的信息就会丢失。</li><li>插入异常，例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><div align="center"> <img src="../pics//c2d343f7-604c-4856-9a3c-c71d6f67fecc.png" width="300"> </div><br><h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>属性不可分；</p><h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p><font size="4"> <strong>分解前</strong> </font><br></p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th><th align="center">Mname</th><th align="center">Cname</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生-1</td><td align="center">学院-1</td><td align="center">院长-1</td><td align="center">课程-1</td><td align="center">90</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-2</td><td align="center">80</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-1</td><td align="center">100</td></tr><tr><td align="center">3</td><td align="center">学生-3</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-2</td><td align="center">95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><font size="4"> <strong>分解后</strong> </font><br></p><p>关系-1</p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th><th align="center">Mname</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生-1</td><td align="center">学院-1</td><td align="center">院长-1</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td></tr><tr><td align="center">3</td><td align="center">学生-3</td><td align="center">学院-2</td><td align="center">院长-2</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table><thead><tr><th align="center">Sno</th><th align="center">Cname</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">课程-1</td><td align="center">90</td></tr><tr><td align="center">2</td><td align="center">课程-2</td><td align="center">80</td></tr><tr><td align="center">2</td><td align="center">课程-1</td><td align="center">100</td></tr><tr><td align="center">3</td><td align="center">课程-2</td><td align="center">95</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt;  Grade</li></ul><h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p><p>上面的 关系-1 中存在以下传递函数依赖：Sno -&gt; Sdept -&gt; Mname，可以进行以下分解：</p><p>关系-11</p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生-1</td><td align="center">学院-1</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td></tr><tr><td align="center">3</td><td align="center">学生-3</td><td align="center">学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th align="center">Sdept</th><th align="center">Mname</th></tr></thead><tbody><tr><td align="center">学院-1</td><td align="center">院长-1</td></tr><tr><td align="center">学院-2</td><td align="center">院长-2</td></tr></tbody></table><h1 id="八、ER-图"><a href="#八、ER-图" class="headerlink" title="八、ER 图"></a>八、ER 图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h2 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h2><p>包含一对一，一对多，多对多三种。</p><p>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；如果是一对一，画两个带箭头的线段；如果是多对多，画两个不带箭头的线段。下图的 Course 和 Student 是一对多的关系。</p><div align="center"> <img src="../pics//292b4a35-4507-4256-84ff-c218f108ee31.jpg" width> </div><br><h2 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><div align="center"> <img src="../pics//8b798007-e0fb-420c-b981-ead215692417.jpg" width> </div><br><h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><div align="center"> <img src="../pics//423f2a40-bee1-488e-b460-8e76c48ee560.png" width> </div><br><p>一般只使用二元联系，可以把多元关系转换为二元关系。</p><div align="center"> <img src="../pics//de9b9ea0-1327-4865-93e5-6f805c48bc9e.png" width> </div><br><h2 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><div align="center"> <img src="../pics//7ec9d619-fa60-4a2b-95aa-bf1a62aad408.jpg" width> </div><br><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.</li><li>施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.</li><li>史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.</li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">The InnoDB Storage Engine</a></li><li><a href="https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels" target="_blank" rel="noopener">Transaction isolation levels</a></li><li><a href="http://scanftree.com/dbms/2-phase-locking-protocol" target="_blank" rel="noopener">Concurrency Control</a></li><li><a href="https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666" target="_blank" rel="noopener">The Nightmare of Locking, Blocking and Isolation Levels!</a></li><li><a href="https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html" target="_blank" rel="noopener">Database Normalization and Normal Forms with an Example</a></li><li><a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/" target="_blank" rel="noopener">The basics of the InnoDB undo logging and history system</a></li><li><a href="https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/" target="_blank" rel="noopener">MySQL locking for the busy web developer</a></li><li><a href="https://draveness.me/mysql-innodb" target="_blank" rel="noopener">浅入浅出 MySQL 和 InnoDB</a></li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="noopener">Innodb 中的事务隔离级别和锁的关系</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一事务&quot;&gt;一、事务&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概念&quot;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#acid&quot;&gt;ACID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#autocommit&quot;&gt;AUTOCOMMIT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二并发一致性问题&quot;&gt;二、并发一致性问题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#丢失修改&quot;&gt;丢失修改&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#读脏数据&quot;&gt;读脏数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#不可重复读&quot;&gt;不可重复读&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#幻影读&quot;&gt;幻影读&lt;/a&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库原理" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>代码可读性</title>
    <link href="http://yoursite.com/2019/09/11/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
    <id>http://yoursite.com/2019/09/11/代码可读性/</id>
    <published>2019-09-11T01:59:35.000Z</published>
    <updated>2019-09-11T02:10:23.214Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#一可读性的重要性">一、可读性的重要性</a></li><li><a href="#二用名字表达代码含义">二、用名字表达代码含义</a></li><li><a href="#三名字不能带来歧义">三、名字不能带来歧义</a></li><li><a href="#四良好的代码风格">四、良好的代码风格</a></li><li><a href="#五为何编写注释">五、为何编写注释</a><a id="more"></a></li><li><a href="#六如何编写注释">六、如何编写注释</a></li><li><a href="#七提高控制流的可读性">七、提高控制流的可读性</a></li><li><a href="#八拆分长表达式">八、拆分长表达式</a></li><li><a href="#九变量与可读性">九、变量与可读性</a></li><li><a href="#十抽取函数">十、抽取函数</a></li><li><a href="#十一一次只做一件事">十一、一次只做一件事</a></li><li><a href="#十二用自然语言表述代码">十二、用自然语言表述代码</a></li><li><a href="#十三减少代码量">十三、减少代码量</a></li><li><a href="#参考资料">参考资料</a><h1 id="一、可读性的重要性"><a href="#一、可读性的重要性" class="headerlink" title="一、可读性的重要性"></a>一、可读性的重要性</h1>编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。<br>可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。<br>只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。<h1 id="二、用名字表达代码含义"><a href="#二、用名字表达代码含义" class="headerlink" title="二、用名字表达代码含义"></a>二、用名字表达代码含义</h1>一些比较有表达力的单词：</li></ul><table><thead><tr><th align="center">单词</th><th>可替代单词</th></tr></thead><tbody><tr><td align="center">send</td><td>deliver、dispatch、announce、distribute、route</td></tr><tr><td align="center">find</td><td>search、extract、locate、recover</td></tr><tr><td align="center">start</td><td>launch、create、begin、open</td></tr><tr><td align="center">make</td><td>create、set up、build、generate、compose、add、new</td></tr></tbody></table><p>使用 i、j、k 作为循环迭代器的名字过于简单，user_i、member_i 这种名字会更有表达力。因为循环层次越多，代码越难理解，有表达力的迭代器名字可读性会更高。</p><p>为名字添加形容词等信息能让名字更具有表达力，但是名字也会变长。名字长短的准则是：作用域越大，名字越长。因此只有在短作用域才能使用一些简单名字。</p><h1 id="三、名字不能带来歧义"><a href="#三、名字不能带来歧义" class="headerlink" title="三、名字不能带来歧义"></a>三、名字不能带来歧义</h1><p>起完名字要思考一下别人会对这个名字有何解读，会不会误解了原本想表达的含义。</p><p>布尔相关的命名加上 is、can、should、has 等前缀。</p><ul><li>用 min、max 表示数量范围；</li><li>用 first、last 表示访问空间的包含范围；</li><li>begin、end 表示访问空间的排除范围，即 end 不包含尾部。</li></ul><div align="center"> <img src="../pics//05907ab4-42c5-4b5e-9388-6617f6c97bea.jpg"> </div><br><h1 id="四、良好的代码风格"><a href="#四、良好的代码风格" class="headerlink" title="四、良好的代码风格"></a>四、良好的代码风格</h1><p>适当的空行和缩进。</p><p>排列整齐的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;   <span class="comment">// 注释</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">11</span>;  <span class="comment">// 注释</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">111</span>; <span class="comment">// 注释</span></span><br></pre></td></tr></table></figure><p>语句顺序不能随意，比如与 html 表单相关联的变量的赋值应该和表单在 html 中的顺序一致。</p><h1 id="五、为何编写注释"><a href="#五、为何编写注释" class="headerlink" title="五、为何编写注释"></a>五、为何编写注释</h1><p>阅读代码首先会注意到注释，如果注释没太大作用，那么就会浪费代码阅读的时间。那些能直接看出含义的代码不需要写注释，特别是并不需要为每个方法都加上注释，比如那些简单的 getter 和 setter 方法，为这些方法写注释反而让代码可读性更差。</p><p>不能因为有注释就随便起个名字，而是争取起个好名字而不写注释。</p><p>可以用注释来记录采用当前解决办法的思考过程，从而让读者更容易理解代码。</p><p>注释用来提醒一些特殊情况。</p><p>用 TODO 等做标记：</p><table><thead><tr><th>标记</th><th>用法</th></tr></thead><tbody><tr><td>TODO</td><td>待做</td></tr><tr><td>FIXME</td><td>待修复</td></tr><tr><td>HACK</td><td>粗糙的解决方案</td></tr><tr><td>XXX</td><td>危险！这里有重要的问题</td></tr></tbody></table><h1 id="六、如何编写注释"><a href="#六、如何编写注释" class="headerlink" title="六、如何编写注释"></a>六、如何编写注释</h1><p>尽量简洁明了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The first String is student's name</span></span><br><span class="line"><span class="comment">// The Second Integer is student's score</span></span><br><span class="line">Map&lt;String, Integer&gt; scoreMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student's name -&gt; Student's score</span></span><br><span class="line">Map&lt;String, Integer&gt; scoreMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>添加测试用例来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Example: add(1, 2), return 3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用专业名词来缩短概念上的解释，比如用设计模式名来说明代码。</p><h1 id="七、提高控制流的可读性"><a href="#七、提高控制流的可读性" class="headerlink" title="七、提高控制流的可读性"></a>七、提高控制流的可读性</h1><p>条件表达式中，左侧是变量，右侧是常数。比如下面第一个语句正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="number">10</span> &gt; len)</span><br></pre></td></tr></table></figure><p>只有在逻辑简单的情况下使用 ? : 三目运算符来使代码更紧凑，否则应该拆分成 if / else；</p><p>do / while 的条件放在后面，不够简单明了，并且会有一些迷惑的地方，最好使用 while 来代替。</p><p>如果只有一个 goto 目标，那么 goto 尚且还能接受，但是过于复杂的 goto 会让代码可读性特别差，应该避免使用 goto。</p><p>在嵌套的循环中，用一些 return 语句往往能减少嵌套的层数。</p><h1 id="八、拆分长表达式"><a href="#八、拆分长表达式" class="headerlink" title="八、拆分长表达式"></a>八、拆分长表达式</h1><p>长表达式的可读性很差，可以引入一些解释变量从而拆分表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> line.split(<span class="string">':'</span>)[<span class="number">0</span>].strip() == <span class="string">"root"</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username = line.split(<span class="string">':'</span>)[<span class="number">0</span>].strip()</span><br><span class="line"><span class="keyword">if</span> username == <span class="string">"root"</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>使用摩根定理简化一些逻辑表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!a &amp;&amp; !b) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(a || b)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九、变量与可读性"><a href="#九、变量与可读性" class="headerlink" title="九、变量与可读性"></a>九、变量与可读性</h1><p><strong>去除控制流变量</strong> 。在循环中通过使用 break 或者 return 可以减少控制流变量的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/* condition */</span> &amp;&amp; !done) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ( ... ) &#123;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="comment">/* condition */</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ( ... ) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>减小变量作用域</strong> 。作用域越小，越容易定位到变量所有使用的地方。</p><p>JavaScript 可以用闭包减小作用域。以下代码中 submit_form 是函数变量，submitted 变量控制函数不会被提交两次。第一个实现中 submitted 是全局变量，第二个实现把 submitted 放到匿名函数中，从而限制了起作用域范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">submitted = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> submit_form = <span class="function"><span class="keyword">function</span>(<span class="params">form_name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    submitted = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> submit_form = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> submitted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">form_name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(submitted) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        submitted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());  <span class="comment">// () 使得外层匿名函数立即执行</span></span><br></pre></td></tr></table></figure><p>JavaScript 中没有用 var 声明的变量都是全局变量，而全局变量很容易造成迷惑，因此应当总是用 var 来声明变量。</p><p>变量定义的位置应当离它使用的位置最近。</p><p><strong>实例解析</strong> </p><p>在一个网页中有以下文本输入字段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"input1"</span> <span class="attr">value</span> = <span class="string">"a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"input2"</span> <span class="attr">value</span> = <span class="string">"b"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"input3"</span> <span class="attr">value</span> = <span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"input4"</span> <span class="attr">value</span> = <span class="string">"d"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在要接受一个字符串并把它放到第一个空的 input 字段中，初始实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setFirstEmptyInput = <span class="function"><span class="keyword">function</span>(<span class="params">new_alue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span> + i);</span><br><span class="line">    <span class="keyword">while</span> (elem != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem.value === <span class="string">''</span>) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        elem = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found) elem.value = new_value;</span><br><span class="line">    <span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现有以下问题：</p><ul><li>found 可以去除；</li><li>elem 作用域过大；</li><li>可以用 for 循环代替 while 循环；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setFirstEmptyInput = <span class="function"><span class="keyword">function</span>(<span class="params">new_value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span> + i);</span><br><span class="line">        <span class="keyword">if</span> (elem === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (elem.value === <span class="string">''</span>) &#123;</span><br><span class="line">            elem.value = new_value;</span><br><span class="line">            <span class="keyword">return</span> elem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="十、抽取函数"><a href="#十、抽取函数" class="headerlink" title="十、抽取函数"></a>十、抽取函数</h1><p>工程学就是把大问题拆分成小问题再把这些问题的解决方案放回一起。</p><p>首先应该明确一个函数的高层次目标，然后对于不是直接为了这个目标工作的代码，抽取出来放到独立的函数中。</p><p>介绍性的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findClostElement</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clostIdx;</span><br><span class="line">    <span class="keyword">int</span> clostDist = Interger.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = ...;</span><br><span class="line">        <span class="keyword">int</span> y = ...;</span><br><span class="line">        <span class="keyword">int</span> z = ...;</span><br><span class="line">        <span class="keyword">int</span> value = x * y * z;</span><br><span class="line">        <span class="keyword">int</span> dist = Math.sqrt(Math.pow(value, <span class="number">2</span>), Math.pow(arr[i], <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; clostDist) &#123;</span><br><span class="line">            clostIdx = i;</span><br><span class="line">            clostDist = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clostIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中循环部分主要计算距离，这部分不属于代码高层次目标，高层次目标是寻找最小距离的值，因此可以把这部分代替提取到独立的函数中。这样做也带来一个额外的好处有：可以单独进行测试、可以快速找到程序错误并修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findClostElement</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clostIdx;</span><br><span class="line">    <span class="keyword">int</span> clostDist = Interger.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> dist = computDist(arr, i);</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; clostDist) &#123;</span><br><span class="line">            clostIdx = i;</span><br><span class="line">            clostDist = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clostIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是函数抽取的越多越好，如果抽取过多，在阅读代码的时候可能需要不断跳来跳去。只有在当前函数不需要去了解某一块代码细节而能够表达其内容时，把这块代码抽取成子函数才是好的。</p><p>函数抽取也用于减小代码的冗余。</p><h1 id="十一、一次只做一件事"><a href="#十一、一次只做一件事" class="headerlink" title="十一、一次只做一件事"></a>十一、一次只做一件事</h1><p>只做一件事的代码很容易让人知道其要做的事；</p><p>基本流程：列出代码所做的所有任务；把每个任务拆分到不同的函数，或者不同的段落。</p><h1 id="十二、用自然语言表述代码"><a href="#十二、用自然语言表述代码" class="headerlink" title="十二、用自然语言表述代码"></a>十二、用自然语言表述代码</h1><p>先用自然语言书写代码逻辑，也就是伪代码，然后再写代码，这样代码逻辑会更清晰。</p><h1 id="十三、减少代码量"><a href="#十三、减少代码量" class="headerlink" title="十三、减少代码量"></a>十三、减少代码量</h1><p>不要过度设计，编码过程会有很多变化，过度设计的内容到最后往往是无用的。</p><p>多用标准库实现。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Dustin, Boswell, Trevor, 等. 编写可读代码的艺术 [M]. 机械工业出版社, 2012.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一可读性的重要性&quot;&gt;一、可读性的重要性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二用名字表达代码含义&quot;&gt;二、用名字表达代码含义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三名字不能带来歧义&quot;&gt;三、名字不能带来歧义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#四良好的代码风格&quot;&gt;四、良好的代码风格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#五为何编写注释&quot;&gt;五、为何编写注释&lt;/a&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="代码规范" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>算法复杂度</title>
    <link href="http://yoursite.com/2019/09/11/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://yoursite.com/2019/09/11/算法复杂度/</id>
    <published>2019-09-11T01:56:34.000Z</published>
    <updated>2019-09-11T01:58:11.970Z</updated>
    
    <content type="html"><![CDATA[<p>人总是贪婪的，在做一件事的时候，我们总是期望着可以付出最少的时间、精力或者金钱来获得最大的回报，这个类比到算法上也同样适用，那就是花最少的时间和最少的存储做成最棒的解决办法，所以好的算法应该具备时效高和存储低的特点。这里的「时效」是指时间效率，也就是算法的执行时间，对于同一个问题的多种不同解决算法，执行时间越短的算法效率越高，越长的效率越低；「存储」是指算法在执行的时候需要的存储空间，主要是指算法程序运行的时候所占用的内存空间。</p><a id="more"></a><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>首先我们先来说时间效率的这个问题，这里的时间效率就是指的算法的执行时间，时间的快慢本来就是一个相对的概念，那么到了算法上，我们该用怎样的度量指标去度量一个算法的时间效率（执行时间）呢？  </p><p>刚开始我们想出了一种事后统计方法，我称它为「马后炮式」，顾名思义，就是对于要解决的某个问题，费尽心思想了 n 种解法，提前写好算法程序，然后攒了一堆数据，让它们分别在电脑上跑，跑完了然后比较程序的运行时间，根据这个来判断算法时效的高低。这种的判断技术计算的是我们日常所用的时间，但这并不是一个对我们来说有用的度量指标，因为它还依赖于运行的机器、所用的编程语言、编译器等等等等。相反，我们需要的是一个不依赖于所用机器或者编程语言的度量指标，这种度量指标可以帮助我们判断算法的优劣，并且可以用来比较算法的具体实现。  </p><p>我们的科学家前辈们发现当我们试图去用执行时间作为独立于具体程序或计算机的度量指标去描述一个算法的时候，确定这个算法所需要的步骤数目非常重要。如果我们把算法程序中的每一步看作是一个基本的计量单位，那么一个算法的执行时间就可以看作是解决一个问题所需要的总步骤数。但是由于算法的执行过程又各不相同，所以这个每一步，即这个基本的计量单位怎么去选择又是一个令人头秃的问题。  </p><p>下面我们来看一个简单的求和的函数：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sum</span><span class="params">(n)</span>:</span></span><br><span class="line">          sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">         sum += i</span><br><span class="line">   <span class="keyword">return</span> sum</span><br><span class="line">print(get_sum(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>我们仔细去分析一下上述代码，其实可以发现统计执行求和的赋值语句的次数可能是一个好的基本计数单位，在上面 get_sum 函数中，赋值语句的数量是 1 （sum = 0）加上 n （执行 sum += i 的次数）。  </p><p>我们一般用一个叫 T 的函数来表示赋值语句的总数量，比如上面的例子可以表示成 T(n) = n + 1。这里的 n 一般指的是「数据的规模大小」，所以前面的等式可以理解为「解决一个规模大小为 n，对应 n+1 步操作步数的问题，所需的时间为 T(n)」。  </p><p>对于 n 来说，它可以取 10，100，1000 或者其它更大的数，我们都知道求解大规模的问题所需的时间比求解小规模要多一些，那么我们接下来的目标就很明确了，那就是「寻找程序的运行时间是如何随着问题规模的变化而变化」。  </p><p>我们的科学家前辈们又对这种分析方法进行了更为深远的思考，他们发现有限的操作次数对于 T(n) 的影响，并不如某些占据主要地位的操作部分重要，换句话说就是「当数据的规模越来越大时，T(n) 函数中的某一部分掩盖了其它部分对函数的影响」。最终，这个起主导作用的部分用来对函数进行比较，所以接下来就是我们所熟知的大 O 闪亮登场的时间了。<br><strong>大 O 表示法</strong><br>「数量级」函数用来描述当规模 n 增加时，T(n) 函数中增长最快的部分，这个数量级函数我们一般用「大 O」表示，记做 O(f(n))。它提供了计算过程中实际步数的近似值，函数 f(n) 是原始函数 T(n) 中主导部分的简化表示。  </p><p>在上面的求和函数的那个例子中，T(n) = n + 1，当 n 增大时，常数 1 对于最后的结果来说越来不越没存在感，如果我们需要 T(n) 的近似值的话，我们要做的就是把 1 给忽略掉，直接认为 T(n) 的运行时间就是 O(n)。这里你一定要搞明白，这里不是说 1 对 T(n) 不重要，而是当 n 增到很大时，丢掉 1 所得到的近似值同样很精确。<br>再举个例子，比如有一个算法的 T(n) = 2n^2+ 2n + 1000，当 n 为 10 或者 20 的时候，常数 1000 看起来对 T(n) 起着决定性的作用。但是当 n 为 1000 或者 10000 或者更大呢？n^2 起到了主要的作用。实际上，当 n 非常大时，后面两项对于最终的结果来说已经是无足轻重了。与上面求和函数的例子很相似，当 n 越来越大的时候，我们就可以忽略其它项，只关注用 2n^2 来代表 T(n) 的近似值。同样的是，系数 2 的作用也会随着 n 的增大，作用变得越来越小，从而也可以忽略。我们这时候就会说 T(n) 的数量级 f(n) = n^2，即 O(n^2)。<br><strong>最好情况、最坏情况和平均情况</strong><br>尽管前面的两个例子中没有体现，但是我们还是应该注意到有时候算法的运行时间还取决于「具体数据」而不仅仅是「问题的规模大小」。对于这样的算法，我们把它们的执行情况分为「最优情况」、「最坏情况」和「平均情况」。  </p><p>某个特定的数据集能让算法的执行情况极好，这就是最「最好情况」，而另一个不同的数据会让算法的执行情况变得极差，这就是「最坏情况」。不过在大多数情况下，算法的执行情况都介于这两种极端情况之间，也就是「平均情况」。因此一定要理解好不同情况之间的差别，不要被极端情况给带了节奏。  </p><p>对于「最优情况」，没有什么大的价值，因为它没有提供什么有用信息，反应的只是最乐观最理想的情况，没有参考价值。「平均情况」是对算法的一个全面评价，因为它完整全面的反映了这个算法的性质，但从另一方面来说，这种衡量并没有什么保证，并不是每个运算都能在这种情况内完成。而对于「最坏情况」，它提供了一种保证，这个保证运行时间将不会再坏了，<strong>所以一般我们所算的时间复杂度是最坏情况下的时间复杂度</strong>，这和我们平时做事要考虑到最坏的情况是一个道理。  </p><p>在我们之后的算法学习过程中，会遇到各种各样的数量级函数，下面我给大家列举几种常见的数量级函数：<br><img src="http://ww1.sinaimg.cn/large/005AJQMSly1fwchz8o0raj30u00fzdgq.jpg" alt><br>为了确定这些函数哪些在 T(n) 中占主导地位，就要在 n 增大时对它们进行比较，请看下图（图片来自于 Google 图片）： </p><p>在上图中，我们可以看到当 n 很小时，函数之间不易区分，很难说谁处于主导地位，但是当 n 增大时，我们就能看到很明显的区别，谁是老大一目了然：</p><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n)</p><p>我们下面就来分析几个上述所说的「数量级函数」：<br><img src="http://ww1.sinaimg.cn/large/005AJQMSly1fwchzzk4x4j30of0hcmz3.jpg" alt><br>1.常数函数  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">100</span>  <span class="comment"># 1 次</span></span><br><span class="line">sum  = (<span class="number">1</span> + n) *n / <span class="number">2</span> <span class="comment"># 1 次</span></span><br><span class="line">print(sum) <span class="comment"># 1 次</span></span><br><span class="line">```  </span><br><span class="line">上述算法程序的 f(n) = <span class="number">3</span>，可能有人看到这会说那么时间复杂度就是 O(f(n)) = O(<span class="number">3</span>)，其实这个是错的，这个函数的时间复杂度其实是 O(<span class="number">1</span>)。这个对于初学者来说是很难理解的一种结果，其实你可以把 sum = (<span class="number">1</span> + n) * n / <span class="number">2</span> 多复制几次再来看：  </span><br><span class="line">```python</span><br><span class="line">a = <span class="number">100</span> <span class="comment"># 1 次</span></span><br><span class="line">sum  = (<span class="number">1</span> + n) * n / <span class="number">2</span> <span class="comment"># 1 次</span></span><br><span class="line">sum  = (<span class="number">1</span> + n) * n / <span class="number">2</span> <span class="comment"># 1 次</span></span><br><span class="line">sum  = (<span class="number">1</span> + n) * n / <span class="number">2</span> <span class="comment"># 1 次</span></span><br><span class="line">sum  = (<span class="number">1</span> + n) * n / <span class="number">2</span> <span class="comment"># 1 次</span></span><br><span class="line">sum  = (<span class="number">1</span> + n) * n / <span class="number">2</span> <span class="comment"># 1 次</span></span><br><span class="line">sum  = (<span class="number">1</span> + n) * n / <span class="number">2</span> <span class="comment"># 1 次</span></span><br><span class="line">print(sum) <span class="comment"># 1 次</span></span><br></pre></td></tr></table></figure><p>上述算法的 f(n) = 8，事实上你可以发现无论 n 为多少，上述两段代码就是 运行 3 次和运行 8 次的区别。这种与数据的规模大小 n 无关，执行时间恒定的算法我们就叫它具有 O(1) 的时间复杂度。不管这个常数是多少，我们都记作是 O(1)，而不是 O(3) 或者是 O(8)。<br>2.对数函数  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> cnt &lt; n:</span><br><span class="line">   cnt *= <span class="number">2</span> <span class="comment"># O(1)</span></span><br></pre></td></tr></table></figure><p>上面的算法程序的时间复杂度就是 O(logn)，这个是怎么算出来的呢？其实很简单：上述的代码可以解释成 cnt 乘以多少个 2 以后才能大于等于 n，我们假设个数是 x，也就是求 2^x = n，即 x = log2n，所以这个循环的时间复杂度就是 O(logn)。</p><p>最后呢，我们来看看下面的这个例子，借助这段代码来详细的说一下我们如何对其时间复杂度进行详细的分析：  </p><pre><code class="python">a = <span class="number">1</span>b = <span class="number">2</span>c = <span class="number">3</span><span class="keyword">for</span> i <span class="keyword">in</span> range(n):   <span class="keyword">for</span> j <span class="keyword">in</span> range(n):       x = i * i       y = j * j       z = i * j<span class="keyword">for</span> k <span class="keyword">in</span> range(n):   u = a * k + b   v = c * cd = <span class="number">4</span></code></pre><p>上面的代码没有任何意义，甚至不是一个可运行的代码，我只是用来说明你在以后如何对代码进行执行分析，关于代码本身可不可以运行，就不需要你在这关心了。</p><p>上面的代码其实我们要分的话可以分成 4 部分：第 1 部分是 a，b，c 这 3 个赋值语句，执行次数也就是 3 次；第二部分是 3n^2，因为是循环结构，里面有 x，y，z 这 3 个赋值语句，每个语句执行了 n^2 次；第 3 部分是 2n，因为里面是 2 个赋值语句，每条语句被执行了 n 次；最后第 4 部分是常数 1，只有 d 这么 1 条赋值语句。所以我们得到的 T(n<br>) = 3+3n^2 +2n+1 = 3n^2+2n+4，看到指数项，我们自然的发现是 n^2 做主导，当 n 增大时，后面两项可以忽略掉，所以这个代码片段的数量级就是 O(n^2)。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>  类比于时间复杂度的讨论，一个算法的空间复杂度是指该算法所耗费的存储空间，计算公式计作：S(n) = O(f(n))。其中 n 也为数据的规模，f(n) 在这里指的是 n 所占存储空间的函数。  </p><p>一般情况下，我们的程序在机器上运行时，刨去需要存储程序本身的输入数据等之外，还需要存储对数据操作的「存储单元」。如果输入数据所占空间和算法无关，只取决于问题本身，那么只需要分析算法在实现过程中所占的「辅助单元」即可。如果所需的辅助单元是个常数，那么空间复杂度就是 O(1)。  </p><p>空间复杂度其实在这里更多的是说一下这个概念，因为当今硬件的存储量级比较大，一般不会为了稍微减少一点儿空间复杂度而大动干戈，更多的是去想怎么优化算法的时间复杂度。所以我们在日常写代码的时候就衍生出了用「空间换时间」的做法，并且成为常态。比如我们在求解斐波那契数列数列的时候我们可以直接用公式去递归求，用哪个求哪个，同样也可以先把很多结果都算出来保存起来，然后用到哪个直接调用，这就是典型的用空间换时间的做法，但是你说这两种具体哪个好，伟大的马克思告诉我们「具体问题具体分析」。  </p><h3 id="写在之后"><a href="#写在之后" class="headerlink" title="写在之后"></a>写在之后</h3><p>如果上面的文章你仔细看了的话，你会发现我不是直接上来就告诉你怎么去求时间复杂度，而是从问题的产生，到思考解决的办法，到“马后炮”，再到 T(n)，最后到 O(n)一步一步来的。这样做的原因呢有两个：一是为了让你了解大 O 到底是怎么来的，有时候搞明白了由来，对于你接下来的学习和理解有很大的帮助；二是为了让这个文章看起来不是那么枯燥，我觉得很多时候上来扔给你一堆概念术语，很容易就让人在刚看到它的时候就打起了退堂鼓，循序渐进的来，慢慢引导着更容易接受一些。</p><p>很多人从大学到工作，代码写了不少依然不会估算时间复杂度，我感觉倒不是学不会，而是内心没有重视起来。你可能觉得计算机的更新换代很快，CPU 处理速度的能力越来越棒，没必要在一些小的方面斤斤计较，其实我觉得你是 too young too naive。我们随便来算一个简单的例子：有两台电脑，你的电脑的运算速度是我的电脑的 100 倍，同样一道问题，明明稍微想一想用 O(n) 可以做出来，你偏偏要懒，直接暴力 O(n^2)，那么当 n 的数据稍微增大一些，比如上万上十万，到底谁的运算速度快还用我再告诉你吗？</p><p>所以今后在写算法的时候，请好好学会用时间复杂度估算一下自己的代码，然后想想有没有更有效率的方法去改进它，你只要这样做了，相信慢慢的你的代码会写的越来越好，头会越来越秃。（逃</p><p>最后说一点的是，估算算法的复杂度这件事你不要指望一下子看了一篇文章就想弄懂，这个还是要有意识的多练，比如看到一个程序的时候有意识的估算一下它的复杂度，准备动手写代码的时候也想想有没有更好的优化方法，有意识的练习慢慢就会来了感觉。这篇文章我就用了几个小例子，大概的估算方式就是这样。之后我还会继续写一些关于「数据结构与算法」相关的文章和一些具体的实战题目，都会带大家继续分析它们的时间复杂度，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人总是贪婪的，在做一件事的时候，我们总是期望着可以付出最少的时间、精力或者金钱来获得最大的回报，这个类比到算法上也同样适用，那就是花最少的时间和最少的存储做成最棒的解决办法，所以好的算法应该具备时效高和存储低的特点。这里的「时效」是指时间效率，也就是算法的执行时间，对于同一个问题的多种不同解决算法，执行时间越短的算法效率越高，越长的效率越低；「存储」是指算法在执行的时候需要的存储空间，主要是指算法程序运行的时候所占用的内存空间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL进阶</title>
    <link href="http://yoursite.com/2019/09/11/SQL%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2019/09/11/SQL进阶/</id>
    <published>2019-09-11T01:52:59.000Z</published>
    <updated>2019-09-11T01:54:21.153Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#一基础">一、基础</a></li><li><a href="#二创建表">二、创建表</a></li><li><a href="#三修改表">三、修改表</a></li><li><a href="#四插入">四、插入</a></li><li><a href="#五更新">五、更新</a><a id="more"></a></li><li><a href="#六删除">六、删除</a></li><li><a href="#七查询">七、查询</a></li><li><a href="#八排序">八、排序</a></li><li><a href="#九过滤">九、过滤</a></li><li><a href="#十通配符">十、通配符</a></li><li><a href="#十一计算字段">十一、计算字段</a></li><li><a href="#十二函数">十二、函数</a></li><li><a href="#十三分组">十三、分组</a></li><li><a href="#十四子查询">十四、子查询</a></li><li><a href="#十五连接">十五、连接</a></li><li><a href="#十六组合查询">十六、组合查询</a></li><li><a href="#十七视图">十七、视图</a></li><li><a href="#十八存储过程">十八、存储过程</a></li><li><a href="#十九游标">十九、游标</a></li><li><a href="#二十触发器">二十、触发器</a></li><li><a href="#二十一事务处理">二十一、事务处理</a></li><li><a href="#二十二字符集">二十二、字符集</a></li><li><a href="#二十三权限管理">二十三、权限管理</a></li><li><a href="#参考资料">参考资料</a><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1></li></ul><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p><p>主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。</p><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p><p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p><p>SQL 支持以下三种注释：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释1</span></span><br><span class="line"><span class="comment">   注释2 */</span></span><br></pre></td></tr></table></figure><p>数据库创建与使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">USE</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><h1 id="二、创建表"><a href="#二、创建表" class="headerlink" title="二、创建表"></a>二、创建表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  col1 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  col2 <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">NULL</span>,</span><br><span class="line">  col3 <span class="built_in">DATE</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure><h1 id="三、修改表"><a href="#三、修改表" class="headerlink" title="三、修改表"></a>三、修改表</h1><p>添加列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">col</span> <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>删除列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><h1 id="四、插入"><a href="#四、插入" class="headerlink" title="四、插入"></a>四、插入</h1><p>普通插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable(col1, col2)</span><br><span class="line"><span class="keyword">VALUES</span>(val1, val2);</span><br></pre></td></tr></table></figure><p>插入检索出来的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable2;</span><br></pre></td></tr></table></figure><p>将一个表的内容插入到一个新表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newtable <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1 id="五、更新"><a href="#五、更新" class="headerlink" title="五、更新"></a>五、更新</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mytable</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">col</span> = val</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="六、删除"><a href="#六、删除" class="headerlink" title="六、删除"></a>六、删除</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>TRUNCATE TABLE</strong>  可以清空表，也就是删除所有行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p><h1 id="七、查询"><a href="#七、查询" class="headerlink" title="七、查询"></a>七、查询</h1><h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h2 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h2><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>返回前 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>返回第 3 ~ 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><ul><li><strong>ASC</strong> ：升序（默认）</li><li><strong>DESC</strong> ：降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h1 id="九、过滤"><a href="#九、过滤" class="headerlink" title="九、过滤"></a>九、过滤</h1><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>下表显示了 WHERE 子句可用的操作符</p><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&lt;&gt; !=</td><td align="center">不等于</td></tr><tr><td align="center">&lt;= !&gt;</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;= !&lt;</td><td align="center">大于等于</td></tr><tr><td align="center">BETWEEN</td><td align="center">在两个值之间</td></tr><tr><td align="center">IS NULL</td><td align="center">为 NULL 值</td></tr></tbody></table><p>应该注意到，NULL 与 0、空字符串都不同。</p><p><strong>AND 和 OR</strong>  用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong>  操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong>  操作符用于否定一个条件。</p><h1 id="十、通配符"><a href="#十、通配符" class="headerlink" title="十、通配符"></a>十、通配符</h1><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><p><strong>%</strong>  匹配 &gt;=0 个任意字符；</p></li><li><p><strong>_</strong>  匹配 ==1 个任意字符；</p></li><li><p><strong>[ ]</strong>  可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</p></li></ul><p>使用 Like 来进行通配符匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">LIKE</span> <span class="string">'[^AB]%'</span>; <span class="comment">-- 不以 A 和 B 开头的任意文本</span></span><br></pre></td></tr></table></figure><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p><h1 id="十一、计算字段"><a href="#十一、计算字段" class="headerlink" title="十一、计算字段"></a>十一、计算字段</h1><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用  <strong>AS</strong>  来取别名，否则输出的时候字段名为计算表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 * col2 <span class="keyword">AS</span> <span class="keyword">alias</span></span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><p><strong>CONCAT()</strong>  用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">TRIM</span>(col1), <span class="string">'('</span>, <span class="keyword">TRIM</span>(col2), <span class="string">')'</span>) <span class="keyword">AS</span> concat_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1 id="十二、函数"><a href="#十二、函数" class="headerlink" title="十二、函数"></a>十二、函数</h1><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><table><thead><tr><th align="center">函 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">AVG()</td><td align="center">返回某列的平均值</td></tr><tr><td align="center">COUNT()</td><td align="center">返回某列的行数</td></tr><tr><td align="center">MAX()</td><td align="center">返回某列的最大值</td></tr><tr><td align="center">MIN()</td><td align="center">返回某列的最小值</td></tr><tr><td align="center">SUM()</td><td align="center">返回某列值之和</td></tr></tbody></table><p>AVG() 会忽略 NULL 行。</p><p>使用 DISTINCT 可以让汇总函数值汇总不同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">LEFT()</td><td align="center">左边的字符</td></tr><tr><td align="center">RIGHT()</td><td align="center">右边的字符</td></tr><tr><td align="center">LOWER()</td><td align="center">转换为小写字符</td></tr><tr><td align="center">UPPER()</td><td align="center">转换为大写字符</td></tr><tr><td align="center">LTRIM()</td><td align="center">去除左边的空格</td></tr><tr><td align="center">RTRIM()</td><td align="center">去除右边的空格</td></tr><tr><td align="center">LENGTH()</td><td align="center">长度</td></tr><tr><td align="center">SOUNDEX()</td><td align="center">转换为语音值</td></tr></tbody></table><p>其中， <strong>SOUNDEX()</strong>  可以将一个字符串转换为描述其语音表示的字母数字模式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">SOUNDEX</span>(col1) = <span class="keyword">SOUNDEX</span>(<span class="string">'apple'</span>)</span><br></pre></td></tr></table></figure><h2 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h2><ul><li>日期格式：YYYY-MM-DD</li><li>时间格式：HH:MM:SS</li></ul><table><thead><tr><th align="center">函 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">AddDate()</td><td align="center">增加一个日期（天、周等）</td></tr><tr><td align="center">AddTime()</td><td align="center">增加一个时间（时、分等）</td></tr><tr><td align="center">CurDate()</td><td align="center">返回当前日期</td></tr><tr><td align="center">CurTime()</td><td align="center">返回当前时间</td></tr><tr><td align="center">Date()</td><td align="center">返回日期时间的日期部分</td></tr><tr><td align="center">DateDiff()</td><td align="center">计算两个日期之差</td></tr><tr><td align="center">Date_Add()</td><td align="center">高度灵活的日期运算函数</td></tr><tr><td align="center">Date_Format()</td><td align="center">返回一个格式化的日期或时间串</td></tr><tr><td align="center">Day()</td><td align="center">返回一个日期的天数部分</td></tr><tr><td align="center">DayOfWeek()</td><td align="center">对于一个日期，返回对应的星期几</td></tr><tr><td align="center">Hour()</td><td align="center">返回一个时间的小时部分</td></tr><tr><td align="center">Minute()</td><td align="center">返回一个时间的分钟部分</td></tr><tr><td align="center">Month()</td><td align="center">返回一个日期的月份部分</td></tr><tr><td align="center">Now()</td><td align="center">返回当前日期和时间</td></tr><tr><td align="center">Second()</td><td align="center">返回一个时间的秒部分</td></tr><tr><td align="center">Time()</td><td align="center">返回一个日期时间的时间部分</td></tr><tr><td align="center">Year()</td><td align="center">返回一个日期的年份部分</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NOW();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-4-14 20:25:11</span><br></pre></td></tr></table></figure><h2 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h2><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">SIN()</td><td align="center">正弦</td></tr><tr><td align="center">COS()</td><td align="center">余弦</td></tr><tr><td align="center">TAN()</td><td align="center">正切</td></tr><tr><td align="center">ABS()</td><td align="center">绝对值</td></tr><tr><td align="center">SQRT()</td><td align="center">平方根</td></tr><tr><td align="center">MOD()</td><td align="center">余数</td></tr><tr><td align="center">EXP()</td><td align="center">指数</td></tr><tr><td align="center">PI()</td><td align="center">圆周率</td></tr><tr><td align="center">RAND()</td><td align="center">随机数</td></tr></tbody></table><h1 id="十三、分组"><a href="#十三、分组" class="headerlink" title="十三、分组"></a>十三、分组</h1><p>分组就是把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">num</span> &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>分组规定：</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ul><h1 id="十四、子查询"><a href="#十四、子查询" class="headerlink" title="十四、子查询"></a>十四、子查询</h1><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure><h1 id="十五、连接"><a href="#十五、连接" class="headerlink" title="十五、连接"></a>十五、连接</h1><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key = B.key;</span><br></pre></td></tr></table></figure><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key = B.key;</span><br></pre></td></tr></table></figure><p>在没有条件语句的情况下返回笛卡尔积。</p><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department = (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">"Jim"</span>);</span><br></pre></td></tr></table></figure><p>自连接版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department = e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name = <span class="string">"Jim"</span>;</span><br></pre></td></tr></table></figure><h2 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h2><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B;</span><br></pre></td></tr></table></figure><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure><p>customers 表：</p><table><thead><tr><th align="center">cust_id</th><th align="center">cust_name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td></tr><tr><td align="center">2</td><td align="center">b</td></tr><tr><td align="center">3</td><td align="center">c</td></tr></tbody></table><p>orders 表：</p><table><thead><tr><th align="center">order_id</th><th align="center">cust_id</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">3</td></tr><tr><td align="center">4</td><td align="center">3</td></tr></tbody></table><p>结果：</p><table><thead><tr><th align="center">cust_id</th><th align="center">cust_name</th><th align="center">order_id</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">a</td><td align="center">2</td></tr><tr><td align="center">3</td><td align="center">c</td><td align="center">3</td></tr><tr><td align="center">3</td><td align="center">c</td><td align="center">4</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">Null</td></tr></tbody></table><h1 id="十六、组合查询"><a href="#十六、组合查询" class="headerlink" title="十六、组合查询"></a>十六、组合查询</h1><p>使用  <strong>UNION</strong>  来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> =<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1 id="十七、视图"><a href="#十七、视图" class="headerlink" title="十七、视图"></a>十七、视图</h1><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处：</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(col1, col2) <span class="keyword">AS</span> concat_col, col3*col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 = val;</span><br></pre></td></tr></table></figure><h1 id="十八、存储过程"><a href="#十八、存储过程" class="headerlink" title="十八、存储过程"></a>十八、存储过程</h1><p>存储过程可以看成是对一系列 SQL 操作的批处理；</p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 in、out 和 inout 三种参数。</p><p>给变量赋值都需要用 select into 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure( <span class="keyword">out</span> ret <span class="built_in">int</span> )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> y <span class="built_in">int</span>;</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">sum</span>(col1)</span><br><span class="line">        <span class="keyword">from</span> mytable</span><br><span class="line">        <span class="keyword">into</span> y;</span><br><span class="line">        <span class="keyword">select</span> y*y <span class="keyword">into</span> ret;</span><br><span class="line">    <span class="keyword">end</span> //</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> myprocedure(@ret);</span><br><span class="line"><span class="keyword">select</span> @ret;</span><br></pre></td></tr></table></figure><h1 id="十九、游标"><a href="#十九、游标" class="headerlink" title="十九、游标"></a>十九、游标</h1><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤：</p><ol><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure(<span class="keyword">out</span> ret <span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> done <span class="built_in">boolean</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">        <span class="keyword">select</span> col1 <span class="keyword">from</span> mytable;</span><br><span class="line">        <span class="comment"># 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1</span></span><br><span class="line">        <span class="keyword">declare</span> continue <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">'02000'</span> <span class="keyword">set</span> done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        open mycursor;</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            fetch mycursor into ret;</span><br><span class="line">            <span class="keyword">select</span> ret;</span><br><span class="line">        until done <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line"></span><br><span class="line">        close mycursor;</span><br><span class="line">    <span class="keyword">end</span> //</span><br><span class="line"> delimiter ;</span><br></pre></td></tr></table></figure><h1 id="二十、触发器"><a href="#二十、触发器" class="headerlink" title="二十、触发器"></a>二十、触发器</h1><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p><p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p><p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> mytrigger <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> mytable</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.col <span class="keyword">into</span> @<span class="keyword">result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">result</span>; <span class="comment">-- 获取结果</span></span><br></pre></td></tr></table></figure><p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p><p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改地，而 OLD 是只读的。</p><p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p><h1 id="二十一、事务处理"><a href="#二十一、事务处理" class="headerlink" title="二十一、事务处理"></a>二十一、事务处理</h1><p>基本术语：</p><ul><li>事务（transaction）指一组 SQL 语句；</li><li>回退（rollback）指撤销指定 SQL 语句的过程；</li><li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ul><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p><p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span></span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure><h1 id="二十二、字符集"><a href="#二十二、字符集" class="headerlink" title="二十二、字符集"></a>二十二、字符集</h1><p>基本术语：</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul><p>除了给表指定字符集和校对外，也可以给列指定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(<span class="keyword">col</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> latin <span class="keyword">COLLATE</span> latin1_general_ci )</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure><p>可以在排序、分组时指定校对：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">col</span> <span class="keyword">COLLATE</span> latin1_general_ci;</span><br></pre></td></tr></table></figure><h1 id="二十三、权限管理"><a href="#二十三、权限管理" class="headerlink" title="二十三、权限管理"></a>二十三、权限管理</h1><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><strong>创建账户</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'mypassword'</span>;</span><br></pre></td></tr></table></figure><p>新创建的账户没有任何权限。</p><p><strong>修改账户名</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> myuser <span class="keyword">TO</span> newuser;</span><br></pre></td></tr></table></figure><p><strong>删除账户</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>查看权限</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>授予权限</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure><p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p><p><strong>删除权限</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure><p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><p><strong>更改密码</strong> </p><p>必须使用 Password() 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWROD <span class="keyword">FOR</span> myuser = <span class="keyword">Password</span>(<span class="string">'new_password'</span>);</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一基础&quot;&gt;一、基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二创建表&quot;&gt;二、创建表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三修改表&quot;&gt;三、修改表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#四插入&quot;&gt;四、插入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#五更新&quot;&gt;五、更新&lt;/a&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>GIT入门</title>
    <link href="http://yoursite.com/2019/09/11/GIT%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/09/11/GIT入门/</id>
    <published>2019-09-11T01:46:14.000Z</published>
    <updated>2019-09-11T01:51:47.716Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#学习资料">学习资料</a></li><li><a href="#集中式与分布式">集中式与分布式</a></li><li><a href="#git-的中心服务器">Git 的中心服务器</a></li><li><a href="#git-工作流">Git 工作流</a><a id="more"></a></li><li><a href="#分支实现">分支实现</a></li><li><a href="#冲突">冲突</a></li><li><a href="#fast-forward">Fast forward</a></li><li><a href="#分支管理策略">分支管理策略</a></li><li><a href="#储藏stashing">储藏（Stashing）</a></li><li><a href="#ssh-传输设置">SSH 传输设置</a></li><li><a href="#gitignore-文件">.gitignore 文件</a></li><li><a href="#git-命令一览">Git 命令一览</a><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1></li></ul><ul><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">Git - 简明指南</a></li><li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解 Git</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰 : Git 教程</a></li><li><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">Learn Git Branching</a></li></ul><h1 id="集中式与分布式"><a href="#集中式与分布式" class="headerlink" title="集中式与分布式"></a>集中式与分布式</h1><p>Git 属于分布式版本控制系统，而 SVN 属于集中式。</p><p>集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码。</p><p>集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。</p><p>集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件的会慢的无法让人忍受。而分布式版本控制不需要连网就能工作。</p><p>分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码。</p><h1 id="Git-的中心服务器"><a href="#Git-的中心服务器" class="headerlink" title="Git 的中心服务器"></a>Git 的中心服务器</h1><p>Git 的中心服务器用来交换每个用户的修改。没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。Github 就是一种 Git 中心服务器。</p><h1 id="Git-工作流"><a href="#Git-工作流" class="headerlink" title="Git 工作流"></a>Git 工作流</h1><p><img src="..%5Cpics//a1198642-9159-4d88-8aec-c3b04e7a2563.jpg" alt><br>新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。</p><p>Git 版本库有一个称为 stage 的暂存区，还有自动创建的 master 分支以及指向分支的 HEAD 指针。<br><img src="..%5Cpics//46f66e88-e65a-4ad0-a060-3c63fe22947c.png" alt></p><ul><li>git add files 把文件的修改添加到暂存区</li><li>git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了</li><li>git reset – files 使用当前分支上的修改覆盖暂缓区，用来撤销最后一次 git add files</li><li>git checkout – files 使用暂存区的修改覆盖工作目录，用来撤销本地修改<br><img src="..%5Cpics//17976404-95f5-480e-9cb4-250e6aa1d55f.png" alt></li></ul><p>可以跳过暂存区域直接从分支中取出修改或者直接提交修改到分支中</p><ul><li>git commit -a 直接把所有文件的修改添加到暂缓区然后执行提交</li><li>git checkout HEAD – files 取出最后一次修改，可以用来进行回滚操作</li></ul><h1 id="分支实现"><a href="#分支实现" class="headerlink" title="分支实现"></a>分支实现</h1><p>Git 把每次提交都连成一条时间线。分支使用指针来实现，例如 master 分支指针指向时间线的最后一个节点，也就是最后一次提交。HEAD 指针指向的是当前分支。<br><img src="..%5Cpics//fb546e12-e1fb-4b72-a1fb-8a7f5000dce6.jpg" alt><br>新建分支是新建一个指针指向时间线的最后一个节点，并让 HEAD 指针指向新分支表示新分支成为当前分支。<br><img src="..%5Cpics//bc775758-89ab-4805-9f9c-78b8739cf780.jpg" alt></p><p>每次提交只会让当前分支向前移动，而其它分支不会移动。<br><img src="..%5Cpics//5292faa6-0141-4638-bf0f-bb95b081dcba.jpg" alt></p><p>合并分支也只需要改变指针即可。<br><img src="..%5Cpics//1164a71f-413d-494a-9cc8-679fb6a2613d.jpg" alt></p><h1 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h1><p>当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。<br><img src="..%5Cpics//58e57a21-6b6b-40b6-af85-956dd4e0f55a.jpg" alt></p><p>Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ，======= ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><h1 id="Fast-forward"><a href="#Fast-forward" class="headerlink" title="Fast forward"></a>Fast forward</h1><p>“快进式合并”（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。</p><p>可以在合并时加上 –no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure><p><img src="..%5Cpics//dd78a1fe-1ff3-4bcf-a56f-8c003995beb6.jpg" alt></p><h1 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h1><p>master 分支应该是非常稳定的，只用来发布新版本；</p><p>日常开发在开发分支 dev 上进行。<br><img src="..%5Cpics//245fd2fb-209c-4ad5-bc5e-eb5664966a0e.jpg" alt></p><h1 id="储藏（Stashing）"><a href="#储藏（Stashing）" class="headerlink" title="储藏（Stashing）"></a>储藏（Stashing）</h1><p>在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故。</p><p>可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈上，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state \ &quot;WIP on master: 049d078 added the index file&quot;</span><br><span class="line">HEAD is now at 049d078 added the index file (To restore them type &quot;git stash apply&quot;)</span><br></pre></td></tr></table></figure><p>该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来。</p><h1 id="SSH-传输设置"><a href="#SSH-传输设置" class="headerlink" title="SSH 传输设置"></a>SSH 传输设置</h1><p>Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。<br>如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>然后把公钥 id_rsa.pub 的内容复制到 Github “Account settings” 的 SSH Keys 中。</p><h1 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h1><p>忽略以下文件：</p><ul><li>操作系统自动生成的文件，比如缩略图；</li><li>编译生成的中间文件，比如 Java 编译产生的 .class 文件；</li><li>自己的敏感信息，比如存放口令的配置文件。<br>不需要全部自己编写，可以到 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a> 中进行查询。<h1 id="Git-命令一览"><a href="#Git-命令一览" class="headerlink" title="Git 命令一览"></a>Git 命令一览</h1><img src="../pics//7a29acce-f243-4914-9f00-f2988c528412.jpg" alt><br>比较详细的地址：<a href="http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf" target="_blank" rel="noopener">http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#学习资料&quot;&gt;学习资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#集中式与分布式&quot;&gt;集中式与分布式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#git-的中心服务器&quot;&gt;Git 的中心服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#git-工作流&quot;&gt;Git 工作流&lt;/a&gt;
    
    </summary>
    
    
      <category term="版本控制工具" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统数据集</title>
    <link href="http://yoursite.com/2019/09/11/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://yoursite.com/2019/09/11/推荐系统数据集/</id>
    <published>2019-09-11T01:42:44.000Z</published>
    <updated>2019-09-11T01:44:30.226Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要整理了一些与推荐系统相关的高质量的数据集。整理自Stack Overflow、一些文章、推荐站点和学术实验。<br>其中，大多数数据集都是免费、开放的，但有些不是，需要获得许可或引用作者的工作才能使用。此外，其中也包含<br>一些预处理数据，可用于学术实验。链接和数据集描述。</p><a id="more"></a><h2 id="BOOK"><a href="#BOOK" class="headerlink" title="BOOK"></a>BOOK</h2><p>Book Crossing <a href="http://www2.informatik.uni-freiburg.de/~cziegler/BX/" target="_blank" rel="noopener">下载链接:http://www2.informatik.uni-freiburg.de/~cziegler/BX/</a><br>BookCrossing（BX）数据集由Cai-Nicolas花了的4周（2004年8月/ 9月）从Book-Crossing社区中爬取得到的。  </p><h2 id="电子商务"><a href="#电子商务" class="headerlink" title="电子商务"></a>电子商务</h2><h2 id="Amazon"><a href="#Amazon" class="headerlink" title="Amazon"></a>Amazon</h2><p><a href="http://jmcauley.ucsd.edu/data/amazon/" target="_blank" rel="noopener">下载链接:http://jmcauley.ucsd.edu/data/amazon/</a><br>该数据集包括自1996年5月至2014年7月，来自亚马逊上的1.428亿产品的评论和metadata。</p><h2 id="Retailrocket推荐系统数据集"><a href="#Retailrocket推荐系统数据集" class="headerlink" title="Retailrocket推荐系统数据集"></a>Retailrocket推荐系统数据集</h2><p><a href="https://www.kaggle.com/retailrocket/ecommerce-dataset" target="_blank" rel="noopener">下载链接：https://www.kaggle.com/retailrocket/ecommerce-dataset</a><br>该数据集由三个文件组成：一个行为数据集（events.csv），一个属性数据集（item_properties.сsv）和一个类目树数据集（category_tree.сsv）。该数据来自现实世界的电子商务网站。  </p><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><h2 id="Amazon-Music"><a href="#Amazon-Music" class="headerlink" title="Amazon Music"></a>Amazon Music</h2><p><a href="http://jmcauley.ucsd.edu/data/amazon/" target="_blank" rel="noopener"> 下载链接</a><br>该数字音乐数据集包含来自亚马逊的评论和元数据</p><h2 id="Yahoo-Music"><a href="#Yahoo-Music" class="headerlink" title="Yahoo Music"></a>Yahoo Music</h2><p><a href="https://webscope.sandbox.yahoo.com/catalog.php?datatype=r" target="_blank" rel="noopener"> 下载链接</a><br>该数据集是一个快照，收集了音乐社区对各种音乐艺术家的偏好。</p><h2 id="LastFM（Implicit）"><a href="#LastFM（Implicit）" class="headerlink" title="LastFM（Implicit）"></a>LastFM（Implicit）</h2><p><a href="https://grouplens.org/datasets/hetrec-2011/" target="_blank" rel="noopener"> 下载链接</a><br>该数据集收集了Last.fm网站上2千名用户的社交网络、tagging和music artist listening信息。</p><h2 id="Milion-Song-Dataset"><a href="#Milion-Song-Dataset" class="headerlink" title="Milion Song Dataset"></a>Milion Song Dataset</h2><p><a href="https://labrosa.ee.columbia.edu/millionsong/" target="_blank" rel="noopener"> 下载链接</a><br>Million Song数据集是一个免费的数据集，提供了一百万条当代流行音乐曲目相关的的audio features和metadata。</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><h2 id="MovieLens"><a href="#MovieLens" class="headerlink" title="MovieLens"></a>MovieLens</h2><p><a href="https://grouplens.org/datasets/movielens/" target="_blank" rel="noopener"> 下载链接</a><br>GroupLens Research已经从他们的电影网站收集整理的rating数据集。</p><h2 id="Yahoo-Movies"><a href="#Yahoo-Movies" class="headerlink" title="Yahoo Movies"></a>Yahoo Movies</h2><p><a href="https://webscope.sandbox.yahoo.com/catalog.php?datatype=r" target="_blank" rel="noopener"> 下载链接</a><br>该数据集包含从两个不同来源收集的歌曲的rating数据集。第一个来源是用户在与Yahoo上使用音乐服务是产生的rating数据。</p><h2 id="CiaoDVD"><a href="#CiaoDVD" class="headerlink" title="CiaoDVD"></a>CiaoDVD</h2><p><a href="https://webscope.sandbox.yahoo.com/catalog.php?datatype=r" target="_blank" rel="noopener"> 下载链接</a><br>CiaoDVD是2013年12月从dvd.ciao.co.uk网站上抓取的DVD类别数据集。</p><h2 id="FilmTrust"><a href="#FilmTrust" class="headerlink" title="FilmTrust"></a>FilmTrust</h2><p><a href="https://www.librec.net/datasets.html" target="_blank" rel="noopener"> 下载链接</a><br>FilmTrust是2011年6月从整个FilmTrust网站上抓取的一个小型数据集。</p><h2 id="Netflix"><a href="#Netflix" class="headerlink" title="Netflix"></a>Netflix</h2><p>这是Netflix奖竞赛中使用的官方数据集。<br><a href="http://academictorrents.com/details/9b13183dc4d60676b773c9e2cd6de5e5542cee9a" target="_blank" rel="noopener"> 下载链接</a> </p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>这是一个用户行数据集，包含：user-id，game-title，behavior-name，value。包括“purchase”和“play”数据集。购买了，puchase的值为1，而“play”的值表示用户播放音乐的时长。<br><a href="https://www.kaggle.com/tamber/steam-video-games/data" target="_blank" rel="noopener"> 下载链接</a>    </p><h2 id="Jokes"><a href="#Jokes" class="headerlink" title="Jokes"></a>Jokes</h2><p>该笑话数据集包含来自73,496个用户，关于100个笑话的410万连续rating数据（-10.00到+10.00）<br><a href="http://www.ieor.berkeley.edu/~goldberg/jester-data/" target="_blank" rel="noopener">  下载链接</a>   </p><h2 id="餐饮"><a href="#餐饮" class="headerlink" title="餐饮"></a>餐饮</h2><p>该数据集包含用户与Entree Chicago餐厅推荐系统交互的记录数据。<br><a href="http://archive.ics.uci.edu/ml/datasets/Entree+Chicago+Recommendation+Data" target="_blank" rel="noopener">  下载链接</a>   </p><h2 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h2><p>该数据集包含来自12,294个动漫的73,516个用户的用户偏好数据。每个用户都可以将动画添加到已完成的列表中并为其评分，该数据集把这些评级整理起来。<br><a href="https://www.kaggle.com/CooperUnion/anime-recommendations-database" target="_blank" rel="noopener"> 下载链接</a></p><h2 id="其他数据集"><a href="#其他数据集" class="headerlink" title="其他数据集"></a>其他数据集</h2><p>GroupLens数据集 <a href="https://grouplens.org/datasets/" target="_blank" rel="noopener"> 下载链接</a><br>LibRec数据集 <a href="https://www.librec.net/datasets.html" target="_blank" rel="noopener"> 下载链接</a><br>Yahoo Research数据集 <a href="https://webscope.sandbox.yahoo.com/catalog.php?datatype=r" target="_blank" rel="noopener"> 下载链接</a><br>斯坦福大型网络数据集汇编 <a href="https://snap.stanford.edu/data/" target="_blank" rel="noopener"> 下载链接</a>      </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要整理了一些与推荐系统相关的高质量的数据集。整理自Stack Overflow、一些文章、推荐站点和学术实验。&lt;br&gt;其中，大多数数据集都是免费、开放的，但有些不是，需要获得许可或引用作者的工作才能使用。此外，其中也包含&lt;br&gt;一些预处理数据，可用于学术实验。链接和数据集描述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="个性化推荐系统" scheme="http://yoursite.com/categories/%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="数据集" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>socket入门</title>
    <link href="http://yoursite.com/2019/09/10/socket%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/09/10/socket入门/</id>
    <published>2019-09-10T13:40:27.000Z</published>
    <updated>2019-09-10T13:50:13.433Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#一io-模型">一、I/O 模型</a><ul><li><a href="#阻塞式-io">阻塞式 I/O</a></li><li><a href="#非阻塞式-io">非阻塞式 I/O</a></li><li><a href="#io-复用">I/O 复用</a></li><li><a href="#信号驱动-io">信号驱动 I/O</a></li><li><a href="#异步-io">异步 I/O</a><a id="more"></a></li><li><a href="#同步-io-与异步-io">同步 I/O 与异步 I/O</a></li><li><a href="#五大-io-模型比较">五大 I/O 模型比较</a></li></ul></li><li><a href="#二io-复用">二、I/O 复用</a><ul><li><a href="#select">select</a></li><li><a href="#poll">poll</a></li><li><a href="#比较">比较</a></li><li><a href="#epoll">epoll</a></li><li><a href="#工作模式">工作模式</a></li><li><a href="#应用场景">应用场景</a></li></ul></li><li><a href="#参考资料">参考资料</a></li></ul><h1 id="一、I-O-模型"><a href="#一、I-O-模型" class="headerlink" title="一、I/O 模型"></a>一、I/O 模型</h1><p>一个输入操作通常包括两个阶段：</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p><p>Unix 下有五种 I/O 模型：</p><ul><li>阻塞式 I/O</li><li>非阻塞式 I/O</li><li>I/O 复用（select 和 poll）</li><li>信号驱动式 I/O（SIGIO）</li><li>异步 I/O（AIO）</li></ul><h2 id="阻塞式-I-O"><a href="#阻塞式-I-O" class="headerlink" title="阻塞式 I/O"></a>阻塞式 I/O</h2><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。</p><p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p><p>下图中，recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br></pre></td></tr></table></figure><div align="center"> <img src="../pics//1492928416812_4.png"> </div><br><h2 id="非阻塞式-I-O"><a href="#非阻塞式-I-O" class="headerlink" title="非阻塞式 I/O"></a>非阻塞式 I/O</h2><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p><p>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。</p><div align="center"> <img src="../pics//1492929000361_5.png"> </div><br><h2 id="I-O-复用"><a href="#I-O-复用" class="headerlink" title="I/O 复用"></a>I/O 复用</h2><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。</p><p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p><p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p><div align="center"> <img src="../pics//1492929444818_6.png"> </div><br><h2 id="信号驱动-I-O"><a href="#信号驱动-I-O" class="headerlink" title="信号驱动 I/O"></a>信号驱动 I/O</h2><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p><p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p><div align="center"> <img src="../pics//1492929553651_7.png"> </div><br><h2 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h2><p>进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><div align="center"> <img src="../pics//1492930243286_8.png"> </div><br><h2 id="同步-I-O-与异步-I-O"><a href="#同步-I-O-与异步-I-O" class="headerlink" title="同步 I/O 与异步 I/O"></a>同步 I/O 与异步 I/O</h2><ul><li>同步 I/O：应用进程在调用 recvfrom 操作时会阻塞。</li><li>异步 I/O：不会阻塞。</li></ul><p>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。</p><h2 id="五大-I-O-模型比较"><a href="#五大-I-O-模型比较" class="headerlink" title="五大 I/O 模型比较"></a>五大 I/O 模型比较</h2><p>前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的：将数据从内核复制到应用进程过程中，应用进程会被阻塞。</p><div align="center"> <img src="../pics//1492928105791_3.png"> </div><br><h1 id="二、I-O-复用"><a href="#二、I-O-复用" class="headerlink" title="二、I/O 复用"></a>二、I/O 复用</h1><p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义。</p><p>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</p><p>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">fd_set fd_in, fd_out;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset the sets</span></span><br><span class="line">FD_ZERO( &amp;fd_in );</span><br><span class="line">FD_ZERO( &amp;fd_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock1 for input events</span></span><br><span class="line">FD_SET( sock1, &amp;fd_in );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock2 for output events</span></span><br><span class="line">FD_SET( sock2, &amp;fd_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find out which socket has the largest numeric value as select requires it</span></span><br><span class="line"><span class="keyword">int</span> largest_sock = sock1 &gt; sock2 ? sock1 : sock2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait up to 10 seconds</span></span><br><span class="line">tv.tv_sec = <span class="number">10</span>;</span><br><span class="line">tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the select</span></span><br><span class="line"><span class="keyword">int</span> ret = select( largest_sock + <span class="number">1</span>, &amp;fd_in, &amp;fd_out, <span class="literal">NULL</span>, &amp;tv );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if select actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( FD_ISSET( sock1, &amp;fd_in ) )</span><br><span class="line">        <span class="comment">// input event on sock1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( FD_ISSET( sock2, &amp;fd_out ) )</span><br><span class="line">        <span class="comment">// output event on sock2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>pollfd 使用链表实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The structure for two events</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[2];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock1 for input</span></span><br><span class="line">fds[<span class="number">0</span>].fd = sock1;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock2 for output</span></span><br><span class="line">fds[<span class="number">1</span>].fd = sock2;</span><br><span class="line">fds[<span class="number">1</span>].events = POLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait 10 seconds</span></span><br><span class="line"><span class="keyword">int</span> ret = poll( &amp;fds, <span class="number">2</span>, <span class="number">10000</span> );</span><br><span class="line"><span class="comment">// Check if poll actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If we detect the event, zero it out so we can reuse the structure</span></span><br><span class="line">    <span class="keyword">if</span> ( pfd[<span class="number">0</span>].revents &amp; POLLIN )</span><br><span class="line">        pfd[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// input event on sock1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pfd[<span class="number">1</span>].revents &amp; POLLOUT )</span><br><span class="line">        pfd[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// output event on sock2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h3><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p><ul><li>select 会修改描述符，而 poll 不会；</li><li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 的描述符类型使用链表实现，没有描述符的数量的限制；</li><li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li><li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li></ul><h3 id="2-速度"><a href="#2-速度" class="headerlink" title="2. 速度"></a>2. 速度</h3><p>select 和 poll 速度都比较慢。</p><ul><li>select 和 poll 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</li><li>select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 I/O 完成的描述符。</li></ul><h3 id="3-可移植性"><a href="#3-可移植性" class="headerlink" title="3. 可移植性"></a>3. 可移植性</h3><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p><p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p><p>epoll 仅适用于 Linux OS。</p><p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.</span></span><br><span class="line"><span class="comment">// The function argument is ignored (it was not before, but now it is), so put your favorite number here</span></span><br><span class="line"><span class="keyword">int</span> pollingfd = epoll_create( <span class="number">0xCAFE</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( pollingfd &lt; <span class="number">0</span> )</span><br><span class="line"> <span class="comment">// report error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the epoll structure in case more members are added in future</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Associate the connection class instance with the event. You can associate anything</span></span><br><span class="line"><span class="comment">// you want, epoll does not use this information. We store a connection class pointer, pConnection1</span></span><br><span class="line">ev.data.ptr = pConnection1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor for input, and do not automatically rearm the descriptor after the event</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLONESHOT;</span><br><span class="line"><span class="comment">// Add the descriptor into the monitoring list. We can do it even if another thread is</span></span><br><span class="line"><span class="comment">// waiting in epoll_wait - the descriptor will be properly added</span></span><br><span class="line"><span class="keyword">if</span> ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// report error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">pevents</span>[ 20 ];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array</span></span><br><span class="line"><span class="keyword">int</span> ready = epoll_wait( pollingfd, pevents, <span class="number">20</span>, <span class="number">10000</span> );</span><br><span class="line"><span class="comment">// Check if epoll actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check if any events detected</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pevents[i].events &amp; EPOLLIN )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get back our connection pointer</span></span><br><span class="line">            Connection * c = (Connection*) pevents[i].data.ptr;</span><br><span class="line">            c-&gt;handleReadEvent();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p><h3 id="1-LT-模式"><a href="#1-LT-模式" class="headerlink" title="1. LT 模式"></a>1. LT 模式</h3><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p><h3 id="2-ET-模式"><a href="#2-ET-模式" class="headerlink" title="2. ET 模式"></a>2. ET 模式</h3><p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p><p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><h3 id="1-select-应用场景"><a href="#1-select-应用场景" class="headerlink" title="1. select 应用场景"></a>1. select 应用场景</h3><p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。</p><p>select 可移植性更好，几乎被所有主流平台所支持。</p><h3 id="2-poll-应用场景"><a href="#2-poll-应用场景" class="headerlink" title="2. poll 应用场景"></a>2. poll 应用场景</h3><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p><p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p><p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。</p><h3 id="3-epoll-应用场景"><a href="#3-epoll-应用场景" class="headerlink" title="3. epoll 应用场景"></a>3. epoll 应用场景</h3><p>只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Stevens W R, Fenner B, Rudoff A M. UNIX network programming[M]. Addison-Wesley Professional, 2004.</li><li><a href="https://www.ibm.com/developerworks/linux/library/l-async/" target="_blank" rel="noopener">Boost application performance using asynchronous I/O</a></li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365683(v=vs.85).aspx" target="_blank" rel="noopener">Synchronous and Asynchronous I/O</a></li><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO 模式及 select、poll、epoll 详解</a></li><li><a href="https://daniel.haxx.se/docs/poll-vs-select.html" target="_blank" rel="noopener">poll vs select vs event-based</a></li><li><a href="http://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/" target="_blank" rel="noopener">select / poll / epoll: practical difference for system architects</a></li><li><a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/" target="_blank" rel="noopener">Browse the source code of userspace/glibc/sysdeps/unix/sysv/linux/ online</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一io-模型&quot;&gt;一、I/O 模型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#阻塞式-io&quot;&gt;阻塞式 I/O&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#非阻塞式-io&quot;&gt;非阻塞式 I/O&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#io-复用&quot;&gt;I/O 复用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#信号驱动-io&quot;&gt;信号驱动 I/O&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#异步-io&quot;&gt;异步 I/O&lt;/a&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2019/09/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/10/正则表达式/</id>
    <published>2019-09-10T13:37:22.000Z</published>
    <updated>2019-09-10T13:42:15.864Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#一概述">一、概述</a></li><li><a href="#二匹配单个字符">二、匹配单个字符</a></li><li><a href="#三匹配一组字符">三、匹配一组字符</a></li><li><a href="#四使用元字符">四、使用元字符</a><a id="more"></a></li><li><a href="#五重复匹配">五、重复匹配</a></li><li><a href="#六位置匹配">六、位置匹配</a></li><li><a href="#七使用子表达式">七、使用子表达式</a></li><li><a href="#八回溯引用">八、回溯引用</a></li><li><a href="#九前后查找">九、前后查找</a></li><li><a href="#十嵌入条件">十、嵌入条件</a></li><li><a href="#参考资料">参考资料</a></li></ul><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>正则表达式用于文本内容的查找和替换。<br>正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件。<br><a href="https://regexr.com/" target="_blank" rel="noopener">正则表达式在线工具</a></p><h1 id="二、匹配单个字符"><a href="#二、匹配单个字符" class="headerlink" title="二、匹配单个字符"></a>二、匹配单个字符</h1><p><strong>.</strong>  可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；<br><strong>.</strong>  是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。<br>正则表达式一般是区分大小写的，但是也有些实现是不区分。<br><strong>正则表达式</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nam.</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><p>My  <strong>name</strong>  is Zheng.</p><h1 id="三、匹配一组字符"><a href="#三、匹配一组字符" class="headerlink" title="三、匹配一组字符"></a>三、匹配一组字符</h1><p><strong>[ ]</strong>  定义一个字符集合；</p><p>0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。</p><p><strong>-</strong>  只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；</p><p><strong>^</strong>  在 [ ] 中是取非操作。</p><p><strong>应用</strong> </p><p>匹配以 abc 为开头，并且最后一个字母不为数字的字符串：</p><p><strong>正则表达式</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc[^0-9]</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><ol><li><strong>abcd</strong> </li><li>abc1</li><li>abc2</li></ol><h1 id="四、使用元字符"><a href="#四、使用元字符" class="headerlink" title="四、使用元字符"></a>四、使用元字符</h1><h2 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h2><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">[\b]</td><td align="center">回退（删除）一个字符</td></tr><tr><td align="center">\f</td><td align="center">换页符</td></tr><tr><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">\r</td><td align="center">回车符</td></tr><tr><td align="center">\t</td><td align="center">制表符</td></tr><tr><td align="center">\v</td><td align="center">垂直制表符</td></tr></tbody></table><p>\r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n。</p><p>\r\n\r\n 可以匹配 Windows 下的空白行，因为它将匹配两个连续的行尾标签，而这正是两条记录之间的空白行；</p><h2 id="匹配特定的字符类别"><a href="#匹配特定的字符类别" class="headerlink" title="匹配特定的字符类别"></a>匹配特定的字符类别</h2><h3 id="1-数字元字符"><a href="#1-数字元字符" class="headerlink" title="1. 数字元字符"></a>1. 数字元字符</h3><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\d</td><td align="center">数字字符，等价于 [0-9]</td></tr><tr><td align="center">\D</td><td align="center">非数字字符，等价于 [^0-9]</td></tr></tbody></table><h3 id="2-字母数字元字符"><a href="#2-字母数字元字符" class="headerlink" title="2. 字母数字元字符"></a>2. 字母数字元字符</h3><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\w</td><td align="center">大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]</td></tr><tr><td align="center">\W</td><td align="center">对 \w 取非</td></tr></tbody></table><h3 id="3-空白字符元字符"><a href="#3-空白字符元字符" class="headerlink" title="3. 空白字符元字符"></a>3. 空白字符元字符</h3><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\s</td><td align="center">任何一个空白字符，等价于 [\f\n\r\t\v]</td></tr><tr><td align="center">\S</td><td align="center">对 \s 取非</td></tr></tbody></table><p>\x 匹配十六进制字符，\0 匹配八进制，例如 \x0A 对应 ASCII 字符 10，等价于 \n。</p><h1 id="五、重复匹配"><a href="#五、重复匹配" class="headerlink" title="五、重复匹配"></a>五、重复匹配</h1><ul><li><strong>+</strong>  匹配 1 个或者多个字符</li><li><strong>\</strong> * 匹配 0 个或者多个</li><li><strong>?</strong>  匹配 0 个或者 1 个</li></ul><p><strong>应用</strong> </p><p>匹配邮箱地址。</p><p><strong>正则表达式</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\w.]+@\w+\.\w+</span><br></pre></td></tr></table></figure><p>[\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；</p><p><strong>匹配结果</strong> </p><p><strong>abc.def<span>@</span>qq.com</strong> </p><ul><li><strong>{n}</strong>  匹配 n 个字符</li><li><strong>{m, n}</strong>  匹配 m~n 个字符</li><li><strong>{m,}</strong>  至少匹配 m 个字符</li></ul><p>* 和 + 都是贪婪型元字符，会匹配最多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m, n}? 。</p><p><strong>正则表达式</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.+c</span><br></pre></td></tr></table></figure><p>由于 + 是贪婪型的，因此 .+ 会匹配更可能多的内容，所以会把整个 abcabcabc 文本都匹配，而不是只匹配前面的 abc 文本。用懒惰型可以实现匹配前面的。</p><p><strong>匹配结果</strong> </p><p><strong>abcabcabc</strong> </p><h1 id="六、位置匹配"><a href="#六、位置匹配" class="headerlink" title="六、位置匹配"></a>六、位置匹配</h1><h2 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h2><p><strong>\b</strong>  可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；<strong>\B</strong> 匹配一个不是单词边界的位置。</p><p>\b 只匹配位置，不匹配字符，因此 \babc\b 匹配出来的结果为 3 个字符。</p><h2 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界"></a>字符串边界</h2><p><strong>^</strong>  匹配整个字符串的开头，<strong>$</strong> 匹配结尾。</p><p>^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。</p><p>分行匹配模式（multiline）下，换行被当做字符串的边界。</p><p><strong>应用</strong> </p><p>匹配代码中以 // 开始的注释行</p><p><strong>正则表达式</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\s*\/\/.*$</span><br></pre></td></tr></table></figure><div align="center"> <img src="../pics//600e9c75-5033-4dad-ae2b-930957db638e.png"> </div><br><p><strong>匹配结果</strong> </p><ol><li>public void fun() {</li><li>&nbsp;&nbsp;&nbsp;&nbsp;     <strong>// 注释 1</strong> </li><li>&nbsp;&nbsp;&nbsp;&nbsp;    int a = 1;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;    int b = 2;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;     <strong>// 注释 2</strong> </li><li>&nbsp;&nbsp;&nbsp;&nbsp;    int c = a + b;</li><li>}</li></ol><h1 id="七、使用子表达式"><a href="#七、使用子表达式" class="headerlink" title="七、使用子表达式"></a>七、使用子表达式</h1><p>使用  <strong>( )</strong>  定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。</p><p>子表达式可以嵌套，但是嵌套层次过深会变得很难理解。</p><p><strong>正则表达式</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ab)&#123;2,&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><p><strong>ababab</strong> </p><p><strong>|</strong>  是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。</p><p><strong>正则表达式</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(19|20)\d&#123;2&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><ol><li><strong>1900</strong> </li><li><strong>2010</strong> </li><li>1020</li></ol><p><strong>应用</strong> </p><p>匹配 IP 地址。</p><p>IP 地址中每部分都是 0-255 的数字，用正则表达式匹配时以下情况是合法的：</p><ul><li>一位数字</li><li>不以 0 开头的两位数字</li><li>1 开头的三位数</li><li>2 开头，第 2 位是 0-4 的三位数</li><li>25 开头，第 3 位是 0-5 的三位数</li></ul><p><strong>正则表达式</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((25[0-5]|(2[0-4]\d)|(1\d&#123;2&#125;)|([1-9]\d)|(\d))\.)&#123;3&#125;(25[0-5]|(2[0-4]\d)|(1\d&#123;2&#125;)|([1-9]\d)|(\d))</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><ol><li><strong>192.168.0.1</strong> </li><li>00.00.00.00</li><li>555.555.555.555</li></ol><h1 id="八、回溯引用"><a href="#八、回溯引用" class="headerlink" title="八、回溯引用"></a>八、回溯引用</h1><p>回溯引用使用  <strong>\n</strong>  来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。</p><p><strong>应用</strong> </p><p>匹配 HTML 中合法的标题元素。</p><p><strong>正则表达式</strong> </p><p>\1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;(h[1-6])&gt;\w*?&lt;\/\1&gt;</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><ol><li><strong>&lt;h1&gt;x&lt;/h1&gt;</strong> </li><li><strong>&lt;h2&gt;x&lt;/h2&gt;</strong> </li><li>&lt;h3&gt;x&lt;/h1&gt;</li></ol><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>需要用到两个正则表达式。</p><p><strong>应用</strong> </p><p>修改电话号码格式。</p><p><strong>文本</strong> </p><p>313-555-1234</p><p><strong>查找正则表达式</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\d&#123;3&#125;)(-)(\d&#123;3&#125;)(-)(\d&#123;4&#125;)</span><br></pre></td></tr></table></figure><p><strong>替换正则表达式</strong> </p><p>在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($1) $3-$5</span><br></pre></td></tr></table></figure><p><strong>结果</strong> </p><p>(313) 555-1234</p><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\l</td><td align="center">把下个字符转换为小写</td></tr><tr><td align="center">\u</td><td align="center">把下个字符转换为大写</td></tr><tr><td align="center">\L</td><td align="center">把\L 和\E 之间的字符全部转换为小写</td></tr><tr><td align="center">\U</td><td align="center">把\U 和\E 之间的字符全部转换为大写</td></tr><tr><td align="center">\E</td><td align="center">结束\L 或者\U</td></tr></tbody></table><p><strong>应用</strong> </p><p>把文本的第二个和第三个字符转换为大写。</p><p><strong>文本</strong> </p><p>abcd</p><p><strong>查找</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\w)(\w&#123;2&#125;)(\w)</span><br></pre></td></tr></table></figure><p><strong>替换</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$1\U$2\E$3</span><br></pre></td></tr></table></figure><p><strong>结果</strong> </p><p>aBCd</p><h1 id="九、前后查找"><a href="#九、前后查找" class="headerlink" title="九、前后查找"></a>九、前后查找</h1><p>前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。向前查找用  <strong>?=</strong>  来定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 ?&lt;= 定义（注: javaScript 不支持向后匹配, java 对其支持也不完善）。</p><p><strong>应用</strong> </p><p>查找出邮件地址 @ 字符前面的部分。</p><p><strong>正则表达式</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\w+(?=@)</span><br></pre></td></tr></table></figure><p><strong>结果</strong> </p><p><strong>abc</strong> @qq.com</p><p>对向前和向后查找取非，只要把 = 替换成 ! 即可，比如 (?=) 替换成 (?!) 。取非操作使得匹配那些首尾不符合要求的内容。</p><h1 id="十、嵌入条件"><a href="#十、嵌入条件" class="headerlink" title="十、嵌入条件"></a>十、嵌入条件</h1><h2 id="回溯引用条件"><a href="#回溯引用条件" class="headerlink" title="回溯引用条件"></a>回溯引用条件</h2><p>条件判断为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。</p><p><strong>正则表达式</strong> </p><p>子表达式 (\() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\()?abc(?(1)\))</span><br></pre></td></tr></table></figure><p><strong>结果</strong> </p><ol><li><strong>(abc)</strong> </li><li><strong>abc</strong> </li><li>(abc</li></ol><h2 id="前后查找条件"><a href="#前后查找条件" class="headerlink" title="前后查找条件"></a>前后查找条件</h2><p>条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。</p><p><strong>正则表达式</strong> </p><p> ?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4} 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;5&#125;(?(?=-)-\d&#123;4&#125;)</span><br></pre></td></tr></table></figure><p><strong>结果</strong> </p><ol><li><strong>11111</strong> </li><li>22222-</li><li><strong>33333-4444</strong> </li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>BenForta. 正则表达式必知必会 [M]. 人民邮电出版社, 2007.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一概述&quot;&gt;一、概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二匹配单个字符&quot;&gt;二、匹配单个字符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三匹配一组字符&quot;&gt;三、匹配一组字符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#四使用元字符&quot;&gt;四、使用元字符&lt;/a&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="通信协议" scheme="http://yoursite.com/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>机器学习线路图</title>
    <link href="http://yoursite.com/2019/09/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E8%B7%AF%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/09/10/机器学习线路图/</id>
    <published>2019-09-10T13:34:30.000Z</published>
    <updated>2019-09-10T13:42:10.529Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章分为了四个部分：机器学习，自然语言处理，python和数学。在每个部分中我都列举了一些主题，但是因为材料的数量庞大，我不可能涉及到每一个主题。</p><a id="more"></a><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>Start Here with Machine Learning (machinelearningmastery.com)<br><a href="https://machinelearningmastery.com/start-here/" target="_blank" rel="noopener">https://machinelearningmastery.com/start-here/</a></p><p>Machine Learning is Fun! (medium.com/@ageitgey)<br><a href="https://medium.com/@ageitgey/machine-learning-is-fun-80ea3ec3c471" target="_blank" rel="noopener">https://medium.com/@ageitgey/machine-learning-is-fun-80ea3ec3c471</a></p><p>Rules of Machine Learning: Best Practices for ML Engineering(martin.zinkevich.org)<br><a href="http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf" target="_blank" rel="noopener">http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf</a></p><p>Machine Learning Crash Course: Part I, Part II, Part III (Machine Learning at Berkeley)<br><a href="https://ml.berkeley.edu/blog/2016/11/06/tutorial-1/" target="_blank" rel="noopener">https://ml.berkeley.edu/blog/2016/11/06/tutorial-1/</a><br><a href="https://ml.berkeley.edu/blog/2016/12/24/tutorial-2/" target="_blank" rel="noopener">https://ml.berkeley.edu/blog/2016/12/24/tutorial-2/</a><br><a href="https://ml.berkeley.edu/blog/2017/02/04/tutorial-3/" target="_blank" rel="noopener">https://ml.berkeley.edu/blog/2017/02/04/tutorial-3/</a></p><p>An Introduction to Machine Learning Theory and Its Applications: A Visual Tutorial with Examples (toptal.com)<br><a href="https://www.toptal.com/machine-learning/machine-learning-theory-an-introductory-primer" target="_blank" rel="noopener">https://www.toptal.com/machine-learning/machine-learning-theory-an-introductory-primer</a></p><p>A Gentle Guide to Machine Learning (monkeylearn.com)<br><a href="https://monkeylearn.com/blog/gentle-guide-to-machine-learning/" target="_blank" rel="noopener">https://monkeylearn.com/blog/gentle-guide-to-machine-learning/</a></p><p>Which machine learning algorithm should I use? (sas.com)<br><a href="https://blogs.sas.com/content/subconsciousmusings/2017/04/12/machine-learning-algorithm-use/" target="_blank" rel="noopener">https://blogs.sas.com/content/subconsciousmusings/2017/04/12/machine-learning-algorithm-use/</a></p><p>The Machine Learning Primer (sas.com)<br><a href="https://www.sas.com/content/dam/SAS/en_us/doc/whitepaper1/machine-learning-primer-108796.pdf" target="_blank" rel="noopener">https://www.sas.com/content/dam/SAS/en_us/doc/whitepaper1/machine-learning-primer-108796.pdf</a></p><p>Machine Learning Tutorial for Beginners (kaggle.com/kanncaa1)<br><a href="https://www.kaggle.com/kanncaa1/machine-learning-tutorial-for-beginners" target="_blank" rel="noopener">https://www.kaggle.com/kanncaa1/machine-learning-tutorial-for-beginners</a></p><h3 id="激活和损失函数"><a href="#激活和损失函数" class="headerlink" title="激活和损失函数"></a>激活和损失函数</h3><p>Sigmoid neurons (neuralnetworksanddeeplearning.com)<br><a href="http://neuralnetworksanddeeplearning.com/chap1.html#sigmoid_neurons" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap1.html#sigmoid_neurons</a></p><p>What is the role of the activation function in a neural network? (quora.com)<br><a href="https://www.quora.com/What-is-the-role-of-the-activation-function-in-a-neural-network" target="_blank" rel="noopener">https://www.quora.com/What-is-the-role-of-the-activation-function-in-a-neural-network</a></p><p>Comprehensive list of activation functions in neural networks with pros/cons(stats.stackexchange.com)<br><a href="https://stats.stackexchange.com/questions/115258/comprehensive-list-of-activation-functions-in-neural-networks-with-pros-cons" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/115258/comprehensive-list-of-activation-functions-in-neural-networks-with-pros-cons</a></p><p>Activation functions and it’s types-Which is better? (medium.com)<br><a href="https://medium.com/towards-data-science/activation-functions-and-its-types-which-is-better-a9a5310cc8f" target="_blank" rel="noopener">https://medium.com/towards-data-science/activation-functions-and-its-types-which-is-better-a9a5310cc8f</a></p><p>Making Sense of Logarithmic Loss (exegetic.biz)<br><a href="http://www.exegetic.biz/blog/2015/12/making-sense-logarithmic-loss/" target="_blank" rel="noopener">http://www.exegetic.biz/blog/2015/12/making-sense-logarithmic-loss/</a></p><p>Loss Functions (Stanford CS231n)<br><a href="http://cs231n.github.io/neural-networks-2/#losses" target="_blank" rel="noopener">http://cs231n.github.io/neural-networks-2/#losses</a></p><p>L1 vs. L2 Loss function (rishy.github.io)<br><a href="http://rishy.github.io/ml/2015/07/28/l1-vs-l2-loss/" target="_blank" rel="noopener">http://rishy.github.io/ml/2015/07/28/l1-vs-l2-loss/</a></p><p>The cross-entropy cost function (neuralnetworksanddeeplearning.com)<br><a href="http://neuralnetworksanddeeplearning.com/chap3.html#the_cross-entropy_cost_function" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap3.html#the_cross-entropy_cost_function</a></p><h3 id="偏差"><a href="#偏差" class="headerlink" title="偏差"></a>偏差</h3><p>Role of Bias in Neural Networks (stackoverflow.com)<br><a href="https://stackoverflow.com/questions/2480650/role-of-bias-in-neural-networks/2499936#2499936" target="_blank" rel="noopener">https://stackoverflow.com/questions/2480650/role-of-bias-in-neural-networks/2499936#2499936</a></p><p>Bias Nodes in Neural Networks(makeyourownneuralnetwork.blogspot.com)<br><a href="http://makeyourownneuralnetwork.blogspot.com/2016/06/bias-nodes-in-neural-networks.html" target="_blank" rel="noopener">http://makeyourownneuralnetwork.blogspot.com/2016/06/bias-nodes-in-neural-networks.html</a></p><p>What is bias in artificial neural network? (quora.com)<br><a href="https://www.quora.com/What-is-bias-in-artificial-neural-network" target="_blank" rel="noopener">https://www.quora.com/What-is-bias-in-artificial-neural-network</a></p><h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><p>Perceptrons (neuralnetworksanddeeplearning.com)<br><a href="http://neuralnetworksanddeeplearning.com/chap1.html#perceptrons" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap1.html#perceptrons</a></p><p>The Perception (natureofcode.com)<br><a href="https://natureofcode.com/book/chapter-10-neural-networks/#chapter10_figure3" target="_blank" rel="noopener">https://natureofcode.com/book/chapter-10-neural-networks/#chapter10_figure3</a></p><p>Single-layer Neural Networks (Perceptrons) (dcu.ie)<br><a href="http://computing.dcu.ie/~humphrys/Notes/Neural/single.neural.html" target="_blank" rel="noopener">http://computing.dcu.ie/~humphrys/Notes/Neural/single.neural.html</a></p><p>From Perceptrons to Deep Networks (toptal.com)<br><a href="https://www.toptal.com/machine-learning/an-introduction-to-deep-learning-from-perceptrons-to-deep-networks" target="_blank" rel="noopener">https://www.toptal.com/machine-learning/an-introduction-to-deep-learning-from-perceptrons-to-deep-networks</a></p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>Introduction to linear regression analysis (duke.edu)<br><a href="http://people.duke.edu/~rnau/regintro.htm" target="_blank" rel="noopener">http://people.duke.edu/~rnau/regintro.htm</a></p><p>Linear Regression (ufldl.stanford.edu)<br><a href="http://ufldl.stanford.edu/tutorial/supervised/LinearRegression/" target="_blank" rel="noopener">http://ufldl.stanford.edu/tutorial/supervised/LinearRegression/</a></p><p>Linear Regression (readthedocs.io)<br><a href="http://ml-cheatsheet.readthedocs.io/en/latest/linear_regression.html" target="_blank" rel="noopener">http://ml-cheatsheet.readthedocs.io/en/latest/linear_regression.html</a></p><p>Logistic Regression (readthedocs.io)<br><a href="https://ml-cheatsheet.readthedocs.io/en/latest/logistic_regression.html" target="_blank" rel="noopener">https://ml-cheatsheet.readthedocs.io/en/latest/logistic_regression.html</a></p><p>Simple Linear Regression Tutorial for Machine Learning(machinelearningmastery.com)<br><a href="http://machinelearningmastery.com/simple-linear-regression-tutorial-for-machine-learning/" target="_blank" rel="noopener">http://machinelearningmastery.com/simple-linear-regression-tutorial-for-machine-learning/</a></p><p>Logistic Regression Tutorial for Machine Learning(machinelearningmastery.com)<br><a href="https://machinelearningmastery.com/logistic-regression-tutorial-for-machine-learning/" target="_blank" rel="noopener">https://machinelearningmastery.com/logistic-regression-tutorial-for-machine-learning/</a></p><p>Softmax Regression (ufldl.stanford.edu)<br><a href="http://ufldl.stanford.edu/tutorial/supervised/SoftmaxRegression/" target="_blank" rel="noopener">http://ufldl.stanford.edu/tutorial/supervised/SoftmaxRegression/</a></p><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>Learning with gradient descent (neuralnetworksanddeeplearning.com)<br><a href="http://neuralnetworksanddeeplearning.com/chap1.html#learning_with_gradient_descent" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap1.html#learning_with_gradient_descent</a></p><p>Gradient Descent (iamtrask.github.io)<br><a href="http://iamtrask.github.io/2015/07/27/python-network-part2/" target="_blank" rel="noopener">http://iamtrask.github.io/2015/07/27/python-network-part2/</a></p><p>How to understand Gradient Descent algorithm (kdnuggets.com)<br><a href="http://www.kdnuggets.com/2017/04/simple-understand-gradient-descent-algorithm.html" target="_blank" rel="noopener">http://www.kdnuggets.com/2017/04/simple-understand-gradient-descent-algorithm.html</a></p><p>An overview of gradient descent optimization algorithms(sebastianruder.com)<br><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">http://sebastianruder.com/optimizing-gradient-descent/</a></p><p>Optimization: Stochastic Gradient Descent (Stanford CS231n)<br><a href="http://cs231n.github.io/optimization-1/" target="_blank" rel="noopener">http://cs231n.github.io/optimization-1/</a></p><h3 id="生成学习"><a href="#生成学习" class="headerlink" title="生成学习"></a>生成学习</h3><p>Generative Learning Algorithms (Stanford CS229)<br><a href="http://cs229.stanford.edu/notes/cs229-notes2.pdf" target="_blank" rel="noopener">http://cs229.stanford.edu/notes/cs229-notes2.pdf</a></p><p>A practical explanation of a Naive Bayes classifier (monkeylearn.com)<br><a href="https://monkeylearn.com/blog/practical-explanation-naive-bayes-classifier/" target="_blank" rel="noopener">https://monkeylearn.com/blog/practical-explanation-naive-bayes-classifier/</a></p><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>An introduction to Support Vector Machines (SVM) (monkeylearn.com)<br><a href="https://monkeylearn.com/blog/introduction-to-support-vector-machines-svm/" target="_blank" rel="noopener">https://monkeylearn.com/blog/introduction-to-support-vector-machines-svm/</a></p><p>Support Vector Machines (Stanford CS229)<br><a href="http://cs229.stanford.edu/notes/cs229-notes3.pdf" target="_blank" rel="noopener">http://cs229.stanford.edu/notes/cs229-notes3.pdf</a></p><p>Linear classification: Support Vector Machine, Softmax (Stanford 231n)<br><a href="http://cs231n.github.io/linear-classify/" target="_blank" rel="noopener">http://cs231n.github.io/linear-classify/</a></p><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>A Guide to Deep Learning by YN² (yerevann.com)<br><a href="http://yerevann.com/a-guide-to-deep-learning/" target="_blank" rel="noopener">http://yerevann.com/a-guide-to-deep-learning/</a></p><p>Deep Learning Papers Reading Roadmap (github.com/floodsung)<br><a href="https://github.com/floodsung/Deep-Learning-Papers-Reading-Roadmap" target="_blank" rel="noopener">https://github.com/floodsung/Deep-Learning-Papers-Reading-Roadmap</a></p><p>Deep Learning in a Nutshell (nikhilbuduma.com)<br><a href="http://nikhilbuduma.com/2014/12/29/deep-learning-in-a-nutshell/" target="_blank" rel="noopener">http://nikhilbuduma.com/2014/12/29/deep-learning-in-a-nutshell/</a></p><p>A Tutorial on Deep Learning (Quoc V. Le)<br><a href="http://ai.stanford.edu/~quocle/tutorial1.pdf" target="_blank" rel="noopener">http://ai.stanford.edu/~quocle/tutorial1.pdf</a></p><p>What is Deep Learning? (machinelearningmastery.com)<br><a href="https://machinelearningmastery.com/what-is-deep-learning/" target="_blank" rel="noopener">https://machinelearningmastery.com/what-is-deep-learning/</a></p><p>What’s the Difference Between Artificial Intelligence, Machine Learning, and Deep Learning? (nvidia.com)<br><a href="https://blogs.nvidia.com/blog/2016/07/29/whats-difference-artificial-intelligence-machine-learning-deep-learning-ai/" target="_blank" rel="noopener">https://blogs.nvidia.com/blog/2016/07/29/whats-difference-artificial-intelligence-machine-learning-deep-learning-ai/</a></p><p>Deep Learning — The Straight Dope (gluon.mxnet.io)<br><a href="https://gluon.mxnet.io/" target="_blank" rel="noopener">https://gluon.mxnet.io/</a></p><h3 id="优化和降维"><a href="#优化和降维" class="headerlink" title="优化和降维"></a>优化和降维</h3><p>Seven Techniques for Data Dimensionality Reduction (knime.org)<br><a href="https://www.knime.org/blog/seven-techniques-for-data-dimensionality-reduction" target="_blank" rel="noopener">https://www.knime.org/blog/seven-techniques-for-data-dimensionality-reduction</a></p><p>Principal components analysis (Stanford CS229)<br><a href="http://cs229.stanford.edu/notes/cs229-notes10.pdf" target="_blank" rel="noopener">http://cs229.stanford.edu/notes/cs229-notes10.pdf</a></p><p>Dropout: A simple way to improve neural networks (Hinton @ NIPS 2012)<br><a href="http://cs229.stanford.edu/notes/cs229-notes10.pdf" target="_blank" rel="noopener">http://cs229.stanford.edu/notes/cs229-notes10.pdf</a></p><p>How to train your Deep Neural Network (rishy.github.io)<br><a href="http://rishy.github.io/ml/2017/01/05/how-to-train-your-dnn/" target="_blank" rel="noopener">http://rishy.github.io/ml/2017/01/05/how-to-train-your-dnn/</a></p><p>长短期记忆（LSTM）</p><p>A Gentle Introduction to Long Short-Term Memory Networks by the Experts(machinelearningmastery.com)<br><a href="https://machinelearningmastery.com/gentle-introduction-long-short-term-memory-networks-experts/" target="_blank" rel="noopener">https://machinelearningmastery.com/gentle-introduction-long-short-term-memory-networks-experts/</a></p><p>Understanding LSTM Networks (colah.github.io)<br><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">http://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></p><p>Exploring LSTMs (echen.me)<br><a href="http://blog.echen.me/2017/05/30/exploring-lstms/" target="_blank" rel="noopener">http://blog.echen.me/2017/05/30/exploring-lstms/</a></p><p>Anyone Can Learn To Code an LSTM-RNN in Python (iamtrask.github.io)<br><a href="http://iamtrask.github.io/2015/11/15/anyone-can-code-lstm/" target="_blank" rel="noopener">http://iamtrask.github.io/2015/11/15/anyone-can-code-lstm/</a></p><h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><p>Introducing convolutional networks (neuralnetworksanddeeplearning.com)<br><a href="http://neuralnetworksanddeeplearning.com/chap6.html#introducing_convolutional_networks" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap6.html#introducing_convolutional_networks</a></p><p>Deep Learning and Convolutional Neural Networks(medium.com/@ageitgey)<br><a href="https://medium.com/@ageitgey/machine-learning-is-fun-part-3-deep-learning-and-convolutional-neural-networks-f40359318721" target="_blank" rel="noopener">https://medium.com/@ageitgey/machine-learning-is-fun-part-3-deep-learning-and-convolutional-neural-networks-f40359318721</a></p><p>Conv Nets: A Modular Perspective (colah.github.io)<br><a href="http://colah.github.io/posts/2014-07-Conv-Nets-Modular/" target="_blank" rel="noopener">http://colah.github.io/posts/2014-07-Conv-Nets-Modular/</a></p><p>Understanding Convolutions (colah.github.io)<br><a href="http://colah.github.io/posts/2014-07-Understanding-Convolutions/" target="_blank" rel="noopener">http://colah.github.io/posts/2014-07-Understanding-Convolutions/</a></p><h3 id="递归神经网络"><a href="#递归神经网络" class="headerlink" title="递归神经网络"></a>递归神经网络</h3><p>Recurrent Neural Networks Tutorial (wildml.com)<br><a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/" target="_blank" rel="noopener">http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/</a></p><p>Attention and Augmented Recurrent Neural Networks (distill.pub)<br><a href="http://distill.pub/2016/augmented-rnns/" target="_blank" rel="noopener">http://distill.pub/2016/augmented-rnns/</a></p><p>The Unreasonable Effectiveness of Recurrent Neural Networks(karpathy.github.io)<br><a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener">http://karpathy.github.io/2015/05/21/rnn-effectiveness/</a></p><p>A Deep Dive into Recurrent Neural Nets (nikhilbuduma.com)<br><a href="http://nikhilbuduma.com/2015/01/11/a-deep-dive-into-recurrent-neural-networks/" target="_blank" rel="noopener">http://nikhilbuduma.com/2015/01/11/a-deep-dive-into-recurrent-neural-networks/</a></p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>Simple Beginner’s guide to Reinforcement Learning &amp; its implementation(analyticsvidhya.com)<br><a href="https://www.analyticsvidhya.com/blog/2017/01/introduction-to-reinforcement-learning-implementation/" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2017/01/introduction-to-reinforcement-learning-implementation/</a></p><p>A Tutorial for Reinforcement Learning (mst.edu)<br><a href="https://web.mst.edu/~gosavia/tutorial.pdf" target="_blank" rel="noopener">https://web.mst.edu/~gosavia/tutorial.pdf</a></p><p>Learning Reinforcement Learning (wildml.com)<br><a href="http://www.wildml.com/2016/10/learning-reinforcement-learning/" target="_blank" rel="noopener">http://www.wildml.com/2016/10/learning-reinforcement-learning/</a></p><p>Deep Reinforcement Learning: Pong from Pixels (karpathy.github.io)<br><a href="http://karpathy.github.io/2016/05/31/rl/" target="_blank" rel="noopener">http://karpathy.github.io/2016/05/31/rl/</a></p><h3 id="生成对抗网络（GANs）"><a href="#生成对抗网络（GANs）" class="headerlink" title="生成对抗网络（GANs）"></a>生成对抗网络（GANs）</h3><p>Adversarial Machine Learning (aaai18adversarial.github.io)<br><a href="https://aaai18adversarial.github.io/slides/AML.pptx" target="_blank" rel="noopener">https://aaai18adversarial.github.io/slides/AML.pptx</a></p><p>What’s a Generative Adversarial Network? (nvidia.com)<br><a href="https://blogs.nvidia.com/blog/2017/05/17/generative-adversarial-network/" target="_blank" rel="noopener">https://blogs.nvidia.com/blog/2017/05/17/generative-adversarial-network/</a></p><p>Abusing Generative Adversarial Networks to Make 8-bit Pixel Art(medium.com/@ageitgey)<br><a href="https://medium.com/@ageitgey/abusing-generative-adversarial-networks-to-make-8-bit-pixel-art-e45d9b96cee7" target="_blank" rel="noopener">https://medium.com/@ageitgey/abusing-generative-adversarial-networks-to-make-8-bit-pixel-art-e45d9b96cee7</a></p><p>An introduction to Generative Adversarial Networks (with code in TensorFlow) (aylien.com)<br><a href="http://blog.aylien.com/introduction-generative-adversarial-networks-code-tensorflow/" target="_blank" rel="noopener">http://blog.aylien.com/introduction-generative-adversarial-networks-code-tensorflow/</a></p><p>Generative Adversarial Networks for Beginners (oreilly.com)<br><a href="https://www.oreilly.com/learning/generative-adversarial-networks-for-beginners" target="_blank" rel="noopener">https://www.oreilly.com/learning/generative-adversarial-networks-for-beginners</a></p><h3 id="多任务学习"><a href="#多任务学习" class="headerlink" title="多任务学习"></a>多任务学习</h3><p>An Overview of Multi-Task Learning in Deep Neural Networks(sebastianruder.com)<br><a href="http://sebastianruder.com/multi-task/index.html" target="_blank" rel="noopener">http://sebastianruder.com/multi-task/index.html</a></p><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><p>Natural Language Processing is Fun! (medium.com/@ageitgey)<br><a href="https://medium.com/@ageitgey/natural-language-processing-is-fun-9a0bff37854e" target="_blank" rel="noopener">https://medium.com/@ageitgey/natural-language-processing-is-fun-9a0bff37854e</a></p><p>A Primer on Neural Network Models for Natural Language Processing(Yoav Goldberg)<br><a href="http://u.cs.biu.ac.il/~yogo/nnlp.pdf" target="_blank" rel="noopener">http://u.cs.biu.ac.il/~yogo/nnlp.pdf</a></p><p>The Definitive Guide to Natural Language Processing (monkeylearn.com)<br><a href="https://monkeylearn.com/blog/the-definitive-guide-to-natural-language-processing/" target="_blank" rel="noopener">https://monkeylearn.com/blog/the-definitive-guide-to-natural-language-processing/</a></p><p>Introduction to Natural Language Processing (algorithmia.com)<br><a href="https://blog.algorithmia.com/introduction-natural-language-processing-nlp/" target="_blank" rel="noopener">https://blog.algorithmia.com/introduction-natural-language-processing-nlp/</a></p><p>Natural Language Processing Tutorial (vikparuchuri.com)<br><a href="http://www.vikparuchuri.com/blog/natural-language-processing-tutorial/" target="_blank" rel="noopener">http://www.vikparuchuri.com/blog/natural-language-processing-tutorial/</a></p><p>Natural Language Processing (almost) from Scratch (arxiv.org)<br><a href="https://arxiv.org/pdf/1103.0398.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1103.0398.pdf</a></p><h3 id="深度学习和自然语言处理"><a href="#深度学习和自然语言处理" class="headerlink" title="深度学习和自然语言处理"></a>深度学习和自然语言处理</h3><p>Deep Learning applied to NLP (arxiv.org)<br><a href="https://arxiv.org/pdf/1703.03091.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1703.03091.pdf</a></p><p>Deep Learning for NLP (without Magic) (Richard Socher)<br><a href="https://nlp.stanford.edu/courses/NAACL2013/NAACL2013-Socher-Manning-DeepLearning.pdf" target="_blank" rel="noopener">https://nlp.stanford.edu/courses/NAACL2013/NAACL2013-Socher-Manning-DeepLearning.pdf</a></p><p>Understanding Convolutional Neural Networks for NLP (wildml.com)<br><a href="http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/" target="_blank" rel="noopener">http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/</a></p><p>Deep Learning, NLP, and Representations (colah.github.io)<br><a href="http://colah.github.io/posts/2014-07-NLP-RNNs-Representations/" target="_blank" rel="noopener">http://colah.github.io/posts/2014-07-NLP-RNNs-Representations/</a></p><p>Embed, encode, attend, predict: The new deep learning formula for state-of-the-art NLP models (explosion.ai)<br><a href="https://explosion.ai/blog/deep-learning-formula-nlp" target="_blank" rel="noopener">https://explosion.ai/blog/deep-learning-formula-nlp</a></p><p>Understanding Natural Language with Deep Neural Networks Using Torch(nvidia.com)<br><a href="https://devblogs.nvidia.com/parallelforall/understanding-natural-language-deep-neural-networks-using-torch/" target="_blank" rel="noopener">https://devblogs.nvidia.com/parallelforall/understanding-natural-language-deep-neural-networks-using-torch/</a></p><p>Deep Learning for NLP with Pytorch (pytorich.org)<br><a href="http://pytorch.org/tutorials/beginner/deep_learning_nlp_tutorial.html" target="_blank" rel="noopener">http://pytorch.org/tutorials/beginner/deep_learning_nlp_tutorial.html</a></p><h3 id="词向量"><a href="#词向量" class="headerlink" title="词向量"></a>词向量</h3><p>Bag of Words Meets Bags of Popcorn (kaggle.com)<br><a href="https://www.kaggle.com/c/word2vec-nlp-tutorial" target="_blank" rel="noopener">https://www.kaggle.com/c/word2vec-nlp-tutorial</a></p><p>On word embeddings Part I, Part II, Part III (sebastianruder.com)<br><a href="http://sebastianruder.com/word-embeddings-1/index.html" target="_blank" rel="noopener">http://sebastianruder.com/word-embeddings-1/index.html</a><br><a href="http://sebastianruder.com/word-embeddings-softmax/index.html" target="_blank" rel="noopener">http://sebastianruder.com/word-embeddings-softmax/index.html</a><br><a href="http://sebastianruder.com/secret-word2vec/index.html" target="_blank" rel="noopener">http://sebastianruder.com/secret-word2vec/index.html</a></p><p>The amazing power of word vectors (acolyer.org)<br><a href="https://blog.acolyer.org/2016/04/21/the-amazing-power-of-word-vectors/" target="_blank" rel="noopener">https://blog.acolyer.org/2016/04/21/the-amazing-power-of-word-vectors/</a></p><p>word2vec Parameter Learning Explained (arxiv.org)<br><a href="https://arxiv.org/pdf/1411.2738.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1411.2738.pdf</a></p><p>Word2Vec Tutorial — The Skip-Gram Model, Negative Sampling(mccormickml.com)<br><a href="http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/" target="_blank" rel="noopener">http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/</a><br><a href="http://mccormickml.com/2017/01/11/word2vec-tutorial-part-2-negative-sampling/" target="_blank" rel="noopener">http://mccormickml.com/2017/01/11/word2vec-tutorial-part-2-negative-sampling/</a></p><h3 id="编码器-解码器"><a href="#编码器-解码器" class="headerlink" title="编码器-解码器"></a>编码器-解码器</h3><p>Attention and Memory in Deep Learning and NLP (wildml.com)<br><a href="http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/" target="_blank" rel="noopener">http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/</a></p><p>Sequence to Sequence Models (tensorflow.org)<br><a href="https://www.tensorflow.org/tutorials/seq2seq" target="_blank" rel="noopener">https://www.tensorflow.org/tutorials/seq2seq</a></p><p>Sequence to Sequence Learning with Neural Networks (NIPS 2014)<br><a href="https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf" target="_blank" rel="noopener">https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf</a></p><p>Machine Learning is Fun Part 5: Language Translation with Deep Learning and the Magic of Sequences (medium.com/@ageitgey)<br><a href="https://medium.com/@ageitgey/machine-learning-is-fun-part-5-language-translation-with-deep-learning-and-the-magic-of-sequences-2ace0acca0aa" target="_blank" rel="noopener">https://medium.com/@ageitgey/machine-learning-is-fun-part-5-language-translation-with-deep-learning-and-the-magic-of-sequences-2ace0acca0aa</a></p><p>tf-seq2seq (google.github.io)<br><a href="https://google.github.io/seq2seq/" target="_blank" rel="noopener">https://google.github.io/seq2seq/</a></p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Machine Learning Crash Course (google.com)<br><a href="https://developers.google.com/machine-learning/crash-course/" target="_blank" rel="noopener">https://developers.google.com/machine-learning/crash-course/</a></p><p>Awesome Machine Learning (github.com/josephmisiti)<br><a href="https://github.com/josephmisiti/awesome-machine-learning#python" target="_blank" rel="noopener">https://github.com/josephmisiti/awesome-machine-learning#python</a></p><p>7 Steps to Mastering Machine Learning With Python (kdnuggets.com)<br><a href="http://www.kdnuggets.com/2015/11/seven-steps-machine-learning-python.html" target="_blank" rel="noopener">http://www.kdnuggets.com/2015/11/seven-steps-machine-learning-python.html</a></p><p>An example machine learning notebook (nbviewer.jupyter.org)<br><a href="http://nbviewer.jupyter.org/github/rhiever/Data-Analysis-and-Machine-Learning-Projects/blob/master/example-data-science-notebook/Example%20Machine%20Learning%20Notebook.ipynb" target="_blank" rel="noopener">http://nbviewer.jupyter.org/github/rhiever/Data-Analysis-and-Machine-Learning-Projects/blob/master/example-data-science-notebook/Example%20Machine%20Learning%20Notebook.ipynb</a></p><p>Machine Learning with Python (tutorialspoint.com)<br><a href="https://www.tutorialspoint.com/machine_learning_with_python/machine_learning_with_python_quick_guide.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/machine_learning_with_python/machine_learning_with_python_quick_guide.htm</a></p><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><p>How To Implement The Perceptron Algorithm From Scratch In Python(machinelearningmastery.com)<br><a href="http://machinelearningmastery.com/implement-perceptron-algorithm-scratch-python/" target="_blank" rel="noopener">http://machinelearningmastery.com/implement-perceptron-algorithm-scratch-python/</a></p><p>Implementing a Neural Network from Scratch in Python (wildml.com)<br><a href="http://www.wildml.com/2015/09/implementing-a-neural-network-from-scratch/" target="_blank" rel="noopener">http://www.wildml.com/2015/09/implementing-a-neural-network-from-scratch/</a></p><p>A Neural Network in 11 lines of Python (iamtrask.github.io)<br><a href="http://iamtrask.github.io/2015/07/12/basic-python-network/" target="_blank" rel="noopener">http://iamtrask.github.io/2015/07/12/basic-python-network/</a></p><p>Implementing Your Own k-Nearest Neighbour Algorithm Using Python(kdnuggets.com)<br><a href="http://www.kdnuggets.com/2016/01/implementing-your-own-knn-using-python.html" target="_blank" rel="noopener">http://www.kdnuggets.com/2016/01/implementing-your-own-knn-using-python.html</a></p><p>ML from Scatch (github.com/eriklindernoren)<br><a href="https://github.com/eriklindernoren/ML-From-Scratch" target="_blank" rel="noopener">https://github.com/eriklindernoren/ML-From-Scratch</a></p><p>Python Machine Learning (2nd Ed.) Code Repository (github.com/rasbt)<br><a href="https://github.com/rasbt/python-machine-learning-book-2nd-edition" target="_blank" rel="noopener">https://github.com/rasbt/python-machine-learning-book-2nd-edition</a></p><h3 id="Scipy-and-numpy"><a href="#Scipy-and-numpy" class="headerlink" title="Scipy and numpy"></a>Scipy and numpy</h3><p>Scipy Lecture Notes (scipy-lectures.org)<br><a href="http://www.scipy-lectures.org/" target="_blank" rel="noopener">http://www.scipy-lectures.org/</a></p><p>Python Numpy Tutorial (Stanford CS231n)<br><a href="http://cs231n.github.io/python-numpy-tutorial/" target="_blank" rel="noopener">http://cs231n.github.io/python-numpy-tutorial/</a></p><p>An introduction to Numpy and Scipy (UCSB CHE210D)<br><a href="https://engineering.ucsb.edu/~shell/che210d/numpy.pdf" target="_blank" rel="noopener">https://engineering.ucsb.edu/~shell/che210d/numpy.pdf</a></p><p>A Crash Course in Python for Scientists (nbviewer.jupyter.org)<br><a href="http://nbviewer.jupyter.org/gist/rpmuller/5920182#ii.-numpy-and-scipy" target="_blank" rel="noopener">http://nbviewer.jupyter.org/gist/rpmuller/5920182#ii.-numpy-and-scipy</a></p><h3 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a>scikit-learn</h3><p>PyCon scikit-learn Tutorial Index (nbviewer.jupyter.org)<br><a href="http://nbviewer.jupyter.org/github/jakevdp/sklearn_pycon2015/blob/master/notebooks/Index.ipynb" target="_blank" rel="noopener">http://nbviewer.jupyter.org/github/jakevdp/sklearn_pycon2015/blob/master/notebooks/Index.ipynb</a></p><p>scikit-learn Classification Algorithms (github.com/mmmayo13)<br><a href="https://github.com/mmmayo13/scikit-learn-classifiers/blob/master/sklearn-classifiers-tutorial.ipynb" target="_blank" rel="noopener">https://github.com/mmmayo13/scikit-learn-classifiers/blob/master/sklearn-classifiers-tutorial.ipynb</a></p><p>scikit-learn Tutorials (scikit-learn.org)<br><a href="http://scikit-learn.org/stable/tutorial/index.html" target="_blank" rel="noopener">http://scikit-learn.org/stable/tutorial/index.html</a></p><p>Abridged scikit-learn Tutorials (github.com/mmmayo13)<br><a href="https://github.com/mmmayo13/scikit-learn-beginners-tutorials" target="_blank" rel="noopener">https://github.com/mmmayo13/scikit-learn-beginners-tutorials</a></p><h3 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h3><p>Tensorflow Tutorials (tensorflow.org)<br><a href="https://www.tensorflow.org/tutorials/" target="_blank" rel="noopener">https://www.tensorflow.org/tutorials/</a></p><p>Introduction to TensorFlow — CPU vs GPU (medium.com/@erikhallstrm)<br><a href="https://medium.com/@erikhallstrm/hello-world-tensorflow-649b15aed18c" target="_blank" rel="noopener">https://medium.com/@erikhallstrm/hello-world-tensorflow-649b15aed18c</a></p><p>TensorFlow: A primer (metaflow.fr)<br><a href="https://blog.metaflow.fr/tensorflow-a-primer-4b3fa0978be3" target="_blank" rel="noopener">https://blog.metaflow.fr/tensorflow-a-primer-4b3fa0978be3</a></p><p>RNNs in Tensorflow (wildml.com)<br><a href="http://www.wildml.com/2016/08/rnns-in-tensorflow-a-practical-guide-and-undocumented-features/" target="_blank" rel="noopener">http://www.wildml.com/2016/08/rnns-in-tensorflow-a-practical-guide-and-undocumented-features/</a></p><p>Implementing a CNN for Text Classification in TensorFlow (wildml.com)<br><a href="http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/" target="_blank" rel="noopener">http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/</a></p><p>How to Run Text Summarization with TensorFlow (surmenok.com)<br><a href="http://pavel.surmenok.com/2016/10/15/how-to-run-text-summarization-with-tensorflow/" target="_blank" rel="noopener">http://pavel.surmenok.com/2016/10/15/how-to-run-text-summarization-with-tensorflow/</a></p><h3 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h3><p>PyTorch Tutorials (pytorch.org)<br><a href="http://pytorch.org/tutorials/" target="_blank" rel="noopener">http://pytorch.org/tutorials/</a></p><p>A Gentle Intro to PyTorch (gaurav.im)<br><a href="http://blog.gaurav.im/2017/04/24/a-gentle-intro-to-pytorch/" target="_blank" rel="noopener">http://blog.gaurav.im/2017/04/24/a-gentle-intro-to-pytorch/</a></p><p>Tutorial: Deep Learning in PyTorch (iamtrask.github.io)<br><a href="https://iamtrask.github.io/2017/01/15/pytorch-tutorial/" target="_blank" rel="noopener">https://iamtrask.github.io/2017/01/15/pytorch-tutorial/</a></p><p>PyTorch Examples (github.com/jcjohnson)<br><a href="https://github.com/jcjohnson/pytorch-examples" target="_blank" rel="noopener">https://github.com/jcjohnson/pytorch-examples</a></p><p>PyTorch Tutorial (github.com/MorvanZhou)<br><a href="https://github.com/MorvanZhou/PyTorch-Tutorial" target="_blank" rel="noopener">https://github.com/MorvanZhou/PyTorch-Tutorial</a></p><p>PyTorch Tutorial for Deep Learning Researchers (github.com/yunjey)<br><a href="https://github.com/yunjey/pytorch-tutorial" target="_blank" rel="noopener">https://github.com/yunjey/pytorch-tutorial</a></p><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>Math for Machine Learning (ucsc.edu)<br><a href="https://people.ucsc.edu/~praman1/static/pub/math-for-ml.pdf" target="_blank" rel="noopener">https://people.ucsc.edu/~praman1/static/pub/math-for-ml.pdf</a></p><p>Math for Machine Learning (UMIACS CMSC422)<br><a href="http://www.umiacs.umd.edu/~hal/courses/2013S_ML/math4ml.pdf" target="_blank" rel="noopener">http://www.umiacs.umd.edu/~hal/courses/2013S_ML/math4ml.pdf</a></p><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>An Intuitive Guide to Linear Algebra (betterexplained.com)<br><a href="https://betterexplained.com/articles/linear-algebra-guide/" target="_blank" rel="noopener">https://betterexplained.com/articles/linear-algebra-guide/</a></p><p>A Programmer’s Intuition for Matrix Multiplication (betterexplained.com)<br><a href="https://betterexplained.com/articles/matrix-multiplication/" target="_blank" rel="noopener">https://betterexplained.com/articles/matrix-multiplication/</a></p><p>Understanding the Cross Product (betterexplained.com)<br><a href="https://betterexplained.com/articles/cross-product/" target="_blank" rel="noopener">https://betterexplained.com/articles/cross-product/</a></p><p>Understanding the Dot Product (betterexplained.com)<br><a href="https://betterexplained.com/articles/vector-calculus-understanding-the-dot-product/" target="_blank" rel="noopener">https://betterexplained.com/articles/vector-calculus-understanding-the-dot-product/</a></p><p>Linear Algebra for Machine Learning (U. of Buffalo CSE574)<br><a href="http://www.cedar.buffalo.edu/~srihari/CSE574/Chap1/LinearAlgebra.pdf" target="_blank" rel="noopener">http://www.cedar.buffalo.edu/~srihari/CSE574/Chap1/LinearAlgebra.pdf</a></p><p>Linear algebra cheat sheet for deep learning (medium.com)<br><a href="https://medium.com/towards-data-science/linear-algebra-cheat-sheet-for-deep-learning-cd67aba4526c" target="_blank" rel="noopener">https://medium.com/towards-data-science/linear-algebra-cheat-sheet-for-deep-learning-cd67aba4526c</a></p><p>Linear Algebra Review and Reference (Stanford CS229)<br><a href="http://cs229.stanford.edu/section/cs229-linalg.pdf" target="_blank" rel="noopener">http://cs229.stanford.edu/section/cs229-linalg.pdf</a></p><h3 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h3><p>Understanding Bayes Theorem With Ratios (betterexplained.com)<br><a href="https://betterexplained.com/articles/understanding-bayes-theorem-with-ratios/" target="_blank" rel="noopener">https://betterexplained.com/articles/understanding-bayes-theorem-with-ratios/</a></p><p>Review of Probability Theory (Stanford CS229)<br><a href="http://cs229.stanford.edu/section/cs229-prob.pdf" target="_blank" rel="noopener">http://cs229.stanford.edu/section/cs229-prob.pdf</a></p><p>Probability Theory Review for Machine Learning (Stanford CS229)<br><a href="https://see.stanford.edu/materials/aimlcs229/cs229-prob.pdf" target="_blank" rel="noopener">https://see.stanford.edu/materials/aimlcs229/cs229-prob.pdf</a></p><p>Probability Theory (U. of Buffalo CSE574)<br><a href="http://www.cedar.buffalo.edu/~srihari/CSE574/Chap1/Probability-Theory.pdf" target="_blank" rel="noopener">http://www.cedar.buffalo.edu/~srihari/CSE574/Chap1/Probability-Theory.pdf</a></p><p>Probability Theory for Machine Learning (U. of Toronto CSC411)<br><a href="http://www.cs.toronto.edu/~urtasun/courses/CSC411_Fall16/tutorial1.pdf" target="_blank" rel="noopener">http://www.cs.toronto.edu/~urtasun/courses/CSC411_Fall16/tutorial1.pdf</a></p><h3 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h3><p>How To Understand Derivatives: The Quotient Rule, Exponents, and Logarithms (betterexplained.com)<br><a href="https://betterexplained.com/articles/how-to-understand-derivatives-the-quotient-rule-exponents-and-logarithms/" target="_blank" rel="noopener">https://betterexplained.com/articles/how-to-understand-derivatives-the-quotient-rule-exponents-and-logarithms/</a></p><p>How To Understand Derivatives: The Product, Power &amp; Chain Rules(betterexplained.com)<br><a href="https://betterexplained.com/articles/derivatives-product-power-chain/" target="_blank" rel="noopener">https://betterexplained.com/articles/derivatives-product-power-chain/</a></p><p>Vector Calculus: Understanding the Gradient (betterexplained.com)<br><a href="https://betterexplained.com/articles/vector-calculus-understanding-the-gradient/" target="_blank" rel="noopener">https://betterexplained.com/articles/vector-calculus-understanding-the-gradient/</a></p><p>Differential Calculus (Stanford CS224n)<br><a href="http://web.stanford.edu/class/cs224n/lecture_notes/cs224n-2017-review-differential-calculus.pdf" target="_blank" rel="noopener">http://web.stanford.edu/class/cs224n/lecture_notes/cs224n-2017-review-differential-calculus.pdf</a></p><p>Calculus Overview (readthedocs.io)<br><a href="http://ml-cheatsheet.readthedocs.io/en/latest/calculus.html" target="_blank" rel="noopener">http://ml-cheatsheet.readthedocs.io/en/latest/calculus.html</a></p><p>相关报道：<br><a href="https://medium.com/machine-learning-in-practice/over-200-of-the-best-machine-learning-nlp-and-python-tutorials-2018-edition-dd8cf53cb7dc" target="_blank" rel="noopener">https://medium.com/machine-learning-in-practice/over-200-of-the-best-machine-learning-nlp-and-python-tutorials-2018-edition-dd8cf53cb7dc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章分为了四个部分：机器学习，自然语言处理，python和数学。在每个部分中我都列举了一些主题，但是因为材料的数量庞大，我不可能涉及到每一个主题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="线路图" scheme="http://yoursite.com/tags/%E7%BA%BF%E8%B7%AF%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议入门</title>
    <link href="http://yoursite.com/2019/09/10/HTTP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/09/10/HTTP协议入门/</id>
    <published>2019-09-10T13:20:47.000Z</published>
    <updated>2019-09-10T13:42:09.575Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#一-基础概念">一 、基础概念</a><ul><li><a href="#url">URL</a></li><li><a href="#请求和响应报文">请求和响应报文</a></li></ul></li><li><a href="#二http-方法">二、HTTP 方法</a><ul><li><a href="#get">GET</a></li><li><a href="#head">HEAD</a></li><li><a href="#post">POST</a></li><li><a href="#put">PUT</a><a id="more"></a></li><li><a href="#patch">PATCH</a></li><li><a href="#delete">DELETE</a></li><li><a href="#options">OPTIONS</a></li><li><a href="#connect">CONNECT</a></li><li><a href="#trace">TRACE</a></li></ul></li><li><a href="#三http-状态码">三、HTTP 状态码</a><ul><li><a href="#1xx-信息">1XX 信息</a></li><li><a href="#2xx-成功">2XX 成功</a></li><li><a href="#3xx-重定向">3XX 重定向</a></li><li><a href="#4xx-客户端错误">4XX 客户端错误</a></li><li><a href="#5xx-服务器错误">5XX 服务器错误</a></li></ul></li><li><a href="#四http-首部">四、HTTP 首部</a><ul><li><a href="#通用首部字段">通用首部字段</a></li><li><a href="#请求首部字段">请求首部字段</a></li><li><a href="#响应首部字段">响应首部字段</a></li><li><a href="#实体首部字段">实体首部字段</a></li></ul></li><li><a href="#五具体应用">五、具体应用</a><ul><li><a href="#cookie">Cookie</a></li><li><a href="#缓存">缓存</a></li><li><a href="#连接管理">连接管理</a></li><li><a href="#内容协商">内容协商</a></li><li><a href="#内容编码">内容编码</a></li><li><a href="#范围请求">范围请求</a></li><li><a href="#分块传输编码">分块传输编码</a></li><li><a href="#多部分对象集合">多部分对象集合</a></li><li><a href="#虚拟主机">虚拟主机</a></li><li><a href="#通信数据转发">通信数据转发</a></li></ul></li><li><a href="#六https">六、HTTPs</a><ul><li><a href="#加密">加密</a></li><li><a href="#认证">认证</a></li><li><a href="#完整性保护">完整性保护</a></li><li><a href="#https-的缺点">HTTPs 的缺点</a></li><li><a href="#配置-https">配置 HTTPs</a></li></ul></li><li><a href="#七http20">七、HTTP/2.0</a><ul><li><a href="#http1x-缺陷">HTTP/1.x 缺陷</a></li><li><a href="#二进制分帧层">二进制分帧层</a></li><li><a href="#服务端推送">服务端推送</a></li><li><a href="#首部压缩">首部压缩</a></li></ul></li><li><a href="#八get-和-post-的区别">八、GET 和 POST 的区别</a><ul><li><a href="#作用">作用</a></li><li><a href="#参数">参数</a></li><li><a href="#安全">安全</a></li><li><a href="#幂等性">幂等性</a></li><li><a href="#可缓存">可缓存</a></li><li><a href="#xmlhttprequest">XMLHttpRequest</a></li></ul></li><li><a href="#九http10-与-http11-的区别">九、HTTP/1.0 与 HTTP/1.1 的区别</a></li><li><a href="#参考资料">参考资料</a><h1 id="一-、基础概念"><a href="#一-、基础概念" class="headerlink" title="一 、基础概念"></a>一 、基础概念</h1></li></ul><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li>URI（Uniform Resource Identifier，统一资源标识符）</li><li>URL（Uniform Resource Locator，统一资源定位符）</li><li>URN（Uniform Resource Name，统一资源名称），例如 urn:isbn:0-486-27557-4。</li></ul><p>URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。<br><img src="..%5Cpics%5Cf716427a-94f2-4875-9c86-98793cf5dcc3.jpg" alt></p><h2 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h2><h3 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1. 请求报文"></a>1. 请求报文</h3><p><img src="..%5Cpics%5CHTTP_RequestMessageExample.png" alt></p><h3 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2. 响应报文"></a>2. 响应报文</h3><p><img src="..%5Cpics%5CHTTP_ResponseMessageExample.png" alt></p><h1 id="二、HTTP-方法"><a href="#二、HTTP-方法" class="headerlink" title="二、HTTP 方法"></a>二、HTTP 方法</h1><p>客户端发送的  <strong>请求报文</strong>  第一行为请求行，包含了方法字段。</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><blockquote><p>获取资源</p></blockquote><p>当前网络请求中，绝大部分使用的是 GET 方法。</p><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><blockquote><p>获取报文首部</p></blockquote><p>和 GET 方法一样，但是不返回报文实体主体部分。</p><p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><blockquote><p>传输实体主体</p></blockquote><p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><p>更多 POST 与 GET 的比较请见第八章。</p><h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><blockquote><p>上传文件</p></blockquote><p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>New File<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h2><blockquote><p>对资源进行部分修改</p></blockquote><p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PATCH /file.txt HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/example</span><br><span class="line">If-Match: "e0023aa4e"</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><blockquote><p>删除文件</p></blockquote><p>与 PUT 功能相反，并且同样不带验证机制。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /file.html HTTP/1.1</span><br></pre></td></tr></table></figure><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><blockquote><p>查询支持的方法</p></blockquote><p>查询指定的 URL 能够支持的方法。</p><p>会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。</p><h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><blockquote><p>要求在与代理服务器通信时建立隧道</p></blockquote><p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP/1.1</span><br></pre></td></tr></table></figure><p><img src="..%5Cpics%5Cdc00f70e-c5c8-4d20-baf1-2d70014a97e3.jpg" alt></p><h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><blockquote><p>追踪路径</p></blockquote><p>服务器会将通信路径返回给客户端。</p><p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p><p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p><h1 id="三、HTTP-状态码"><a href="#三、HTTP-状态码" class="headerlink" title="三、HTTP 状态码"></a>三、HTTP 状态码</h1><p>服务器返回的  <strong>响应报文</strong>  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th align="center">状态码</th><th align="center">类别</th><th align="center">原因短语</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">Informational（信息性状态码）</td><td align="center">接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">Success（成功状态码）</td><td align="center">请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">Redirection（重定向状态码）</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">Client Error（客户端错误状态码）</td><td align="center">服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">Server Error（服务器错误状态码）</td><td align="center">服务器处理请求出错</td></tr></tbody></table><h2 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h2><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul><li><p><strong>200 OK</strong> </p></li><li><p><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p></li><li><p><strong>206 Partial Content</strong> ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。</p></li></ul><h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul><li><p><strong>301 Moved Permanently</strong> ：永久性重定向</p></li><li><p><strong>302 Found</strong> ：临时性重定向</p></li><li><p><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p></li><li><p>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p></li><li><p><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p></li><li><p><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p></li></ul><h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul><li><p><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</p></li><li><p><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p></li><li><p><strong>403 Forbidden</strong> ：请求被拒绝，服务器端没有必要给出拒绝的详细理由。</p></li><li><p><strong>404 Not Found</strong> </p></li></ul><h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul><li><p><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</p></li><li><p><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p></li></ul><h1 id="四、HTTP-首部"><a href="#四、HTTP-首部" class="headerlink" title="四、HTTP 首部"></a>四、HTTP 首部</h1><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p><p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p><h2 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h2><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">控制缓存的行为</td></tr><tr><td align="center">Connection</td><td align="center">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td align="center">Date</td><td align="center">创建报文的日期时间</td></tr><tr><td align="center">Pragma</td><td align="center">报文指令</td></tr><tr><td align="center">Trailer</td><td align="center">报文末端的首部一览</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">指定报文主体的传输编码方式</td></tr><tr><td align="center">Upgrade</td><td align="center">升级为其他协议</td></tr><tr><td align="center">Via</td><td align="center">代理服务器的相关信息</td></tr><tr><td align="center">Warning</td><td align="center">错误通知</td></tr></tbody></table><h2 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h2><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">用户代理可处理的媒体类型</td></tr><tr><td align="center">Accept-Charset</td><td align="center">优先的字符集</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">优先的内容编码</td></tr><tr><td align="center">Accept-Language</td><td align="center">优先的语言（自然语言）</td></tr><tr><td align="center">Authorization</td><td align="center">Web 认证信息</td></tr><tr><td align="center">Expect</td><td align="center">期待服务器的特定行为</td></tr><tr><td align="center">From</td><td align="center">用户的电子邮箱地址</td></tr><tr><td align="center">Host</td><td align="center">请求资源所在服务器</td></tr><tr><td align="center">If-Match</td><td align="center">比较实体标记（ETag）</td></tr><tr><td align="center">If-Modified-Since</td><td align="center">比较资源的更新时间</td></tr><tr><td align="center">If-None-Match</td><td align="center">比较实体标记（与 If-Match 相反）</td></tr><tr><td align="center">If-Range</td><td align="center">资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td align="center">If-Unmodified-Since</td><td align="center">比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td align="center">Max-Forwards</td><td align="center">最大传输逐跳数</td></tr><tr><td align="center">Proxy-Authorization</td><td align="center">代理服务器要求客户端的认证信息</td></tr><tr><td align="center">Range</td><td align="center">实体的字节范围请求</td></tr><tr><td align="center">Referer</td><td align="center">对请求中 URI 的原始获取方</td></tr><tr><td align="center">TE</td><td align="center">传输编码的优先级</td></tr><tr><td align="center">User-Agent</td><td align="center">HTTP 客户端程序的信息</td></tr></tbody></table><h2 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h2><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept-Ranges</td><td align="center">是否接受字节范围请求</td></tr><tr><td align="center">Age</td><td align="center">推算资源创建经过时间</td></tr><tr><td align="center">ETag</td><td align="center">资源的匹配信息</td></tr><tr><td align="center">Location</td><td align="center">令客户端重定向至指定 URI</td></tr><tr><td align="center">Proxy-Authenticate</td><td align="center">代理服务器对客户端的认证信息</td></tr><tr><td align="center">Retry-After</td><td align="center">对再次发起请求的时机要求</td></tr><tr><td align="center">Server</td><td align="center">HTTP 服务器的安装信息</td></tr><tr><td align="center">Vary</td><td align="center">代理服务器缓存的管理信息</td></tr><tr><td align="center">WWW-Authenticate</td><td align="center">服务器对客户端的认证信息</td></tr></tbody></table><h2 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h2><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="center">资源可支持的 HTTP 方法</td></tr><tr><td align="center">Content-Encoding</td><td align="center">实体主体适用的编码方式</td></tr><tr><td align="center">Content-Language</td><td align="center">实体主体的自然语言</td></tr><tr><td align="center">Content-Length</td><td align="center">实体主体的大小</td></tr><tr><td align="center">Content-Location</td><td align="center">替代对应资源的 URI</td></tr><tr><td align="center">Content-MD5</td><td align="center">实体主体的报文摘要</td></tr><tr><td align="center">Content-Range</td><td align="center">实体主体的位置范围</td></tr><tr><td align="center">Content-Type</td><td align="center">实体主体的媒体类型</td></tr><tr><td align="center">Expires</td><td align="center">实体主体过期的日期时间</td></tr><tr><td align="center">Last-Modified</td><td align="center">资源的最后修改日期时间</td></tr></tbody></table><h1 id="五、具体应用"><a href="#五、具体应用" class="headerlink" title="五、具体应用"></a>五、具体应用</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB。</p><h3 id="1-用途"><a href="#1-用途" class="headerlink" title="1. 用途"></a>1. 用途</h3><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="2-创建过程"><a href="#2-创建过程" class="headerlink" title="2. 创建过程"></a>2. 创建过程</h3><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中读出 Cookie 信息通过 Cookie 请求首部字段发送给服务器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><h3 id="3-分类"><a href="#3-分类" class="headerlink" title="3. 分类"></a>3. 分类</h3><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure><h3 id="4-JavaScript-获取-Cookie"><a href="#4-JavaScript-获取-Cookie" class="headerlink" title="4. JavaScript 获取 Cookie"></a>4. JavaScript 获取 Cookie</h3><p>通过 <code>Document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = "yummy_cookie=choco";</span><br><span class="line">document.cookie = "tasty_cookie=strawberry";</span><br><span class="line">console.log(document.cookie);</span><br></pre></td></tr></table></figure><h3 id="5-Secure-和-HttpOnly"><a href="#5-Secure-和-HttpOnly" class="headerlink" title="5. Secure 和 HttpOnly"></a>5. Secure 和 HttpOnly</h3><p>标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。因为跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>Document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><h3 id="6-作用域"><a href="#6-作用域" class="headerlink" title="6. 作用域"></a>6. 作用域</h3><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p><ul><li>/docs</li><li>/docs/Web/</li><li>/docs/Web/HTTP</li></ul><h3 id="7-Session"><a href="#7-Session" class="headerlink" title="7. Session"></a>7. Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在内存型数据库中，比如 Redis。</p><p>使用 Session 维护用户登录的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码；</li><li>如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 ID 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之后的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h3 id="8-浏览器禁用-Cookie"><a href="#8-浏览器禁用-Cookie" class="headerlink" title="8. 浏览器禁用 Cookie"></a>8. 浏览器禁用 Cookie</h3><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p><h3 id="9-Cookie-与-Session-选择"><a href="#9-Cookie-与-Session-选择" class="headerlink" title="9. Cookie 与 Session 选择"></a>9. Cookie 与 Session 选择</h3><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟（缓存资源比服务器上的资源离客户端更近）。</li></ul><h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h3><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul><h3 id="3-Cache-Control"><a href="#3-Cache-Control" class="headerlink" title="3. Cache-Control"></a>3. Cache-Control</h3><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p><p><strong>（一）禁止进行缓存</strong> </p><p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure><p><strong>（二）强制确认缓存</strong> </p><p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效才将能使用该缓存对客户端的请求进行响应。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p><strong>（三）私有缓存和公共缓存</strong> </p><p>private 指令规定了将资源作为私有缓存，只能被单独用户所使用，一般存储在用户浏览器中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure><p>public 指令规定了将资源作为公共缓存，可以被多个用户所使用，一般存储在代理服务器中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure><p><strong>（四）缓存过期机制</strong> </p><p>max-age 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p>max-age 指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure><p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。在 HTTP/1.1 中，会优先处理 Cache-Control : max-age 指令；而在 HTTP/1.0 中，Cache-Control : max-age 指令会被忽略掉。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><h3 id="4-缓存验证"><a href="#4-缓存验证" class="headerlink" title="4. 缓存验证"></a>4. 缓存验证</h3><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></table></figure><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></table></figure><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 Not Modified 响应。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p><img src="..%5Cpics%5CHTTP1_x_Connections.png" alt></p><h3 id="1-短连接与长连接"><a href="#1-短连接与长连接" class="headerlink" title="1. 短连接与长连接"></a>1. 短连接与长连接</h3><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源，如果每进行一次 HTTP 通信就要断开一次 TCP 连接，连接建立和断开的开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><p>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；而在 HTTP/1.1 之前默认是短连接的，如果需要长连接，则使用 Connection : Keep-Alive。</p><h3 id="2-流水线"><a href="#2-流水线" class="headerlink" title="2. 流水线"></a>2. 流水线</h3><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到相应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。</p><h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p><h3 id="1-类型"><a href="#1-类型" class="headerlink" title="1. 类型"></a>1. 类型</h3><p><strong>（一）服务端驱动型内容协商</strong> </p><p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Languag，服务器根据这些字段返回特定的资源。</p><p>它存在以下问题：</p><ul><li>服务器很难知道客户端浏览器的全部信息；</li><li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）。</li><li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li></ul><p><strong>（二）代理驱动型协商</strong> </p><p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p><h3 id="2-Vary"><a href="#2-Vary" class="headerlink" title="2. Vary"></a>2. Vary</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure><p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p><p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p><h2 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h2><p>内容编码将实体主体进行压缩，从而减少传输的数据量。常用的内容编码有：gzip、compress、deflate、identity。</p><p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级，服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，在响应中，Vary 首部中至少要包含 Content-Encoding，这样的话，缓存服务器就可以对资源的不同展现形式进行缓存。</p><h2 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h2><p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p><h3 id="1-Range"><a href="#1-Range" class="headerlink" title="1. Range"></a>1. Range</h3><p>在请求报文中添加 Range 首部字段指定请求的范围。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /z4d4kWk.jpg HTTP/1.1</span><br><span class="line">Host: i.imgur.com</span><br><span class="line">Range: bytes=0-1023</span><br></pre></td></tr></table></figure><p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Range: bytes 0-1023/146515</span><br><span class="line">Content-Length: 1024</span><br><span class="line">...</span><br><span class="line">(binary content)</span><br></pre></td></tr></table></figure><h3 id="2-Accept-Ranges"><a href="#2-Accept-Ranges" class="headerlink" title="2. Accept-Ranges"></a>2. Accept-Ranges</h3><p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><h3 id="3-响应状态码"><a href="#3-响应状态码" class="headerlink" title="3. 响应状态码"></a>3. 响应状态码</h3><ul><li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li><li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li><li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li></ul><h2 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h2><p>Chunked Transfer Coding，可以把数据分割成多块，让浏览器逐步显示页面。</p><h2 id="多部分对象集合"><a href="#多部分对象集合" class="headerlink" title="多部分对象集合"></a>多部分对象集合</h2><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p><p>例如，上传多个表单时可以使用如下方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name="submit-name"</span><br><span class="line"></span><br><span class="line">Larry</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name="files"; filename="file1.txt"</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">... contents of file1.txt ...</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure><h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p><h2 id="通信数据转发"><a href="#通信数据转发" class="headerlink" title="通信数据转发"></a>通信数据转发</h2><h3 id="1-代理"><a href="#1-代理" class="headerlink" title="1. 代理"></a>1. 代理</h3><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p><p>使用代理的主要目的是：</p><ul><li>缓存</li><li>负载均衡</li><li>网络访问控制</li><li>访问日志记录</li></ul><p>代理服务器分为正向代理和反向代理两种，用户察觉得到正向代理的存在；而反向代理一般位于内部网络中，用户察觉不到。<br><img src="..%5Cpics%5Ca314bb79-5b18-4e63-a976-3448bffa6f1b.png" alt><br><img src="..%5Cpics%5C2d09a847-b854-439c-9198-b29c65810944.png" alt></p><h3 id="2-网关"><a href="#2-网关" class="headerlink" title="2. 网关"></a>2. 网关</h3><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p><h3 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3. 隧道"></a>3. 隧道</h3><p>使用 SSL 等加密手段，为客户端和服务器之间建立一条安全的通信线路。</p><h1 id="六、HTTPs"><a href="#六、HTTPs" class="headerlink" title="六、HTTPs"></a>六、HTTPs</h1><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPs 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。<br><img src="..%5Cpics%5Cssl-offloading.jpg" alt></p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="1-对称密钥加密"><a href="#1-对称密钥加密" class="headerlink" title="1. 对称密钥加密"></a>1. 对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。<br><img src="..%5Cpics%5C7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" alt></li></ul><h3 id="2-非对称密钥加密"><a href="#2-非对称密钥加密" class="headerlink" title="2.非对称密钥加密"></a>2.非对称密钥加密</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。<br><img src="..%5Cpics%5C39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" alt></li></ul><h3 id="3-HTTPs-采用的加密方式"><a href="#3-HTTPs-采用的加密方式" class="headerlink" title="3. HTTPs 采用的加密方式"></a>3. HTTPs 采用的加密方式</h3><p>HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证安全性，之后使用对称密钥加密进行通信来保证效率。（下图中的 Session Key 就是对称密钥）<br><img src="..%5Cpics%5CHow-HTTPS-Works.png" alt></p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>通过使用  <strong>证书</strong>  来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPs 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p>通信开始时，客户端需要使用服务器的公开密钥将自己的私有密钥传输给服务器，之后再进行对称密钥加密。<br><img src="..%5Cpics%5C2017-06-11-ca.png" alt></p><h2 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h2><p>SSL 提供报文摘要功能来进行完整性保护。</p><p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p><p>HTTPs 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h2 id="HTTPs-的缺点"><a href="#HTTPs-的缺点" class="headerlink" title="HTTPs 的缺点"></a>HTTPs 的缺点</h2><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高费用。</li></ul><h2 id="配置-HTTPs"><a href="#配置-HTTPs" class="headerlink" title="配置 HTTPs"></a>配置 HTTPs</h2><p><a href="https://aotu.io/notes/2016/08/16/nginx-https/index.html" target="_blank" rel="noopener">Nginx 配置 HTTPS 服务器</a></p><h1 id="七、HTTP-2-0"><a href="#七、HTTP-2-0" class="headerlink" title="七、HTTP/2.0"></a>七、HTTP/2.0</h1><h2 id="HTTP-1-x-缺陷"><a href="#HTTP-1-x-缺陷" class="headerlink" title="HTTP/1.x 缺陷"></a>HTTP/1.x 缺陷</h2><p> HTTP/1.x 实现简单是以牺牲应用性能为代价的：</p><ul><li>客户端需要使用多个连接才能实现并发和缩短延迟；</li><li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li><li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li></ul><h2 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h2><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。<br><img src="..%5Cpics%5C86e6a91d-a285-447a-9345-c5484b8d0c47.png" alt></p><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。一个数据流都有一个唯一标识符和可选的优先级信息，用于承载双向信息。消息（Message）是与逻辑请求或响应消息对应的完整的一系列帧。帧（Fram）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。<br><img src="..%5Cpics%5Caf198da1-2480-4043-b07f-a3b91a88b815.png" alt></p><h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。<br><img src="..%5Cpics%5Ce3f1657c-80fc-4dfa-9643-bf51abd201c6.png" alt></p><h2 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h2><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。<br><img src="..%5Cpics%5C_u4E0B_u8F7D.png" alt></p><h1 id="八、GET-和-POST-的区别"><a href="#八、GET-和-POST-的区别" class="headerlink" title="八、GET 和 POST 的区别"></a>八、GET 和 POST 的区别</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /test/demo_form.asp HTTP/1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><p>不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码，例如<code>中文</code>会转换为<code>%E4%B8%AD%E6%96%87</code>，而空格会转换为<code>%20</code>。POST 支持标准字符集。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。所有的安全方法也都是幂等的。</p><p>GET /pageX HTTP/1.1 是幂等的。连续调用多次，客户端接收到的结果都是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br></pre></td></tr></table></figure><p>POST /add_row HTTP/1.1 不是幂等的。如果调用多次，就会增加多行记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 1nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure><p>DELETE /idX/delete HTTP/1.1 是幂等的，即便不同的请求接收到的状态码不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure><h2 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h2><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><p>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。而 GET 方法 Header 和 Data 会一起发送。</p><h1 id="九、HTTP-1-0-与-HTTP-1-1-的区别"><a href="#九、HTTP-1-0-与-HTTP-1-1-的区别" class="headerlink" title="九、HTTP/1.0 与 HTTP/1.1 的区别"></a>九、HTTP/1.0 与 HTTP/1.1 的区别</h1><blockquote><p>详细内容请见上文</p></blockquote><ul><li><p>HTTP/1.1 默认是长连接</p></li><li><p>HTTP/1.1 支持管线化处理</p></li><li><p>HTTP/1.1 支持同时打开多个 TCP 连接</p></li><li><p>HTTP/1.1 支持虚拟主机</p></li><li><p>HTTP/1.1 新增状态码 100</p></li><li><p>HTTP/1.1 支持分块传输编码</p></li><li><p>HTTP/1.1 新增缓存处理指令 max-age</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">MDN : HTTP</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">HTTP/2 简介</a></li><li><a href="http://php.net/manual/zh/function.htmlspecialchars.php" target="_blank" rel="noopener">htmlspecialchars</a></li><li><a href="https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement" target="_blank" rel="noopener">How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement</a></li><li><a href="https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="noopener">浅谈 HTTP 中 Get 与 Post 的区别</a></li><li><a href="https://www.webdancers.com/are-http-and-www-necesary/" target="_blank" rel="noopener">Are http:// and www really necessary?</a></li><li><a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html" target="_blank" rel="noopener">HTTP (HyperText Transfer Protocol)</a></li><li><a href="https://www.igvita.com/2011/12/01/web-vpn-secure-proxies-with-spdy-chrome/" target="_blank" rel="noopener">Web-VPN: Secure Proxies with SPDY &amp; Chrome</a></li><li><a href="http://en.wikipedia.org/wiki/File:HTTP_persistent_connection.svg" target="_blank" rel="noopener">File:HTTP persistent connection.svg</a></li><li><a href="https://en.wikipedia.org/wiki/Proxy_server" target="_blank" rel="noopener">Proxy server</a></li><li><a href="https://www.x-cart.com/blog/what-is-https-and-ssl.html" target="_blank" rel="noopener">What Is This HTTPS/SSL Thing And Why Should You Care?</a></li><li><a href="https://securebox.comodo.com/ssl-sniffing/ssl-offloading/" target="_blank" rel="noopener">What is SSL Offloading?</a></li><li><a href="https://docs.oracle.com/cd/E19424-01/820-4811/6ng8i26bn/index.html" target="_blank" rel="noopener">Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption</a></li><li><a href="https://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication" target="_blank" rel="noopener">An Introduction to Mutual SSL Authentication</a></li><li><a href="https://danielmiessler.com/study/url-uri/" target="_blank" rel="noopener">The Difference Between URLs and URIs</a></li><li><a href="https://juejin.im/entry/5766c29d6be3ff006a31b84e#comment" target="_blank" rel="noopener">Cookie 与 Session 的区别</a></li><li><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noopener">COOKIE 和 SESSION 有什么区别</a></li><li><a href="https://harttle.land/2015/08/10/cookie-session.html" target="_blank" rel="noopener">Cookie/Session 的机制与安全</a></li><li><a href="https://shijianan.com/2017/06/11/https/" target="_blank" rel="noopener">HTTPS 证书原理</a></li><li><a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn" target="_blank" rel="noopener">What is the difference between a URI, a URL and a URN?</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a></li><li><a href="https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/" target="_blank" rel="noopener">XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?</a></li><li><a href="https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences" target="_blank" rel="noopener">Symmetric vs. Asymmetric Encryption – What are differences?</a></li><li><a href="https://www.kancloud.cn/digest/web-performance-http2" target="_blank" rel="noopener">Web 性能优化与 HTTP/2</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">HTTP/2 简介</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-基础概念&quot;&gt;一 、基础概念&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#url&quot;&gt;URL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#请求和响应报文&quot;&gt;请求和响应报文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二http-方法&quot;&gt;二、HTTP 方法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#get&quot;&gt;GET&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#head&quot;&gt;HEAD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#post&quot;&gt;POST&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#put&quot;&gt;PUT&lt;/a&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="通信协议" scheme="http://yoursite.com/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
</feed>
